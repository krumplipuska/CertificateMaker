<html lang="en" style="--zoom: 1; --left-panel-width: 152px; --right-panel-width: 354px;"><head>
  <meta charset="utf-8">
  <title>Minimal A4 Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <style>
#lasso { position: fixed; border:1px dashed #888; background: rgba(128,128,128,0.12); pointer-events: none; z-index: 99999; }

/* Selection group box */
.selbox { position:fixed; border:1px dashed rgba(124,58,237,.45); border-radius:6px; pointer-events:none; z-index: 800; background: transparent; }
.selbox.hidden { display:none; }
.selbox .sb-h { position:absolute; width:10px; height:10px; border-radius:50%; background:#fff; border:2px solid #7c3aed; box-shadow:0 1px 2px rgba(0,0,0,.1); pointer-events:auto; }
.selbox .sb-h[data-handle="nw"]{ left:-6px; top:-6px; }
.selbox .sb-h[data-handle="n"]{ left:50%; top:-6px; transform:translateX(-50%); }
.selbox .sb-h[data-handle="ne"]{ right:-6px; top:-6px; }
.selbox .sb-h[data-handle="e"]{ right:-6px; top:50%; transform:translateY(-50%); }
.selbox .sb-h[data-handle="se"]{ right:-6px; bottom:-6px; }
.selbox .sb-h[data-handle="s"]{ left:50%; bottom:-6px; transform:translateX(-50%); }
.selbox .sb-h[data-handle="sw"]{ left:-6px; bottom:-6px; }
.selbox .sb-h[data-handle="w"]{ left:-6px; top:50%; transform:translateY(-50%); }
/* Move and rotate handles */
.selbox .sb-h[data-handle="rotate"]{ right:50%; bottom:-24px; transform:translate(50%,50%); width:12px; height:12px; border-radius:50%; border-color:#3b82f6; cursor: grab; }
/* Move handle moved down next to rotation handle (offset to the right) */
.selbox .sb-h[data-handle="move"]{ left:calc(50% + 20px); bottom:-24px; transform:translate(-50%,50%); width:12px; height:12px; border-radius:4px; border-color:#10b981; cursor: grab; }
.selbox .sb-h[data-handle="move"]::after{ content:""; position:absolute; inset:2px; background:#10b981; border-radius:2px; }
.selbox .sb-h[data-handle="rotate"]::after{ content:""; position:absolute; inset:2px; border-radius:50%; background:#3b82f6; }
/* Resize cursors for handles */
.selbox .sb-h[data-handle="n"], .selbox .sb-h[data-handle="s"] { cursor: ns-resize; }
.selbox .sb-h[data-handle="e"], .selbox .sb-h[data-handle="w"] { cursor: ew-resize; }
.selbox .sb-h[data-handle="ne"], .selbox .sb-h[data-handle="sw"] { cursor: nesw-resize; }
.selbox .sb-h[data-handle="nw"], .selbox .sb-h[data-handle="se"] { cursor: nwse-resize; }
/* Layout & theme for refactored editor */
:root{
  /* Use real-world millimeter dimensions so exports map directly to A4 */
  --page-w: 210mm;  /* A4 width */
  --page-h: 297mm;  /* A4 height */
  /* MonTech brand */
  --brand-primary: #E10600;
  --brand-dark: #222222;
  --brand-light: #F5F5F5;
  --brand-white: #FFFFFF;
  /* App theme mapped to brand */
  --bg: var(--brand-light);
  --panel: var(--brand-white);
  --ink: var(--brand-dark);
  --muted: #6b6b6b;
  --primary: var(--brand-primary);
  --border: #e5e5e5;
  --shadow: 0 2px 8px rgba(0,0,0,.06), 0 10px 20px rgba(0,0,0,.04);
  --zoom: 1;
  /* Panel dimensions */
  --left-panel-width: 200px;
  --right-panel-width: 240px;
  accent-color: var(--primary);
}
html, body { margin: 0; height: 100%; background: var(--bg); color: var(--ink);
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial; }

/* Top bar */
.topbar { position: fixed; inset: 0 0 auto 0; height: 44px; background: var(--brand-primary); color: var(--brand-white); display: flex; align-items: center; gap: 6px; padding: 0 10px; box-shadow: var(--shadow); z-index: 1100; }
/* Make groups transparent for a cleaner bar */
.topbar .group { display: inline-flex; gap: 6px; border: 0; border-radius: 999px; padding: 0; background: transparent; }
/* Simple, outlined white pills inside the red bar */
.topbar .btn { background: transparent; color: #fff; border-color: rgba(255,255,255,.9); border-radius: 999px; transition: background-color .15s ease, color .15s ease, border-color .15s ease, transform .15s ease; }
/* Prominent hover/focus: white pill, brand text/icon */
.topbar .btn:hover,
.topbar .btn:focus-visible { background: #fff; color: var(--brand-primary); border-color: #fff; transform: translateY(-1px); }
/* Icons follow text color so hover/focus recolors them too */
.topbar > .group .btn .icon { color: currentColor; }
.topbar > .group .btn .icon circle { fill: currentColor; }
.topbar #moreMenu { z-index: 1201; }
/* Ensure dropdown buttons use regular palette, not the white-on-red topbar style */
.topbar #moreMenu { 
  position: absolute;
  top: 36px;
  right: 0;
  background: #fff;
  border: 1px solid rgba(0,0,0,0.08);
  border-radius: 12px;
  box-shadow: var(--shadow);
  padding: 6px;
  min-width: 220px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.topbar #moreMenu .btn { background: transparent; color: var(--ink); border: none; border-radius: 8px; padding: 10px 12px; justify-content: flex-start; width: 100%; margin: 0; font-size: 14px; font-weight: 500; transition: color .2s ease, background .2s ease; display: flex; align-items: center; gap: 10px; text-align: left; }
.topbar #moreMenu .btn:hover { background:#f9fafb; color: var(--brand-primary); }
.topbar #moreMenu .btn .icon { color: currentColor; flex-shrink: 0; width: 16px; height: 16px; }
.topbar #moreMenu .btn span { 
  font-weight: 500;
  letter-spacing: 0.01em;
  flex: 1;
}
.topbar #moreMenu hr { 
  border: none; 
  border-top: 1px solid rgba(0,0,0,0.06); 
  margin: 6px 0; 
  border-radius: 1px;
}
.topbar #docTitleGroup { position: absolute; left: 50%; transform: translateX(-50%); }
.topbar #docTitleGroup .btn { transition: background-color .15s ease, color .15s ease, border-color .15s ease; }
/* When renaming (input focused), switch to white pill + brand accent */
#docTitleGroup .btn:focus-within { background: #fff; color: var(--brand-primary); border-color: #fff; }
.btn { height: 26px; padding: 0 8px; border: 1px solid var(--border); border-radius: 8px; background: #fff; color: var(--ink); cursor: pointer; display: inline-flex; align-items: center; justify-content: center; gap: 6px; transition: border-color .15s, background .15s, color .15s; }
.btn:hover{ background: color-mix(in srgb, var(--primary) 8%, #fff); border-color: color-mix(in srgb, var(--primary) 20%, var(--border)); }
.btn.mini{ height: 22px; padding: 0 6px; font-size: 12px; }
.btn.mini:hover{ background: color-mix(in srgb, var(--primary) 8%, #fff); border-color: color-mix(in srgb, var(--primary) 20%, var(--border)); }
.btn.saving{ background: #fef3c7; border-color: #f59e0b; color: #92400e; }
.btn.saved{ background: #ecfdf5; border-color: #10b981; color: #065f46; }
.spacer { flex: 1; }
.topbar #docTitleGroup .btn { max-width: 420px; }
#docTitleText { max-width: 360px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
/* Title input inside red bar */
#docTitleInput { color:#fff; transition: background-color .15s ease, color .15s ease; }
#docTitleInput::placeholder { color: rgba(255,255,255,.8); }
/* Override inline styles while typing to ensure readability */
#docTitleInput:focus { background:#fff !important; color: var(--brand-dark) !important; }
#docTitleInput:focus::placeholder { color: rgba(0,0,0,.5) !important; }
/* Also recolor the title text on hover of the pill */
.topbar #docTitleGroup .btn:hover #docTitleInput,
.topbar #docTitleGroup .btn:focus-visible #docTitleInput { color: var(--brand-primary) !important; }
.topbar #version { font-size: 12px; color: var(--muted); display: flex; align-items: center; }
.pages-strip { display:flex; gap:6px; margin-right:8px; }
.pages-strip .page-tab { padding: 6px 10px; border:1px solid var(--border); border-radius: 8px; background:#fff; cursor:pointer; }
.pages-strip .page-tab.active { border-color: var(--primary); color: var(--primary); background:#eef2ff; }
.switch { display:inline-flex; align-items:center; gap:8px; font-size:14px; }

/* App layout */
.app { padding-top: calc(48px + 44px + 16px); display: grid; grid-template-columns: 1fr; gap: 12px; align-items: start; }
.side { background:#fff; border:1px solid var(--border); border-radius:10px; padding: 0; height: calc(100dvh - 96px); position: fixed; top: 64px; overflow:hidden; z-index: 1000; transition: width 0.3s ease, left 0.3s ease, right 0.3s ease; box-shadow: var(--shadow); }
.side.left { left:12px; width: var(--left-panel-width); }
.side.right { right:12px; width: var(--right-panel-width); }
.side.collapsed { width: 32px !important; }
.side.collapsed .panel-content { display: none; }
.side.collapsed .panel-header h3 { display: none; }
.side.left.collapsed ~ .workspace #pageViewport { padding-left: 44px; }
.side.right.collapsed ~ .workspace #pageViewport { padding-right: 44px; }

/* Panel structure */
.panel-header { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid var(--border); background: var(--brand-dark); border-radius: 10px 10px 0 0; }
.panel-header h3 { margin: 0; font-size: 14px; color: var(--brand-white); }
.panel-toggle { background: none; border: none; cursor: pointer; padding: 4px; color: var(--muted); font-size: 16px; border-radius: 4px; transition: background 0.15s ease, color 0.15s ease; }
.panel-toggle:hover { background: color-mix(in srgb, var(--primary) 8%, #fff); color: var(--primary); }
.panel-toggle .icon { display:block; width:16px; height:16px; transition: transform .15s ease; }
.panel-toggle[data-dir="right"] .icon { transform: rotate(180deg); }
.panel-content { padding: 10px; overflow-y: auto; height: calc(100% - 60px); }

/* Panel resize handles */
.panel-resize-handle { position: absolute; top: 0; bottom: 0; width: 4px; background: transparent; cursor: ew-resize; z-index: 1001; transition: background 0.15s ease; }
.panel-resize-handle:hover { background: var(--primary); }
.panel-resize-right { right: -2px; }
.panel-resize-left { left: -2px; }

.props { display:grid; grid-template-columns: 1fr; row-gap: 6px; font-size: 12px; }
.props .row { display: contents; }
.props .row > label { grid-column: 1 / -1; display:flex; align-items:center; color: var(--muted); font-size: 11px; margin-left: 2px; }
.props .row input:not([type="checkbox"]):not([type="radio"]), .props .row select, .props .row textarea { width: 100%; box-sizing: border-box; padding: 6px 8px; border:1px solid var(--border); border-radius:8px; font-size: 12px; height: 30px; transition: border-color .15s, background .15s; }
.props .row input:not([type="checkbox"]):not([type="radio"]):hover, .props .row select:hover, .props .row textarea:hover { border-color: color-mix(in srgb, var(--primary) 20%, var(--border)); background: color-mix(in srgb, var(--primary) 2%, #fff); }
.props .row input:not([type="checkbox"]):not([type="radio"]):focus, .props .row select:focus, .props .row textarea:focus { border-color: var(--primary); background: color-mix(in srgb, var(--primary) 4%, #fff); outline: none; }
.props .row input[type="checkbox"] { width: 16px; height: 16px; padding: 0; margin: 0; border-radius: 4px; }
.props .row textarea { height: 60px; resize: vertical; }
.props .row input[aria-invalid="true"]{ border-color:#ef4444; background:#fee2e2; }
.props .row .row-hint { grid-column: 1 / -1; font-size: 11px; color: var(--muted); }
.props .add-wrap { grid-column: 1 / -1; display:flex; justify-content:center; margin-top:6px; }
.props .add-wrap button { width:28px; height:28px; border-radius:8px; border:1px solid var(--border); background:#f9fafb; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; }

/* Workspace and page */
.workspace { display: grid; grid-template-columns: 1fr; }
#pageViewport { height: calc(100dvh - 96px); overflow:auto; display:grid; place-items:start center; padding-left: calc(var(--left-panel-width) + 12px); padding-right: calc(var(--right-panel-width) + 12px); }
#pageContainer { padding: 12px; }
.page { position: relative; width: var(--page-w); height: var(--page-h); background:#fff; box-shadow: var(--shadow); overflow:visible; border-radius:6px; transform: scale(var(--zoom)); transform-origin: top left; }
/* grid background removed per request (no ::before) */

/* Elements */
.element { position:absolute; box-sizing:border-box; outline:none; user-select:none; touch-action:none; }

/* Image elements */
.element.image { overflow:hidden; }
.element.image img { 
  width: 100%; 
  height: 100%; 
  object-fit: contain; 
  object-position: center;
  display: block;
}
/* .element.selected { box-shadow: inset 0 0 0 1.5px var(--primary); } */
.text { min-width:10px; min-height:10px; padding:6px 8px; border:1px solid var(--border); border-radius:4px; background:#fff; color:var(--ink); line-height:1.4; font-size:14pt; overflow:hidden; white-space:pre-wrap; word-break:break-word; }
/* NEW: make field look and behave like text */
.field {
  min-width:10px; min-height:10px; padding:6px 8px;
  border:1px solid var(--border); border-radius:4px;
  background:#fff; color:var(--ink); line-height:1.4; font-size:14pt;
  overflow:hidden; white-space:pre-wrap; word-break:break-word;
}

/* Allow caret & selection while editing */
.text.editing, .field.editing { cursor:text; user-select:text; }

/* Placeholder styling */
.text.has-placeholder, .field.has-placeholder { 
  color: #999; 
  font-style: italic; 
}

/* Table element */
.element.table { position:absolute; background:#fff; }

/* Grid host */
.table-grid {
  display:grid;
  width:100%; height:100%;
  user-select:none;           /* selection handled by app */
}

/* Cells */
.table-cell {
  display:flex;
  align-items:flex-start;     /* vertical alignment */
  justify-content:flex-start; /* horizontal alignment */
  padding:6px 8px;
  font-size:14pt; line-height:1.4;
  white-space:pre-wrap; word-break:break-word;
  /* outline removed; borders are set per-cell inline */
  background: transparent;
}

/* Editing */
.table-cell[contenteditable="true"] {
  cursor:text;
  user-select:text;
  outline-offset:-1px;
}

/* Focus ring for the active cell (roving tabindex) */
.table-cell:focus-visible { outline: none; }
/* Improve caret visibility while editing */
.table-cell[contenteditable="true"] {
  caret-color: currentColor;
}

/* Selection (cell/range): darken existing cell background without recoloring */
.table-cell.is-selected,
.table-cell.is-range    { background-image: none; }

/* Excel-like selection border overlay */
.table-selection {
  position:absolute;
  pointer-events:none;
  border:2px solid #059669;           /* emerald-600 */
  box-sizing: border-box;
  box-shadow: 0 0 0 1px rgba(5,150,105,.2) inset;
  border-radius: 2px;
  z-index: 1002;
}
.table-selection .handle {
  position:absolute; width:6px; height:6px;
  right:-4px; bottom:-4px;
  background:#059669; border:2px solid #fff; border-radius:2px;
  box-shadow: 0 0 0 1px #059669;
}

/* Outer border (draw once for crisp edges) */
.table-outer {
  pointer-events:none;
  position:absolute; inset:0;
  /* border:1px solid var(--table-outer, #000); */
}

/* Floating table actions bar */
/* removed .table-actions toolbar; replaced by context menu */

/* Table border drag affordances (shown on hover) */
.table-resizer {
  position:absolute; pointer-events:auto; z-index:1003;
  background: rgba(108,92,231,.55);
}
.table-resizer.v { width:2px; top:0; bottom:0; }
.table-resizer.h { height:2px; left:0; right:0; }
.table-grid.resizing { cursor: col-resize; }
.table-grid.resizing.row { cursor: row-resize; }
/* In view mode, force normal cursor inside tables */
.edit-off .table-grid, .edit-off .table-cell { cursor: default !important; }
.edit-off .table-grid.resizing, .edit-off .table-grid.resizing.row { cursor: default !important; }
.rect { border:1px solid var(--border); background:var(--brand-light); border-radius:6px; min-width:10px; min-height:10px; padding:6px 8px; line-height:1.4; overflow:hidden; white-space:pre-wrap; word-break:break-word; }
.line { height:2px; width:40px; background:#111827; transform-origin:0 0; }

/* Block container (stacked column) */
.element.block {
  background:#fff;
  border:1px solid var(--border);
  border-radius:8px;
  padding:8px;
}
.element.block > .element { position:absolute; }

/* Handles */
.handle { position:absolute; width:10px; height:10px; background:#fff; border:2px solid #10b981; border-radius:50%; box-shadow:0 1px 2px rgba(0,0,0,.1); pointer-events:all; }
.handle.corner { margin:-6px 0 0 -6px; }
.handle.tl{ top:0; left:0; } .handle.tr{ top:0; right:0; } .handle.bl{ bottom:0; left:0; } .handle.br{ bottom:0; right:0; }
.handle.endpoint { margin:-6px 0 0 -6px; z-index:5; }

/* Floating/format toolbar */
.floating { background:var(--panel); border:1px solid var(--border); border-radius:12px; box-shadow: var(--shadow); padding:6px; display:flex; flex-direction:row; gap:8px; z-index: 2000; }
.floating.hidden { display:none; }
.floating .row { display:flex; flex-wrap:nowrap; gap:12px; align-items:center; overflow-x:auto; white-space:nowrap; }
/* Align label text and controls vertically in toolbar */
.floating label { display:inline-flex; align-items:center; gap:6px; }
/* Fixed position for format toolbar under topbar */
#formatToolbar { position: fixed; top: 35px; left: 0; right: 0; margin: 4px auto 0; width: fit-content; z-index: 1100; }
/* Generic icon sizing for buttons */
.btn .icon { width:16px; height:16px; display:block; margin:auto; }

/* Layers and Brand kit (left panel) */
.layers { display:flex; flex-direction:column; gap:4px; font-size:12px; }
.layer-item { display:grid; grid-template-columns: auto 1fr auto auto; align-items:center; gap:6px; padding:4px 6px; border:1px solid var(--border); border-radius:6px; transition: background .15s ease, border-color .15s ease; }
.layer-item:hover { background: color-mix(in srgb, var(--primary) 4%, #fff); border-color: color-mix(in srgb, var(--primary) 20%, var(--border)); }
.layer-item .name { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.brand-kit { display:flex; flex-direction:column; gap:8px; }
.brand-colors { display:grid; grid-template-columns: repeat(8, 1fr); gap:4px; }
.brand-color { width:18px; height:18px; border-radius:4px; border:1px solid var(--border); cursor:pointer; transition: border-color .15s ease; }
.brand-color:hover { border-color: var(--primary); }
.brand-fonts { display:flex; flex-wrap:wrap; gap:6px; }
.brand-font { padding:2px 6px; border:1px solid var(--border); border-radius:6px; cursor:pointer; font-size:12px; transition: background .15s ease, border-color .15s ease; }
.brand-font:hover { background: color-mix(in srgb, var(--primary) 4%, #fff); border-color: color-mix(in srgb, var(--primary) 20%, var(--border)); }

/* Pages list */
#pagesList { display: grid; gap: 32px; place-items: start center; width: 100%; }
.page-wrapper { display: grid; gap: 8px; justify-items: center; }
.page-title { color: var(--muted); font-size: 13px; display:flex; align-items:center; gap:6px; width: calc(var(--page-w) * var(--zoom));z-index: 899; }
.page-title .title-actions { margin-left: auto; float: none !important; }
.page-stage { position: relative; width: calc(var(--page-w) * var(--zoom)); height: calc(var(--page-h) * var(--zoom)); justify-self: center; }
.page-stage .page-title,
.page-stage .page-controls { position: relative; z-index: 1200; }
.page-stage .page { position: relative; z-index: 99; }
/* ensure editor overlays beat elements */
#selectionBox, #elementActions, #tableActions, .guide { z-index: 1500; }
.page-controls { display: inline-flex; gap: 6px; }

/* Element actions bubble */
#elementActions { position: fixed; transform: translate(-50%, -100%); background:var(--panel); border:1px solid var(--border); border-radius: 999px; box-shadow: var(--shadow); padding: 6px; display: inline-flex; gap: 6px; z-index: 900; transition: background .15s ease, border-color .15s ease; }
#elementActions.hidden { display: none; }
#elementActions:hover { background: color-mix(in srgb, var(--primary) 4%, #fff); border-color: color-mix(in srgb, var(--primary) 20%, var(--border)); }
#elementActions .menu { display: inline-flex; gap: 6px; }
#elementActions .dropdown.hidden { display: none; }
/* Compact icon menu inside actions dropdown */
#elementActions .dropdown .icon-row{ display:flex; gap:4px; align-items:center; justify-content:space-around; }
#elementActions .dropdown .group{ display:flex; flex-direction:column; gap:4px; }
#elementActions .dropdown .group-label{ font-size:11px; color:var(--muted); padding:0 2px; line-height:1; }
#elementActions .dropdown .btn.mini{ width:50%; height:26px; padding:0; display:inline-flex; align-items:center; justify-content:center; }

/* Floating table actions (small bubble) */
#tableActions { position: fixed; top: 72px; left: 0; right: 0; margin: 0 auto; transform: none; background:var(--panel); border:1px solid var(--border); border-radius: 12px; box-shadow: var(--shadow); padding: 6px; display: inline-flex; gap: 6px; z-index: 1150; width: fit-content; }
#tableActions.hidden { display: none; }

/* Alignment guides */
.guide { position: absolute; pointer-events: none; background: var(--primary); opacity: .8; z-index: 1500; }
.guide.v { width: 2px; height: 100%; top: 0; }
.guide.h { height: 2px; width: 100%; left: 0; }

/* generic hidden utility */
.hidden { display: none !important; }

/* Hub view */
.hub-header { position: fixed; left: 12px; right: 12px; top: 8px; height: 44px; background: var(--brand-primary); color: #fff; border-radius: 999px; display: flex; align-items: center; justify-content: space-between; padding: 0 10px 0 10px; box-shadow: var(--shadow); z-index: 1100; }
.hub-title { font-size: 12px; opacity: .95; }
.hub-save { background: var(--brand-dark); color:#fff; border-color: var(--brand-dark); }
/* Make hub header buttons visually match editor topbar pills */
.hub-header .btn { background: transparent; color: #fff; border-color: rgba(255,255,255,.9); border-radius: 999px; transition: background-color .15s ease, color .15s ease, border-color .15s ease, transform .15s ease; }
/* Match editor topbar prominent hover */
.hub-header .btn:hover,
.hub-header .btn:focus-visible { background:#fff; color: var(--brand-primary); border-color:#fff; transform: translateY(-1px); }
.hub-header .btn .icon { color: currentColor; }
.hub-header .btn .icon circle { fill: currentColor; }
.hub-header #hubMoreMenu { position:absolute; top:36px; right:0; background:#fff; border:1px solid rgba(0,0,0,0.08); border-radius:12px; box-shadow: var(--shadow); padding:6px; min-width:200px; display:flex; flex-direction:column; gap:4px; }
.hub-header #hubMoreMenu .btn { background:transparent; color:var(--ink); border:none; border-radius:8px; padding:10px 12px; justify-content:flex-start; width:100%; margin:0; font-size:14px; font-weight:500; transition: color .2s ease, background .2s ease; display:flex; align-items:center; gap:10px; text-align:left; }
.hub-header #hubMoreMenu .btn:hover { background:#f9fafb; color: var(--brand-primary); }
.hub-panel { position: fixed; top: 60px; bottom: 12px; left: 50px; right: 50px; background: var(--bg); display: grid; grid-template-rows: auto 1fr; padding: 8px; }
.hub-actions { display:flex; gap:8px; padding: 4px 6px 8px; align-items:center; flex-wrap:wrap; }
.doc-row.dragging { opacity:.6; }
/* Single global marker line shown between items while dragging (overlay, no reflow) */
.doc-drop-marker { position: absolute; left: 8px; right: 8px; top: 0; height: 0; border-top: 3px solid var(--primary); border-radius: 4px; pointer-events: none; z-index: 2; }
.doc-list { overflow: auto; padding-right: 4px; display: grid; gap: 10px; grid-auto-rows: min-content; position: relative; }
.doc-row { display:grid; grid-template-columns: 1fr auto; align-items:center; gap: 8px; background:var(--brand-white); border:1px solid var(--border); border-radius: 999px; padding: 8px 10px; transition: background-color .15s ease, border-color .15s ease, box-shadow .15s ease; }
.doc-row:hover { background: color-mix(in srgb, var(--primary) 6%, #f8fafc); border-color: color-mix(in srgb, var(--primary) 28%, var(--border)); box-shadow: 0 1px 2px rgba(0,0,0,.06); }
.doc-row:focus-within { background: color-mix(in srgb, var(--primary) 9%, #f8fafc); border-color: color-mix(in srgb, var(--primary) 38%, var(--border)); box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary) 20%, transparent); }
.doc-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.doc-meta { font-size:12px; color: var(--muted); margin-right: 8px; }
.doc-actions { display:inline-flex; gap:6px; }
.doc-actions .btn { height: 24px; padding: 0 6px; }
body.in-hub .topbar, body.in-hub #formatToolbar, body.in-hub .side, body.in-hub .workspace { display: none !important; }

/* Inline rename input in hub list */
.doc-edit { width: auto; display:inline-block; box-sizing: border-box; border: 1px solid var(--border); border-radius: 8px; padding: 2px 6px; height: 24px; line-height: 20px; font-size: 14px; }
.doc-row.editing { background:#fff; border-color: var(--primary); box-shadow: 0 0 0 1px color-mix(in srgb, var(--primary) 20%, transparent); }

/* Folder bar (flat pills) */
#folderBar { position: relative; }
.folder-pill { display:inline-flex; align-items:center; gap:6px; height:28px; padding: 0 10px; border-radius: 999px; background: #f3f4f6; border: 1px solid var(--border); color: #111827; cursor: pointer; transition: background .12s ease, border-color .12s ease, color .12s ease, transform .12s ease; }
.folder-pill:hover, .folder-pill:focus-visible, .folder-pill.drag-over { background:#eef2ff; border-color: color-mix(in srgb, var(--primary) 35%, var(--border)); color: #1f2937; transform: translateY(-1px); }
.folder-pill.active { background:var(--brand-dark); border-color: var(--brand-dark); color: #fff; }
.folder-pill .icon { color: currentColor; }
.folder-pill .rename-input { height: 18px; border:1px solid var(--border); border-radius:6px; padding:0 6px; font-size:10px; background:#fff; color:var(--brand-dark); }
.folder-pill .close-btn { width:20px; height:20px; display:inline-flex; align-items:center; justify-content:center; border-radius:999px; background: transparent; border: none; color: inherit; }
.folder-pill .close-btn:hover { background: rgba(0,0,0,.08); }

.folder-plus { display:inline-flex; align-items:center; justify-content:center; width:28px; height:28px; border-radius:999px; border:1px dashed var(--border); background:var(--bg); color:#6b7280; cursor:pointer; }
.folder-plus:hover { background:#f3f4f6; color:#111827; border-style:solid; }
/* Drag-over highlight for folder drop */
/* .folder-pill.drag-over { outline: 2px solid var(--primary); outline-offset: 2px; background: #eef2ff; border-color: color-mix(in srgb, var(--primary) 45%, var(--border)); } */

/* Confirm dialog buttons */
#confirmDialog .btn.primary { background: var(--brand-primary); color:#fff; border-color: var(--brand-primary); }
#confirmDialog .btn.danger { background: #ef4444; color:#fff; border-color: #ef4444; }
#confirmDialog .btn.light { background: #f9fafb; }

/* Rulers */
.ruler { position:fixed; background:#fff; border:1px solid var(--border); z-index:1050; box-shadow:var(--shadow); }
.ruler.h { left:12px; right:12px; top:35px; height:20px; }
.ruler.v { top:64px; bottom:16px; left:12px; width:20px; }

/* Header/Footer guides (edit-mode only) */
.hf-guide { position:absolute; left:0; right:0; background: transparent; border:1px dashed rgba(59,130,246,.35); box-sizing: border-box; pointer-events: none; z-index: 50; }
.hf-guide.header { top:0; }
.hf-guide.footer { bottom:0; }
.hf-guide .hf-label { position:absolute; left:8px; top:6px; font-size:11px; color:#1f2937; background:transparent; padding:0; border-radius:0; border:none; pointer-events:none; }
.hf-guide .hf-label::after { content:''; }
.hf-guide.footer .hf-label { top:auto; bottom:6px; }
.hf-guide .hf-resize { position:absolute; left:0; right:0; height:8px; background: transparent; cursor: ns-resize; pointer-events: auto; }
.hf-guide.header .hf-resize { bottom:-4px; }
.hf-guide.footer .hf-resize { top:-4px; }
.element.repeated { pointer-events: none !important; }

/* Hide guides in view/export mode and PDF/export */
.edit-off .hf-guide { display: none !important; }
.__export_sandbox .hf-guide { display: none !important; }

/* circular color inputs */
input[type="color"].circle { appearance: none; -webkit-appearance: none; border: none; width: 24px; height: 24px; padding: 0; background: none; }
input[type="color"].circle::-webkit-color-swatch-wrapper { padding: 0; transition: border-color .15s ease; }
input[type="color"].circle::-webkit-color-swatch { border: 1px solid var(--border); border-radius: 999px; transition: border-color .15s ease; }
input[type="color"].circle:hover::-webkit-color-swatch { border-color: var(--primary); }

/* Custom Color Picker */
.custom-color-picker {
  position: fixed;
  background: white;
  border: 1px solid var(--border);
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.12);
  padding: 12px;
  z-index: 2100;
  width: 260px; /* widened to fit recent colors comfortably */
}

.custom-color-picker.hidden {
  display: none;
}

.color-picker-section {
  margin-bottom: 12px;
}

.color-picker-section h4 {
  margin: 0 0 8px 0;
  font-size: 12px;
  font-weight: 600;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.color-history-grid {
  display: grid;
  grid-template-columns: repeat(10, 1fr); /* more columns for more chips */
  gap: 6px;
  margin-bottom: 12px;
}

.color-history-circle {
  width: 22px;
  height: 22px;
  border-radius: 50%;
  border: 2px solid transparent;
  cursor: pointer;
  transition: all 0.15s ease;
  position: relative;
}

.color-history-circle:hover {
  transform: scale(1.05);
  border-color: var(--primary);
}

.color-history-circle.selected {
  border-color: var(--primary);
}

.color-picker-input-wrapper {
  display: flex;
  align-items: center;
  gap: 8px;
}

.color-picker-input-wrapper input[type="color"] {
  width: 40px;
  height: 40px;
  border-radius: 8px;
  border: 1px solid var(--border);
  cursor: pointer;
}

.color-picker-hex {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-family: 'Monaco', 'Menlo', monospace;
  font-size: 13px;
}

/* Toolbar toggle pressed state */
.btn[aria-pressed="true"] { background: color-mix(in srgb, var(--primary) 12%, #fff); border-color: var(--primary); color: var(--primary); }
.btn[aria-pressed="true"]:hover { background: color-mix(in srgb, var(--primary) 16%, #fff); border-color: color-mix(in srgb, var(--primary) 20%, var(--border)); }

/* Alignment hamburger icons (simple CSS drawing) */
/* Align buttons now use inline SVG; show only the active state group */
.align { position: relative; width: 28px; height: 28px; }
.align .icon { width: 16px; height: 16px; }
.align .h-icon, .align .v-icon { display: none; }
.align.h-left .h-icon.h-left { display: block; }
.align.h-center .h-icon.h-center { display: block; }
.align.h-right .h-icon.h-right { display: block; }
.align.v-top .v-icon.v-top { display: block; }
.align.v-middle .v-icon.v-middle { display: block; }
.align.v-bottom .v-icon.v-bottom { display: block; }

/* View mode: hide editing UI */
.edit-off #formatToolbar,
.edit-off #elementActions,
.edit-off #tableActions,
.edit-off .selbox,
.edit-off #lasso,
.edit-off .guide { display: none !important; }
.edit-off .page .element { cursor: default; }
.edit-off .page .element.selected { box-shadow: none; }
.edit-off .element.repeated { pointer-events: none; }
.edit-off .page-title .title-actions { visibility: hidden; }

/* (Removed explicit visual styling for freeMove elements; they appear like normal elements) */
.edit-off .side { display: none; }
.edit-off .app { grid-template-columns: 1fr; }
/* Export sandbox guard: ensure no transforms leak into the clone */
.__export_sandbox, .__export_sandbox * {
  transform: none !important;
}

/* Deterministic image boxes used by the editor */
.image-box {
  position: relative;
  display: flex;
  align-items: center;   /* vertical center (html2canvas-safe) */
  justify-content: center;
  overflow: hidden;
  box-sizing: border-box;  /* borders don't change content size */
}

/* Images on the canvas should behave the same in editor and export */
.canvas img,
.image-box img {
  display: block;           /* kill baseline alignment shifts */
  max-width: 100%;
  max-height: 100%;
  width: auto;
  height: auto;
  object-fit: contain;      /* don't crop */
  object-position: center;  /* center inside its box */
}

/* Background image boxes (alternative for maximum html2canvas reliability) */
.bg-image-box {
  background-repeat: no-repeat;
  background-position: center;
  background-size: contain;   /* or 'cover' if you want fill */
  box-sizing: border-box;
}

/* Not used. Styles are embedded in index.html for a single-file app per request. */



/* Disable text selection during drags/resizes */
body.app-noselect, body.app-noselect * { user-select: none !important; }
/* Hide complex controls from the simplified top bar (keep undo/redo visible) */
.topbar #viewToggles { display: none !important; }
/* Make undo/redo icon-only in the top bar */
.topbar #undoBtn span, .topbar #redoBtn span { display: none; }

/* Bottom-right floating zoom control */
.zoom-control { position: fixed; right: 12px; bottom: 12px; background: var(--panel); border:1px solid var(--border); border-radius: 999px; box-shadow: var(--shadow); padding: 6px 8px; display:inline-flex; align-items:center; gap:8px; z-index: 1200; transition: background .15s ease, border-color .15s ease; }
.zoom-control:hover { background: color-mix(in srgb, var(--primary) 4%, #fff); border-color: color-mix(in srgb, var(--primary) 20%, var(--border)); }
.zoom-control input[type="range"]{ width: 160px; transition: background .15s ease; }
.zoom-control input[type="range"]:hover { background: color-mix(in srgb, var(--primary) 2%, transparent); }
.zoom-control #zoomLabel { font-size: 12px; color: var(--ink); transition: color .15s ease; }
.zoom-control:hover #zoomLabel { color: var(--primary); }

  </style>

  <!-- External libs for export (CDN). Works offline once loaded. -->
  <!-- <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" defer></script> -->
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js" integrity="sha512-GsLlZN/3F2ErC5ifS5QtgpiJtWd43JWSuIgh7mbzZ8zBps+dvLusV+eNQATqgA/HdeKFVgA5v3S/cIrLF7QnIg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  
  
  
  
  
  
  
  
  
  
  
  
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" async="" crossorigin="anonymous" referrerpolicy="no-referrer" data-dynamic-src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" data-loaded="true"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" async="" crossorigin="anonymous" referrerpolicy="no-referrer" data-dynamic-src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" data-loaded="true"></script></head>
<body class="in-hub edit-off" style="">
  <!-- Hub view (hidden by default). All documents are stored inline in __docs__ -->
  <div id="hubView">
    <div id="hubHeader" class="hub-header">
      <div id="hubFileTitle" class="hub-title">The whole file(app) name (like index.html)</div>
      <div style="display:inline-flex;align-items:center;gap:6px">
        <button id="newDocBtn" class="btn" title="Create new document">
          <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path></svg>
          <span>New</span>
        </button>
        <button id="hubSaveBtn" class="btn hub-save saving" title="Save this file" aria-busy="true" data-original-text="Save">Saving…</button>
        <div class="menu" style="position:relative">
          <button class="btn" id="hubMoreMenuBtn" title="More options" aria-haspopup="true" aria-expanded="false">
            <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><circle cx="5" cy="12" r="2"></circle><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle></svg>
          </button>
          <div class="dropdown hidden" id="hubMoreMenu">
            <button id="hubSettingsBtn" class="btn mini"><svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 8a4 4 0 110 8 4 4 0 010-8z" fill="none" stroke="currentColor" stroke-width="2"></path><path d="M4 12h2M18 12h2M12 4v2M12 18v2M6.2 6.2l1.4 1.4M16.4 16.4l1.4 1.4M17.8 6.2l-1.4 1.4M7.6 16.4l-1.4 1.4" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path></svg><span>Settings</span></button>
          </div>
        </div>
      </div>
    </div>
    <div class="hub-panel">
      <div class="hub-actions" id="folderBar" aria-label="Folders">
        <button class="folder-pill active" data-fid="all" aria-current="page">
          <svg class="icon" width="14" height="14" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 7h6l2 2h10v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" fill="currentColor"></path></svg>
          <span class="folder-name">All</span>
          
        </button><button class="folder-plus" id="addFolderBtn" title="New folder" aria-label="New folder">+
        </button></div>
      <div id="docList" class="doc-list" aria-label="Documents"></div>
    </div>
    <script id="__docs__" type="application/json">{"catalog":[],"docs":{},"folders":[],"docFolders":{}}</script>
  </div>

  <div id="editorView" hidden="">
  <!-- Top bar -->
  <div class="topbar">
    <div class="group">
      <button id="backToHubBtn" class="btn" title="Back to hub" aria-label="Back to hub" hidden="">
        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M15 18l-6-6 6-6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
      </button>
    </div>
    <div class="group">
      <button id="editToggleBtn" class="btn" aria-pressed="false" title="View mode" aria-label="View mode"><svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7S1 12 1 12z" fill="none" stroke="currentColor" stroke-width="2"></path><circle cx="12" cy="12" r="3" fill="currentColor"></circle></svg><span>View mode</span></button>
    </div>
    <div class="group">
      <button id="undoBtn" class="btn" title="Undo" aria-label="Undo">
        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M9 8l-4 4 4 4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>
      </button>
      <button id="redoBtn" class="btn" disabled="" title="Redo" aria-label="Redo">
        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M15 8l4 4-4 4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>
      </button>
    </div>
    <div class="group" id="viewToggles">
      <label class="switch"><input id="snapToggle" type="checkbox" checked=""><span>Snap</span></label>
      <!-- Guides & Minimap toggles temporarily removed per request -->
      <label class="switch" style="display:none"><input id="guidesToggle" type="checkbox"><span>Guides</span></label>
      <label class="switch" style="display:none"><input id="minimapToggle" type="checkbox"><span>Minimap</span></label>
      <label class="switch" style="display:none"><input id="rulersToggle" type="checkbox"><span>Rulers</span></label>
    </div>
    <div class="group" id="docTitleGroup">
      <div class="btn" style="gap:6px">
        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 6h16v12H4z" fill="none" stroke="currentColor" stroke-width="2"></path><path d="M4 10h16" stroke="currentColor" stroke-width="2"></path><path d="M8 14h8" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path></svg>
        <input id="docTitleInput" type="text" value="Untitled" aria-label="Document name" style="border:none;outline:none;background:transparent;color:#fff;max-width:360px">
      </div>
    </div>
    <div class="spacer"></div>
    <div class="group">
      <button id="saveBtn" class="btn saving" aria-busy="true" data-original-text="Save">Saving…</button>
      <div class="menu" style="position:relative">
        <button class="btn" id="moreMenuBtn" title="More options" aria-haspopup="true" aria-expanded="false">
          <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><circle cx="5" cy="12" r="2"></circle><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle></svg>
      </button>
        <div class="dropdown hidden" id="moreMenu">
          <button id="saveAsBtn" class="btn mini"><svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M5 5h12v14H5z" fill="none" stroke="currentColor" stroke-width="2"></path><path d="M9 5v6h6V5" fill="none" stroke="currentColor" stroke-width="2"></path><path d="M12 13v6" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><path d="M9 16h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path></svg><span>Save As</span></button>
          <button id="savePdfBtn" class="btn mini"><svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3v8" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><path d="M8 9l4 4 4-4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M5 19h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path></svg><span>Export PDF</span></button>
          <button id="exportPngBtn" class="btn mini"><svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3v8" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><path d="M8 9l4 4 4-4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M5 19h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path></svg><span>Export PNG</span></button>
          <button id="exportJpgBtn" class="btn mini"><svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3v8" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><path d="M8 9l4 4 4-4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M5 19h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path></svg><span>Export JPG</span></button>
          <hr>
          <button id="settingsBtn" class="btn mini"><svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 8a4 4 0 110 8 4 4 0 010-8z" fill="none" stroke="currentColor" stroke-width="2"></path><path d="M4 12h2M18 12h2M12 4v2M12 18v2M6.2 6.2l1.4 1.4M16.4 16.4l1.4 1.4M17.8 6.2l-1.4 1.4M7.6 16.4l-1.4 1.4" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path></svg><span>Settings</span></button>
        </div>
      </div>
    </div>
  </div>

  <div class="app">
    <aside class="side left" id="elementsPanel" style="width: 152px;">
      <div class="panel-header">
        <h3>Elements</h3>
        <button class="panel-toggle" id="elementsToggle" title="Collapse/Expand Elements Panel" aria-label="Toggle Elements Panel" data-dir="right">
          <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M15 6l-6 6 6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
          </svg>
        </button>
      </div>
      <div class="panel-content">
        <button class="btn add-el" data-add="text" draggable="true">Text</button>
        <button class="btn add-el" data-add="field" draggable="true">Field</button>
        <button class="btn add-el" data-add="rect" draggable="true">Rectangle</button>
        <button class="btn add-el" data-add="line" draggable="true">Line</button>
        <button class="btn add-el" data-add="image" draggable="true">Image</button>
        <button class="btn add-el" data-add="table" draggable="true">Table</button>
        <button class="btn add-el" data-add="block" draggable="true">Block</button>
        

        <!-- Layers and Brand sections removed per request -->
      </div>
      <div class="panel-resize-handle panel-resize-right" data-panel="elementsPanel"></div>
    </aside>

    <main class="workspace">
      <div id="pageViewport" style="padding-left: 0px; padding-right: 0px;">
        <div id="pagesList" aria-label="Pages list"></div>
      </div>
    </main>

    <aside class="side right" id="propertiesPanel" style="width: 354px;">
      <div class="panel-resize-handle panel-resize-left" data-panel="propertiesPanel"></div>
      <div class="panel-header">
        <h3>Properties</h3>
        <button class="panel-toggle" id="propertiesToggle" title="Collapse/Expand Properties Panel" aria-label="Toggle Properties Panel" data-dir="left">
          <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M15 6l-6 6 6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
          </svg>
        </button>
      </div>
      <div class="panel-content">
        <div id="propertiesContent" class="props"></div>
        <div class="props" style="margin-top:12px;border-top:1px dashed var(--border);padding-top:8px">
          <div class="row"><label>Header height</label><input id="docHeaderHeight" type="number" min="0" value="10"></div>
          <div class="row"><label>Footer height</label><input id="docFooterHeight" type="number" min="0" value="10"></div>
        </div>
      </div>
    </aside>
  </div>
  <!-- Bottom-right floating zoom control -->
  <div class="zoom-control" id="zoomControl">
    <input id="zoomSlider" type="range" min="25" max="300" step="1" value="100">
    <span id="zoomLabel">100%</span>
  </div>
  <!-- aria-live region to announce selection and range changes for screen readers -->
  <div id="srAnnouncer" aria-live="polite" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden"></div>

  <div id="formatToolbar" class="floating hidden" role="toolbar" aria-label="Editing toolbar">
    <div class="row">
      <label>Fill <input class="circle" type="color" data-prop="styles.fill"></label>
      <label>Text <input class="circle" type="color" data-prop="styles.textColor"></label>
      <label>Stroke <input class="circle" type="color" data-prop="styles.strokeColor"></label>
      <label>Stroke W <input type="range" min="0" max="20" step="1" style="width:120px" data-prop="styles.strokeWidth"></label>
      <label>Radius <input type="range" min="0" max="60" step="1" style="width:120px" data-prop="styles.radius"></label>
      <label>Font <select data-prop="styles.fontFamily">
        <option value="system-ui">System</option>
        <option value="Arial">Arial</option>
        <option value="Helvetica Neue">Helvetica</option>
        <option value="Times New Roman">Times</option>
        <option value="Georgia">Georgia</option>
        <option value="Courier New">Courier</option>
      </select></label>
      <label>Size <select style="width:64px" data-prop="styles.fontSize">
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="14" selected="">14</option>
        <option value="16">16</option>
        <option value="18">18</option>
        <option value="20">20</option>
        <option value="24">24</option>
        <option value="28">28</option>
        <option value="32">32</option>
        <option value="36">36</option>
        <option value="48">48</option>
        <option value="72">72</option>
      </select></label>
      <button class="btn mini" data-toggle="styles.bold" title="Bold" aria-label="Bold" aria-pressed="false">
        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
          <text x="6" y="17" font-family="system-ui, -apple-system, 'Segoe UI', Roboto, Arial" font-size="16" font-weight="700" fill="currentColor">B</text>
        </svg>
      </button>
      <button class="btn mini" data-toggle="styles.italic" title="Italic" aria-label="Italic" aria-pressed="false">
        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
          <text x="8" y="17" font-family="system-ui, -apple-system, 'Segoe UI', Roboto, Arial" font-size="16" font-style="italic" fill="currentColor">I</text>
        </svg>
      </button>
      <button class="btn mini" data-toggle="styles.underline" title="Underline" aria-label="Underline" aria-pressed="false">
        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
          <text x="5" y="16" font-family="system-ui, -apple-system, 'Segoe UI', Roboto, Arial" font-size="16" font-weight="600" fill="currentColor">U</text>
          <line x1="5" y1="18" x2="19" y2="18" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
        </svg>
      </button>
      <button class="btn mini align h-left" id="alignHBtn" data-align-h-cycle="" title="Horizontal align" aria-label="Horizontal align" aria-pressed="false">
        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
          <g class="h-icon h-left">
            <line x1="5" y1="7" x2="17" y2="7" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="5" y1="17" x2="14" y2="17" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
          </g>
          <g class="h-icon h-center">
            <line x1="6" y1="7" x2="18" y2="7" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="7" y1="17" x2="17" y2="17" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
          </g>
          <g class="h-icon h-right">
            <line x1="7" y1="7" x2="19" y2="7" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="10" y1="17" x2="19" y2="17" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
          </g>
        </svg>
      </button>
      <button class="btn mini align v-top" id="alignVBtn" data-align-v-cycle="" title="Vertical align" aria-label="Vertical align" aria-pressed="false">
        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
          <g class="v-icon v-top">
            <line x1="7" y1="5" x2="7" y2="17" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="17" y1="5" x2="17" y2="14" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="5" y1="5" x2="19" y2="5" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
          </g>
          <g class="v-icon v-middle">
            <line x1="7" y1="7" x2="7" y2="19" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="17" y1="8" x2="17" y2="17" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
          </g>
          <g class="v-icon v-bottom">
            <line x1="7" y1="7" x2="7" y2="19" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="17" y1="10" x2="17" y2="19" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
            <line x1="5" y1="19" x2="19" y2="19" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
          </g>
        </svg>
      </button>
      <label class="btn" style="gap:6px; align-items:center"><input type="checkbox" id="bgTransparentToggle"> Transparent BG</label>
    </div>
  </div>

  <div id="lasso" style="left: 491px; top: 326px; width: 2px; height: 8px;" hidden=""></div>
  <style>
    /* Suppress lasso only while header/footer resizing is active */
    .hf-resizing #lasso { display:none !important; }
  </style>
  <div id="selectionBox" class="selbox hidden" style="left: 263.75px; top: 253.569px; width: 97.3738px; height: 59.5526px; z-index: 800;">
    <div class="sb-h" data-handle="nw"></div>
    <div class="sb-h" data-handle="n"></div>
    <div class="sb-h" data-handle="ne"></div>
    <div class="sb-h" data-handle="e"></div>
    <div class="sb-h" data-handle="se"></div>
    <div class="sb-h" data-handle="s"></div>
    <div class="sb-h" data-handle="sw"></div>
    <div class="sb-h" data-handle="w"></div>
    <div class="sb-h" data-handle="move" title="Drag to move"></div>
    <div class="sb-h" data-handle="rotate" title="Drag to rotate"></div>
  </div>

  <div id="elementActions" class="actions hidden" role="toolbar" aria-label="Element actions" data-shown-at="1758970687688" style="left: 312.435px; top: 245.566px;">
    <button class="btn mini" data-action="copy" title="Copy" aria-label="Copy">
      <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
        <rect x="9" y="3" width="12" height="12" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"></rect>
        <rect x="3" y="9" width="12" height="12" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"></rect>
      </svg>
    </button>
    <button class="btn mini" data-action="delete" title="Delete" aria-label="Delete">
      <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M3 6h18" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
        <path d="M8 6V4h8v2" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
        <rect x="6" y="6" width="12" height="14" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"></rect>
        <path d="M10 11v6M14 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
      </svg>
    </button>
    <button class="btn mini" data-group-toggle="" title="Group/Ungroup" disabled="">Group</button>
    <div class="menu" style="position:relative">
      <button class="btn mini" data-menu="actions" title="More" aria-label="More actions">
        <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
          <circle cx="5" cy="12" r="2" fill="currentColor"></circle>
          <circle cx="12" cy="12" r="2" fill="currentColor"></circle>
          <circle cx="19" cy="12" r="2" fill="currentColor"></circle>
        </svg>
      </button>
  <div class="dropdown hidden" data-menu-panel="actions" style="position:absolute;top:36px;right:0;background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);padding:8px;display:flex;flex-direction:column;gap:6px;min-width:160px">
        <div class="icon-row" style="display:flex;gap:6px;justify-content:space-between">
          <button class="btn mini" data-action="delete" title="Delete" aria-label="Delete">
            <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M3 6h18" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
              <path d="M8 6V4h8v2" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
              <rect x="6" y="6" width="12" height="14" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"></rect>
              <path d="M10 11v6M14 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
            </svg>
          </button>
          <button class="btn mini" data-action="duplicate" title="Duplicate" aria-label="Duplicate">
            <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
              <rect x="9" y="3" width="12" height="12" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"></rect>
              <rect x="3" y="9" width="12" height="12" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"></rect>
            </svg>
          </button>
        </div>
        <div class="group">
          <div class="group-label">Align horizontally</div>
          <div class="icon-row">
            <button class="btn mini" data-align="left" title="Align left" aria-label="Align left">
              <svg class="icon" width="16" height="16" viewBox="0 0 24 24"><path d="M4 4v16M6 7h12v4H6zM6 15h8v4H6z" fill="currentColor"></path></svg>
            </button>
            <button class="btn mini" data-align="center" title="Align center" aria-label="Align center">
              <svg class="icon" width="16" height="16" viewBox="0 0 24 24"><path d="M12 4v16M4 9h16v4H4z" fill="currentColor"></path></svg>
            </button>
            <button class="btn mini" data-align="right" title="Align right" aria-label="Align right">
              <svg class="icon" width="16" height="16" viewBox="0 0 24 24"><path d="M20 4v16M6 7h12v4H6zM10 15h8v4h-8z" fill="currentColor"></path></svg>
            </button>
          </div>
        </div>
        <div class="group">
          <div class="group-label">Align vertically</div>
          <div class="icon-row">
            <button class="btn mini" data-align="top" title="Align top" aria-label="Align top">
              <svg class="icon" width="16" height="16" viewBox="0 0 24 24"><path d="M4 4h16M7 6v12h4V6zM15 6v8h4V6z" fill="currentColor"></path></svg>
            </button>
            <button class="btn mini" data-align="middle" title="Align middle" aria-label="Align middle">
              <svg class="icon" width="16" height="16" viewBox="0 0 24 24"><path d="M4 12h16M7 6v12h4V6zM15 8v8h4V8z" fill="currentColor"></path></svg>
            </button>
            <button class="btn mini" data-align="bottom" title="Align bottom" aria-label="Align bottom">
              <svg class="icon" width="16" height="16" viewBox="0 0 24 24"><path d="M4 20h16M7 6v12h4V6zM15 10v8h4v-8z" fill="currentColor"></path></svg>
            </button>
          </div>
        </div>
        <div class="group">
          <div class="group-label">Space evenly</div>
          <div class="icon-row">
            <button class="btn mini" data-distribute="h" title="Distribute horizontally" aria-label="Distribute horizontally">
              <svg class="icon" width="16" height="16" viewBox="0 0 24 24"><path d="M4 4v16M20 4v16M9 6h6v12H9z" fill="currentColor"></path></svg>
            </button>
            <button class="btn mini" data-distribute="v" title="Distribute vertically" aria-label="Distribute vertically">
              <svg class="icon" width="16" height="16" viewBox="0 0 24 24"><path d="M4 4h16M4 20h16M6 9v6h12V9z" fill="currentColor"></path></svg>
            </button>
          </div>
        </div>
        <div class="group">
          <div class="group-label">Layers</div>
          <div class="icon-row">
            <button class="btn mini" data-z="front" title="Bring to front" aria-label="Bring to front">
              <svg class="icon" width="16" height="16" viewBox="0 0 24 24"><path d="M3 3h8v8H3zM13 13h8v8h-8zM8 16h8v-8H8z" fill="currentColor"></path></svg>
            </button>
            <button class="btn mini" data-z="up" title="Bring forward" aria-label="Bring forward">
              <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M5 5h8v8H5z" fill="none" stroke="currentColor" stroke-width="2"></path>
                <path d="M11 11h8v8h-8z" fill="none" stroke="currentColor" stroke-width="2"></path>
              </svg>
            </button>
            <button class="btn mini" data-z="down" title="Send backward" aria-label="Send backward">
              <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M11 11h8v8h-8z" fill="none" stroke="currentColor" stroke-width="2"></path>
                <path d="M5 5h8v8H5z" fill="none" stroke="currentColor" stroke-width="2"></path>
              </svg>
            </button>
            <button class="btn mini" data-z="back" title="Send to back" aria-label="Send to back">
              <svg class="icon" width="16" height="16" viewBox="0 0 24 24"><path d="M3 3h8v8H3zM13 13h8v8h-8zM10 10h8V2h-8z" fill="currentColor"></path></svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Minimal floating table action bar (appears when a table is selected) -->
  <div id="tableActions" class="hidden" role="toolbar" aria-label="Table actions">
    <button class="btn mini" data-tact="row-add">+ Row</button>
    <button class="btn mini" data-tact="col-add">+ Col</button>
    <button class="btn mini" data-tact="row-del">Del Row</button>
    <button class="btn mini" data-tact="col-del">Del Col</button>
    <button class="btn mini" data-tact="merge">Merge</button>
    <button class="btn mini" data-tact="unmerge">Unmerge</button>
    <div class="menu" style="position:relative">
      <button class="btn mini" data-menu="borders">Borders</button>
      <div class="dropdown hidden" data-menu-panel="borders" style="position:absolute;top:36px;left:0;background:#fff;border:1px solid var(--border);border-radius:8px;box-shadow:var(--shadow);padding:8px;display:flex;flex-direction:column;gap:8px;min-width:220px">
        <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px">
          <button class="btn mini" data-borders="all" title="All">All</button>
          <button class="btn mini" data-borders="outer" title="Outer">Outer</button>
          <button class="btn mini" data-borders="inner" title="Inner">Inner</button>
          <button class="btn mini" data-borders="none" title="None">None</button>
          <button class="btn mini" data-borders="top" title="Top">Top</button>
          <button class="btn mini" data-borders="right" title="Right">Right</button>
          <button class="btn mini" data-borders="bottom" title="Bottom">Bottom</button>
          <button class="btn mini" data-borders="left" title="Left">Left</button>
        </div>
        <div style="display:flex;align-items:center;gap:8px">
          <label>Color <input type="color" id="tblBorderColor" value="#000000"></label>
          <label>Width <input type="range" id="tblBorderWidth" min="0" max="12" step="1" value="1" style="width:120px"></label>
        </div>
      </div>
    </div>
  </div>

  <!-- Table context menu -->
  <div id="tableMenu" class="hidden" style="position:fixed; z-index:1101; background:#fff; border:1px solid var(--border); border-radius:8px; box-shadow:var(--shadow); padding:6px; display:flex; flex-direction:column; gap:4px; min-width:180px">
    <button class="btn mini" data-tm="merge">Merge cells</button>
    <button class="btn mini" data-tm="unmerge">Unmerge</button>
    <hr>
    <button class="btn mini" data-tm="row-insert-above">Insert row above</button>
    <button class="btn mini" data-tm="row-insert-below">Insert row below</button>
    <button class="btn mini" data-tm="row-delete">Delete row</button>
    <hr>
    <button class="btn mini" data-tm="col-insert-left">Insert column left</button>
    <button class="btn mini" data-tm="col-insert-right">Insert column right</button>
    <button class="btn mini" data-tm="col-delete">Delete column</button>
  </div>

  <!-- Element context menu -->
  <div id="elementMenu" class="hidden" style="position:fixed; z-index:1101; background:#fff; border:1px solid var(--border); border-radius:8px; box-shadow:var(--shadow); padding:6px; display:flex; flex-direction:column; gap:4px; min-width:200px">
    <button class="btn mini" data-em="duplicate">Duplicate (Ctrl+D)</button>
    <button class="btn mini" data-em="delete">Delete (Del)</button>
    <hr>
    <button class="btn mini" data-em="group">Group</button>
    <button class="btn mini" data-em="ungroup">Ungroup</button>
    <hr>
    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:4px">
      <button class="btn mini" data-em="align-left">Align Left</button>
      <button class="btn mini" data-em="align-center">Align Center</button>
      <button class="btn mini" data-em="align-right">Align Right</button>
      <button class="btn mini" data-em="align-top">Align Top</button>
      <button class="btn mini" data-em="align-middle">Align Middle</button>
      <button class="btn mini" data-em="align-bottom">Align Bottom</button>
    </div>
    <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:4px;margin-top:4px">
      <button class="btn mini" data-em="distribute-h">Distribute H</button>
      <button class="btn mini" data-em="distribute-v">Distribute V</button>
    </div>
    <hr>
    <button class="btn mini" data-em="z-front">Bring to front</button>
    <button class="btn mini" data-em="z-back">Send to back</button>
  </div>

  <!-- Command Palette -->
  <div id="commandPalette" class="hidden" role="dialog" aria-modal="true" aria-label="Command palette" style="position:fixed;inset:0;display:grid;place-items:center;z-index:1200;background:rgba(0,0,0,.2)">
    <div class="cpanel" style="background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);width:min(640px,90vw);">
      <input id="commandInput" type="text" placeholder="Type a command… (Esc to close)" style="width:100%;box-sizing:border-box;padding:10px 12px;border:0;border-bottom:1px solid var(--border);border-radius:12px 12px 0 0;font-size:14px;outline:none">
      <div id="commandList" style="max-height:300px;overflow:auto;padding:6px;display:flex;flex-direction:column;gap:4px"></div>
    </div>
  </div>

  

  <!-- Rulers (top/left) and Minimap -->
  <div id="rulers" class="hidden" aria-hidden="true" style="display:none">
    <div id="rulerH" class="ruler h" style="background-image: linear-gradient(to right, transparent 0px, transparent 9px, rgb(221, 221, 221) 9px, rgb(221, 221, 221) 10px); background-size: 10px 100%;"></div>
    <div id="rulerV" class="ruler v" style="background-image: linear-gradient(transparent 0px, transparent 9px, rgb(221, 221, 221) 9px, rgb(221, 221, 221) 10px); background-size: 100% 10px;"></div>
  </div>
  <canvas id="minimap" class="hidden" width="180" height="120" style="display:none;position:fixed;right:16px;bottom:16px;border:1px solid var(--border);border-radius:6px;background:#fff;box-shadow:var(--shadow);z-index:1050"></canvas>

  
  </div> <!-- /#editorView -->
  
  <!-- Settings dialog (global; available in hub and editor) -->
  <div id="settingsDialog" class="hidden" role="dialog" aria-modal="true" aria-label="Settings" style="position:fixed;inset:0;display:grid;place-items:center;z-index:1200;background:rgba(0,0,0,.2)">
    <div class="cpanel" style="background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);width:min(420px,90vw);padding:12px 12px 10px 12px">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:8px">
        <h3 style="margin:0;font-size:16px">Settings</h3>
        <button class="btn mini" id="settingsCloseBtn" aria-label="Close settings">Close</button>
      </div>
      <div style="display:flex;align-items:center;justify-content:space-between;gap:12px">
        <div>
          <div style="font-weight:600">Autosave</div>
          <div style="font-size:12px;color:#555">When on, hub docs are saved to this file automatically.</div>
        </div>
        <label class="switch"><input id="autosaveToggle" type="checkbox" checked=""><span>Off</span></label>
      </div>
    </div>
  </div>

  <!-- Internal confirmation dialog (reusable) -->
  <div id="confirmDialog" class="hidden" role="dialog" aria-modal="true" aria-labelledby="confirmTitle" style="position:fixed;inset:0;display:grid;place-items:center;z-index:1250;background:rgba(0,0,0,.25)">
    <div class="cpanel" style="background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);width:min(460px,92vw);padding:14px">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:8px">
        <h3 id="confirmTitle" style="margin:0;font-size:16px">Delete folder</h3>
        <button class="btn mini" id="confirmCloseBtn" aria-label="Close">Close</button>
      </div>
      <div id="confirmMessage" style="font-size:14px;color:#374151;margin-bottom:12px">What would you like to delete?</div>
      <div id="confirmButtons" style="display:flex;gap:8px;justify-content:flex-end"><button class="btn danger">Delete folder and documents</button><button class="btn primary">Delete folder only</button><button class="btn light">Cancel</button></div>
    </div>
  </div>


<div class="custom-color-picker hidden" style="left: 27.5781px; top: 77px;">
    <div class="color-picker-section">
      <h4>Recent Colors</h4>
      <div class="color-history-grid" id="colorHistoryGrid" data-role="colorHistoryGrid"><div class="color-history-circle" title="#c8c574" data-color="#c8c574" style="background-color: rgb(200, 197, 116);"></div><div class="color-history-circle" title="#7ec874" data-color="#7ec874" style="background-color: rgb(126, 200, 116);"></div><div class="color-history-circle" title="#787878" data-color="#787878" style="background-color: rgb(120, 120, 120);"></div><div class="color-history-circle" title="#e60505" data-color="#e60505" style="background-color: rgb(230, 5, 5);"></div><div class="color-history-circle" title="#fafafa" data-color="#fafafa" style="background-color: rgb(250, 250, 250);"></div><div class="color-history-circle" title="#f3f1f1" data-color="#f3f1f1" style="background-color: rgb(243, 241, 241);"></div><div class="color-history-circle" title="#e6e6e6" data-color="#e6e6e6" style="background-color: rgb(230, 230, 230);"></div><div class="color-history-circle" title="#e8a6a6" data-color="#e8a6a6" style="background-color: rgb(232, 166, 166);"></div></div>
    </div>
    <div class="color-picker-section">
      <h4>Custom Color</h4>
      <div class="color-picker-input-wrapper">
        <input type="color" id="customColorInput" data-role="customColorInput" value="#000000">
        <input type="text" class="color-picker-hex" id="colorHexInput" data-role="colorHexInput" placeholder="#000000">
      </div>
    </div>
  </div>
  <script>
// editor.core.js
// Extracted from script.js on 2025-08-20T18:47:33.901424Z
// Range: [0:5800] bytes

// Minimal editor logic refactor: model-driven, side panels, floating toolbar, edit mode, pages

/**
 * @typedef {Object} Cell
 * @property {string} id
 * @property {number} row
 * @property {number} col
 * @property {number} rowSpan
 * @property {number} colSpan
 * @property {boolean} hidden
 * @property {string} [content]
 * @property {Object} [styles]
 * @property {Object} [attrs]
 */
/**
 * @typedef {Object} TableElement
 * @property {string} id
 * @property {"table"} type
 * @property {number} x
 * @property {number} y
 * @property {number} w
 * @property {number} h
 * @property {number} rows
 * @property {number} cols
 * @property {number[]} rowHeights
 * @property {number[]} colWidths
 * @property {{ inner:number, outer:number, color:string, style:string }} border
 * @property {Object.<string, Cell>} cells
 * @property {string[][]} grid
 * @property {Object} [styles]
 * @property {Object} [attrs]
 */
/**
 * @typedef {Object} BaseElement
 * @property {string} id
 * @property {"text"|"field"|"rect"|"line"|"image"|"block"|"table"} type
 * @property {number} x
 * @property {number} y
 * @property {number} [w]
 * @property {number} [h]
 * @property {number} [z]
 * @property {Object} styles
 * @property {string} [content]
 * @property {string} [src]
 * @property {number} [x2]
 * @property {number} [y2]
 * @property {string} [parentId]
 * @property {string} [groupId]
 * @property {Object} [attrs]
 */
/**
 * @typedef {BaseElement|TableElement} Element
 */
/**
 * @typedef {Object} Page
 * @property {string} id
 * @property {string} name
 * @property {Element[]} elements
 */
/**
 * @typedef {Object} DocumentModel
 * @property {Page[]} pages
 * @property {string} currentPageId
 * @property {number} nextElementId
 * @property {boolean} editMode
 */

/* ----------------------- Model ----------------------- */
const Model = {
  document: {
    pages: [],
    currentPageId: '',
    nextElementId: 1,
    editMode: false,
    // Global header/footer reserved heights in logical pixels
    headerHeight: 10,
    footerHeight: 10,
  },
};

// Centralized history (keep out of the document snapshot so multiple undos work)
const HISTORY_LIMIT = 10;
const History = { past: [], future: [] };
const APP_VERSION = 'v1.0.0';
// Schema for serialized document payloads
const SCHEMA_VERSION = 1;

function isElementIdInUse(id){
  try {
    return (Model.document?.pages || []).some(p => (p.elements || []).some(el => el.id === id));
  } catch { return false; }
}
function generateId(prefix = 'el') {
  // Ensure uniqueness even if nextElementId is out of sync with existing data
  let id = `${prefix}-${Model.document.nextElementId++}`;
  while (isElementIdInUse(id)) {
    id = `${prefix}-${Model.document.nextElementId++}`;
  }
  return id;
}

/* ----------------------- DOM refs ----------------------- */
const pagesList = () => document.getElementById('pagesList');
const elementsPanel = () => document.getElementById('elementsPanel');
const propertiesContent = () => document.getElementById('propertiesContent');
const formatToolbar = () => document.getElementById('formatToolbar');
const elementActions = () => document.getElementById('elementActions');
// Zoom
const zoomSlider = () => document.getElementById('zoomSlider');
const zoomLabel  = () => document.getElementById('zoomLabel');
let __zoom = 1; // scale (1 = 100%)
function getZoom(){ return __zoom; }
function setZoomScale(scale){
  const clamped = Math.min(3, Math.max(0.25, Number(scale) || 1));
  __zoom = clamped;
  document.documentElement.style.setProperty('--zoom', String(clamped));
  if (zoomSlider()) zoomSlider().value = String(Math.round(clamped * 100));
  if (zoomLabel())  zoomLabel().textContent = `${Math.round(clamped * 100)}%`;
  alignOverlays();
}
function setZoomPercent(pct){ setZoomScale((Number(pct)||100) / 100); }

// Zoom helpers that keep a focal point stable on screen
function zoomAtClientPoint(clientX, clientY, nextScale){
  const vp = document.getElementById('pageViewport');
  const page = getPageNode(); if (!vp || !page) return setZoomScale(nextScale);
  const before = page.getBoundingClientRect();
  const z0 = getZoom();
  const px = (clientX - before.left) / z0; // logical point on page
  const py = (clientY - before.top)  / z0;
  setZoomScale(nextScale);
  const after = page.getBoundingClientRect();
  const z1 = getZoom();
  const nx = px * z1; const ny = py * z1; // new on-screen offset from page top-left
  const dx = nx - (clientX - after.left);
  const dy = ny - (clientY - after.top);
  vp.scrollLeft += dx;
  vp.scrollTop  += dy;
}
function zoomAtViewportCenter(nextScale){
  const vp = document.getElementById('pageViewport'); if (!vp) return setZoomScale(nextScale);
  const r = vp.getBoundingClientRect();
  const cx = r.left + r.width/2; const cy = r.top + r.height/2;
  zoomAtClientPoint(cx, cy, nextScale);
}

const undoBtn = () => document.getElementById('undoBtn');
const redoBtn = () => document.getElementById('redoBtn');
const editToggleBtn = () => document.getElementById('editToggleBtn');
const saveBtn = () => document.getElementById('saveBtn');
const saveAsBtn = () => document.getElementById('saveAsBtn');
const savePdfBtn = () => document.getElementById('savePdfBtn');

/* ----------------------- Utilities ----------------------- */
function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }
function deepMerge(target, patch){
	const out = deepClone(target);
	Object.keys(patch || {}).forEach(k => {
		if (patch[k] && typeof patch[k] === 'object' && !Array.isArray(patch[k])) {
			out[k] = deepMerge(out[k] || {}, patch[k]);
		} else {
			out[k] = patch[k];
		}
	});
	return out;
}
function nowSnapshot() { return deepClone(Model.document); }
function commitHistory(label) {
  History.past.push(nowSnapshot());
  if (History.past.length > HISTORY_LIMIT) History.past.shift();
  History.future = [];
  updateUndoRedoButtons();
  // Trigger inline autosave (debounced in editor.app.js)
  try { if (typeof autosaveInline === 'function') autosaveInline(); } catch {}
}
function undo() {
  if (!History.past.length) return;
  History.future.push(nowSnapshot());
  Model.document = History.past.pop();
  renderAll();
  updateUndoRedoButtons();
}
function redo() {
  if (!History.future.length) return;
  History.past.push(nowSnapshot());
  Model.document = History.future.pop();
  renderAll();
  updateUndoRedoButtons();
}
function updateUndoRedoButtons() {
  undoBtn().disabled = History.past.length === 0;
  redoBtn().disabled = History.future.length === 0;
}

function setEditMode(on) {
  Model.document.editMode = on;
  document.body.classList.toggle('edit-off', !on);
  try { const btn = (typeof editToggleBtn === 'function') ? editToggleBtn() : null; if (btn) btn.setAttribute('aria-pressed', on ? 'true' : 'false'); } catch {}
  // hide selection and toolbar if turning off
  if (!on) {
    try { clearSelection(); } catch {}
    try { const bar = document.getElementById('tableActions'); if (bar) bar.classList.add('hidden'); } catch {}
    try { const lasso = document.getElementById('lasso'); if (lasso) lasso.hidden = true; } catch {}
  }
  // Instead of re-rendering from scratch (which can reset some visibility),
  // update only inline event attributes to reflect mode.
  try {
    if (typeof window.applyEventAttributesForMode === 'function') window.applyEventAttributesForMode(getCurrentPage());
  } catch {}
  // Re-apply element styles to honor edit-mode visibility policy without rebuilding all pages
  try {
    const page = getCurrentPage();
    if (page) page.elements.forEach(el => {
      const node = document.querySelector(`.page-wrapper[data-page-id="${page.id}"] .page .element[data-id="${el.id}"]`);
      if (node) applyElementStyles(node, el);
    });
  } catch {}
  // Sync the toggle button UI (icon, text, pressed state)
  try {
    const btn = (typeof editToggleBtn === 'function') ? editToggleBtn() : null;
    if (btn){
      btn.setAttribute('aria-pressed', on ? 'true' : 'false');
      if (on){
        btn.innerHTML = '<svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z" fill="currentColor"></path><path d="M20.71 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" fill="currentColor"></path></svg><span>Edit mode</span>';
        btn.title = 'Edit mode';
        btn.setAttribute('aria-label', 'Edit mode');
      } else {
        btn.innerHTML = '<svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7S1 12 1 12z" fill="none" stroke="currentColor" stroke-width="2"></path><circle cx="12" cy="12" r="3" fill="currentColor"></circle></svg><span>View mode</span>';
        btn.title = 'View mode';
        btn.setAttribute('aria-label', 'View mode');
      }
    }
  } catch {}
  // Update padding after mode change
  if (typeof window.updateWorkspacePadding === 'function') window.updateWorkspacePadding();
}

/* ----------------------- Page & Elements ----------------------- */
function createPage(name = `Page ${Model.document.pages.length + 1}`) {
  const id = `page-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
  return { id, name, elements: [] };
}

function getCurrentPage() {
  return Model.document.pages.find(p => p.id === Model.document.currentPageId);
}

/** Return element model by id from the current page. */
function getElementById(id){
	const page = getCurrentPage();
	return page && page.elements ? page.elements.find(e => e.id === id) : null;
}

function addPage() {
  commitHistory('add-page');
  const p = createPage();
  Model.document.pages.push(p);
  Model.document.currentPageId = p.id;
  renderAll();
}

function removeCurrentPage() {
  if (Model.document.pages.length <= 1) return;
  commitHistory('remove-page');
  const idx = Model.document.pages.findIndex(p => p.id === Model.document.currentPageId);
  Model.document.pages.splice(idx, 1);
  const newIdx = Math.max(0, idx - 1);
  Model.document.currentPageId = Model.document.pages[newIdx].id;
  renderAll();
}

function duplicateCurrentPage() {
  const page = getCurrentPage();
  commitHistory('duplicate-page');
  const clone = deepClone(page);
  // Create a fresh page shell to get a new id and name
  const fresh = createPage(page.name + ' copy');
  clone.id = fresh.id;
  clone.name = fresh.name;
  // Remap element ids and fix parentId references so all elements (including hidden ones) are preserved
  const idMap = new Map();
  clone.elements = (clone.elements || []).map(e => {
    const newId = generateId();
    idMap.set(e.id, newId);
    return { ...e, id: newId };
  });
  clone.elements = clone.elements.map(e => {
    const pid = e.parentId;
    if (pid && idMap.has(pid)) return { ...e, parentId: idMap.get(pid) };
    return e;
  });
  const idx = Model.document.pages.findIndex(p => p.id === page.id);
  Model.document.pages.splice(idx + 1, 0, clone);
  Model.document.currentPageId = clone.id;
  renderAll();
}

function moveCurrentPage(delta) {
  const idx = Model.document.pages.findIndex(p => p.id === Model.document.currentPageId);
  const target = idx + delta;
  if (target < 0 || target >= Model.document.pages.length) return;
  commitHistory('move-page');
  const [pg] = Model.document.pages.splice(idx, 1);
  Model.document.pages.splice(target, 0, pg);
  renderAll();
}

/* ----------------------- Formula Engine ----------------------- */
/**
 * Evaluate a simple Excel-like formula string.
 * Supported:
 *  - Arithmetic: +, -, *, /, %, parentheses
 *  - Functions: SUM(...), AVG(...), MIN(...), MAX(...), ROUND(x[,d]), FLOOR(x), CEIL(x), ABS(x)
 *  - References to other elements/cells using #id tokens (e.g., #el-1 or #cell-abc)
 * Returns { value:string, error?:string } where value is a string suitable for content.
 */
function evaluateFormulaExpression(expr){
  try {
    if (!expr || typeof expr !== 'string') return { value: '' };
    const raw = String(expr).trim();
    if (!raw.startsWith('=')) return { value: raw };
    const body = raw.slice(1);

    // Support both raw #id tokens and quoted "#id" tokens from picker
    let toEval = body
      .replace(/"#([A-Za-z0-9_\-:]+)"/g, (m, id) => `r('${id}')`)
      .replace(/#([A-Za-z0-9_\-:]+)/g, (m, id) => `r('${id}')`);

    // Helper to resolve a numeric value from an element or table cell by id
    function r(id){
      try {
        for (const p of (Model.document?.pages || [])){
          const el = (p.elements || []).find(e => e && e.id === id);
          if (el){
            const txt = String(el.content ?? '').trim();
            const num = Number(txt);
            return Number.isFinite(num) ? num : 0;
          }
          const table = (p.elements || []).find(e => e && e.type === 'table' && e.cells && e.cells[id]);
          if (table){
            const cell = table.cells[id];
            const txt = String(cell?.content ?? '').trim();
            const num = Number(txt);
            return Number.isFinite(num) ? num : 0;
          }
        }
      } catch {}
      return 0;
    }

    // Whitelist functions
    const SUM = (...args) => args.reduce((a,b)=>a + (Number(b)||0), 0);
    const AVG = (...args) => { const arr = args.map(v=>Number(v)||0); return arr.length ? (arr.reduce((a,b)=>a+b,0)/arr.length) : 0; };
    const MIN = (...args) => Math.min(...args.map(v=>Number(v)||0));
    const MAX = (...args) => Math.max(...args.map(v=>Number(v)||0));
    const ROUND = (x, d=0) => { const n = Number(x)||0; const k = Math.pow(10, Number(d)||0); return Math.round(n*k)/k; };
    const FLOOR = (x) => Math.floor(Number(x)||0);
    const CEIL  = (x) => Math.ceil(Number(x)||0);
    const ABS   = (x) => Math.abs(Number(x)||0);

    // Very light sanitization: allow digits, ops, commas, parentheses, dots, letters, and r('id') calls.
    // Strip r('...') arguments before checking for disallowed characters so quotes inside r() are permitted.
    const sanitized = toEval.replace(/r\('\s*[A-Za-z0-9_\-:]+\s*'\)/g, 'r(x)');
    if (/[^0-9A-Za-z_\-:#(),.\s+\-*\/%%]/.test(sanitized)) {
      return { value: '', error: 'Invalid characters in formula' };
    }

    // Evaluate in a restricted scope
    // eslint-disable-next-line no-new-func
    const fn = new Function('r','SUM','AVG','MIN','MAX','ROUND','FLOOR','CEIL','ABS', `return (${toEval});`);
    const num = fn(r, SUM, AVG, MIN, MAX, ROUND, FLOOR, CEIL, ABS);
    const asNum = Number(num);
    if (Number.isFinite(asNum)) return { value: String(asNum) };
    return { value: String(num ?? '') };
  } catch (err){
    try { console.warn('evaluateFormulaExpression failed', err); } catch {}
    return { value: '' , error: String(err && err.message || err) };
  }
}

/**
 * Scan the whole document and update element/cell content from attrs.formula when present.
 * Mutates Model.document in-place (no history). Safe to call frequently.
 */
function recalculateAllFormulas(){
  try {
    const doc = Model.document; if (!doc || !Array.isArray(doc.pages)) return;
    for (let pass=0; pass<2; pass++){
      for (const p of (doc.pages || [])){
        for (const el of (p.elements || [])){
          try {
            if (el && (el.type === 'text' || el.type === 'field' || el.type === 'rect')){
              const f = String(el?.attrs?.formula || '').trim();
              if (f){
                const out = evaluateFormulaExpression(f);
                el.content = out.value;
              }
            }
            if (el && el.type === 'table' && el.cells){
              Object.keys(el.cells).forEach((cid) => {
                try {
                  const cell = el.cells[cid]; if (!cell || !cell.attrs) return;
                  const ff = String(cell.attrs.formula || '').trim();
                  if (ff){
                    const out = evaluateFormulaExpression(ff);
                    cell.content = out.value;
                  }
                } catch {}
              });
            }
          } catch {}
        }
      }
    }
  } catch {}
}

try { window.evaluateFormulaExpression = evaluateFormulaExpression; } catch {}
try { window.recalculateAllFormulas = recalculateAllFormulas; } catch {}


  </script>

  <script>
// core.update.js
// Pure model update helpers. No DOM access, no history.

/** Return a deep-cloned document with patches applied to element ids on the current page. */
function applyPatchToElements(documentModel, elementIds, patch){
	const doc = deepClone(documentModel);
	if (!doc || !Array.isArray(doc.pages)) return doc;
	const page = doc.pages.find(p => p.id === doc.currentPageId);
	if (!page) return doc;
	const ids = new Set((elementIds || []).filter(Boolean));
	if (ids.size === 0) return doc;
	page.elements = page.elements.map(el => {
		if (!ids.has(el.id)) return el;
		return deepMerge(el, patch || {});
	});
	return doc;
}

/** Apply element patch to matching ids across all pages (used for cross-page selectors). */
function applyPatchToElementsAnyPage(documentModel, elementIds, patch){
	const doc = deepClone(documentModel);
	if (!doc || !Array.isArray(doc.pages)) return doc;
	const ids = new Set((elementIds || []).filter(Boolean));
	if (ids.size === 0) return doc;
	doc.pages.forEach(p => {
		if (!Array.isArray(p.elements)) return;
		p.elements = p.elements.map(el => ids.has(el.id) ? deepMerge(el, patch || {}) : el);
	});
	return doc;
}

/**
 * Apply per-cell style patch to a rectangular range in a table element.
 * stylePatch accepts model style keys, mapped to table cell helpers internally.
 */
function applyPatchToTableCells(documentModel, tableId, range, stylePatch){
	const doc = deepClone(documentModel);
	if (!doc || !Array.isArray(doc.pages)) return doc;
	const page = doc.pages.find(p => p.id === doc.currentPageId);
	if (!page) return doc;
	const idx = page.elements.findIndex(e => e.id === tableId);
	if (idx === -1) return doc;
	let next = page.elements[idx];
	const styles = stylePatch || {};
	if (styles.fill != null) next = tableApplyCellBg(next, range, styles.fill);
	if (styles.textColor != null) next = tableApplyTextColor(next, range, styles.textColor);
	const alignH = (styles.textAlignH != null) ? styles.textAlignH : undefined;
	const alignV = (styles.textAlignV != null) ? styles.textAlignV : undefined;
	if (alignH || alignV) next = tableApplyAlign(next, range, alignH, alignV);
	const perCellKeys = ['strokeColor','strokeWidth','fontFamily','fontSize','bold','italic','underline', 'borderColor', 'borderWidth'];
	perCellKeys.forEach(k => { if (styles[k] != null) next = tableApplyCellStyle(next, range, k, styles[k]); });
	page.elements[idx] = next;
	return doc;
}

/** Apply table-cell style patch, locating the table by id in any page. */
function applyPatchToTableCellsAnyPage(documentModel, tableId, range, stylePatch){
	const doc = deepClone(documentModel);
	if (!doc || !Array.isArray(doc.pages)) return doc;
	for (let p of doc.pages){
		const idx = p.elements.findIndex(e => e.id === tableId);
		if (idx === -1) continue;
		let next = p.elements[idx];
		const styles = stylePatch || {};
		if (styles.fill != null) next = tableApplyCellBg(next, range, styles.fill);
		if (styles.textColor != null) next = tableApplyTextColor(next, range, styles.textColor);
		const alignH = (styles.textAlignH != null) ? styles.textAlignH : undefined;
		const alignV = (styles.textAlignV != null) ? styles.textAlignV : undefined;
		if (alignH || alignV) next = tableApplyAlign(next, range, alignH, alignV);
		const perCellKeys = ['strokeColor','strokeWidth','fontFamily','fontSize','bold','italic','underline', 'borderColor', 'borderWidth'];
		perCellKeys.forEach(k => { if (styles[k] != null) next = tableApplyCellStyle(next, range, k, styles[k]); });
		p.elements[idx] = next;
		break;
	}
	return doc;
}

/**
 * Best-effort selector patching without DOM: supports "#id", "id" matching elements,
 * and cell ids inside any table element. Returns a new document.
 */
function applyPatchBySelector(documentModel, selector, patch){
	if (!selector) return documentModel;
	const token = String(selector).replace(/^#/, '');
	let doc = documentModel;
	// Try element id first
	const page = documentModel.pages.find(p => p.id === documentModel.currentPageId);
	if (page && page.elements.some(e => e.id === token)){
		doc = applyPatchToElements(doc, [token], patch);
		return doc;
	}
	// Try table cell id inside any table on the page
	if (page){
		for (const el of page.elements){
			if (el.type !== 'table') continue;
			if (el.cells && el.cells[token]){
				const cell = el.cells[token];
				const range = { r0: cell.row, c0: cell.col, r1: cell.row, c1: cell.col };
				doc = applyPatchToTableCells(doc, el.id, range, patch && patch.styles ? patch.styles : {});
				return doc;
			}
		}
	}
	return doc;
}



  </script>

  <script>
// selection.store.js
// Centralized selection store to avoid cross-file mutation. Minimal API.

const SelectionStore = (function(){
	let elementIds = new Set();
	let listeners = new Set();
	return {
		get(){ return new Set(elementIds); },
		set(ids){ elementIds = new Set((ids||[]).filter(Boolean)); listeners.forEach(fn=>fn()); },
		clear(){ elementIds.clear(); listeners.forEach(fn=>fn()); },
		add(id){ if (!id) return; elementIds.add(id); listeners.forEach(fn=>fn()); },
		toggle(id){ if (!id) return; elementIds.has(id) ? elementIds.delete(id) : elementIds.add(id); listeners.forEach(fn=>fn()); },
		on(fn){ listeners.add(fn); return () => listeners.delete(fn); }
	};
})();



  </script>

  <script>
// style.map.js
// Centralized style mapping and normalization.

const ELEMENT_STYLE_KEYS = [
	'fill','strokeColor','strokeWidth','radius','textColor','fontFamily','fontSize','bold','italic','underline','textAlignH','textAlignV','rotate'
];

const TABLE_PER_CELL_KEYS = [
	'strokeColor','strokeWidth','fontFamily','fontSize','bold','italic','underline','borderColor','borderWidth'
];

function tablePatchFromElementPatch(stylePatch){
	const s = stylePatch || {};
	const out = {
		bg: s.fill != null ? s.fill : undefined,
		textColor: s.textColor != null ? s.textColor : undefined,
		alignH: s.textAlignH != null ? s.textAlignH : undefined,
		alignV: s.textAlignV != null ? s.textAlignV : undefined,
		perCell: {}
	};
	TABLE_PER_CELL_KEYS.forEach(k => {
		if (Object.prototype.hasOwnProperty.call(s, k)) out.perCell[k] = s[k];
	});
	return out;
}



  </script>

  <script>
// editor.selection.js
// Extracted from script.js on 2025-08-20T18:47:33.901424Z
// Range: [5800:10684] bytes

/* ----------------------- Selection (multi-select) ----------------------- */
let selectedIds = new Set();

function clearSelection(){ 
  selectedIds.clear(); 
  console.log('[SELECTION] clear');
  // If a canvas text/field/cell is currently being edited, stop editing as well
  try {
    const active = document.activeElement;
    const isEditable = !!(active && (active.isContentEditable || active.tagName === 'INPUT' || active.tagName === 'TEXTAREA'));
    const isInCanvas = !!(isEditable && active && active.closest && (active.closest('.page') || active.classList.contains('table-cell')));
    if (isInCanvas) { active.blur(); }
  } catch {}
  clearTableSelection(); 
  updateSelectionUI(); 
}
function setSelection(ids){ 
  selectedIds = new Set((ids||[]).filter(Boolean)); 
  console.log('[SELECTION] set', Array.from(selectedIds));
  // Clear table selection unless we're selecting the same table that has active cell selection
  if (tableSel && (selectedIds.size !== 1 || !selectedIds.has(tableSel.tableId))) {
    clearTableSelection();
  }
  updateSelectionUI(); 
}
function addToSelection(id){ 
  if (!id) return; 
  selectedIds.add(id); 
  console.log('[SELECTION] add', id, '→', Array.from(selectedIds));
  // Clear table selection when adding non-table elements or different tables
  if (tableSel && (!selectedIds.has(tableSel.tableId) || selectedIds.size > 1)) {
    clearTableSelection();
  }
  updateSelectionUI(); 
}
function toggleSelection(id){ 
  if (!id) return; 
  selectedIds.has(id) ? selectedIds.delete(id) : selectedIds.add(id); 
  console.log('[SELECTION] toggle', id, '→', Array.from(selectedIds));
  // Clear table selection when toggling creates a multi-selection or removes the table
  if (tableSel && (!selectedIds.has(tableSel.tableId) || selectedIds.size > 1)) {
    clearTableSelection();
  }
  updateSelectionUI(); 
}
function isSelected(id){ return selectedIds.has(id); }

function updateSelectionUI(){
  console.log('[SELECTION] updateUI size=', selectedIds.size);
  document.querySelectorAll('.page .element').forEach(el => {
    const isTableElement = el.classList.contains('table');
    const should = selectedIds.has(el.dataset.id) && !isTableElement;
    el.classList.toggle('selected', should);
  });
  updateFormatToolbarVisibility();
  if (selectedIds.size === 1) {
    const m = getElementById([...selectedIds][0]);
    if (m) syncFormatToolbar(m);
  } else if (!tableSel) {
    // Only clear toolbar when there's no table selection active
    const bar = formatToolbar();
    if (bar){
      bar.querySelectorAll('[data-prop]').forEach(i => {
        // Avoid assigning empty string to color inputs to prevent format warnings
        if (i.type === 'color') return;
        if (i.type !== 'range' && i.type !== 'number') i.value = '';
      });
      bar.querySelectorAll('[data-toggle]').forEach(b => b.setAttribute('aria-pressed','false'));
    }
  }
  updateSelectionBox();
  if (typeof window.applyAlignButtonState === 'function') window.applyAlignButtonState();
  // keep properties panel in sync
  renderProperties();
  // update group toggle state
  if (typeof updateGroupToggleButton === 'function') updateGroupToggleButton();
  // NEW: keep the action bubble in sync with selection
  positionElementActions();
}  

function updateFormatToolbarVisibility(){
  const bar = formatToolbar();
  if ((selectedIds.size === 0 && !tableSel) || !Model.document.editMode) { bar.classList.add('hidden'); return; }
  bar.classList.remove('hidden');
}
function hideFormatToolbar(){ formatToolbar().classList.add('hidden'); }

function positionElementActions(){
  const bubble = elementActions();
  if (selectedIds.size === 0 || !Model.document.editMode) { bubble.classList.add('hidden'); return; }
  const firstId = [...selectedIds][0];
  const el = document.querySelector(`.page .element[data-id="${firstId}"]`);
  if (!el) { bubble.classList.add('hidden'); return; }
  const r = el.getBoundingClientRect();
  bubble.style.left = (r.left + r.width / 2) + 'px';
  bubble.style.top = (r.top - 8) + 'px';
  bubble.classList.remove('hidden');
  // Mark the moment of this reposition so clicks immediately following
  // a selection change don't trigger the actions dropdown unintentionally
  bubble.setAttribute('data-shown-at', String(Date.now()));
}

/* ----------------------- Selection box ----------------------- */
function selectionBoxEl(){ return document.getElementById('selectionBox'); }
function updateSelectionBox(){
  const box = selectionBoxEl(); if (!box) return;
  const b = getSelectionBounds();
  const page = getPageNode();
  // Hide selection box entirely for field(s) when edit mode is off
  if (!Model.document.editMode && selectedIds.size > 0) {
    const allFields = [...selectedIds].every(id => getElementById(id)?.type === 'field');
    if (allFields) { box.classList.add('hidden'); return; }
  }
  if (!b || !page){ box.classList.add('hidden'); return; }
  box.classList.remove('hidden');
  // Calculate viewport position from page rect so it survives page changes/scrolling
  const pr = page.getBoundingClientRect();
  const z = getZoom();
  const style = box.style;
  style.left = pr.left + b.x * z + 'px';
  style.top = pr.top + b.y * z + 'px';
  style.width = b.w * z + 'px';
  style.height = b.h * z + 'px';
  // Ensure selection box z-order sits just above page but below toolbars
  style.zIndex = '800';
  // Update actions bubble to the selection bounds center in viewport coords
  const bubble = elementActions();
  if (bubble && selectedIds.size > 0) {
    const cx = pr.left + (b.x + b.w / 2) * z;
    const cy = pr.top + b.y * z - 8;
    bubble.style.left = cx + 'px';
    bubble.style.top = cy + 'px';
  }
}

// Re-align viewport overlays (selection box + action bubble) once per frame
let __alignReq = null;
function alignOverlays() {
  if (__alignReq) return;
  __alignReq = requestAnimationFrame(() => {
    __alignReq = null;
    updateSelectionBox();
    positionElementActions();
  });
}


  </script>

  <script>
// editor.tables.js
// Extracted from script.js on 2025-08-20T18:47:33.901424Z
// Range: [10684:53602] bytes

/* ===================== Table: model, pure ops, rendering, selection, commands ===================== */
// ----- utils -----
const clone = (obj) => JSON.parse(JSON.stringify(obj));
function generateCellId(tableId, r, c){
  // Deterministic, simple id aligned with element data-id scheme
  return `${tableId}_${r}x${c}`;
}
function normalizeRange(r0,c0,r1,c1){ return { r0: Math.min(r0,r1), c0: Math.min(c0,c1), r1: Math.max(r0,r1), c1: Math.max(c0,c1) }; }
function getElementNode(id){ return document.querySelector(`.page .element[data-id="${id}"]`); }

// ===== Table model types =====
function makeTableElement(rows=3, cols=4) {
  const id = generateId('tbl');
  const colWidths = Array(cols).fill(Math.round(600/cols));
  const rowHeights = Array(rows).fill(40);
  const cells = {}; const grid = []; let counter = 0;
  for (let r=0; r<rows; r++){
    grid[r] = [];
    for (let c=0; c<cols; c++){
      const cid = generateCellId(id, r, c);
      cells[cid] = { id: cid, row:r, col:c, rowSpan:1, colSpan:1, hidden:false, content: "", styles: { alignH:'left', alignV:'top', padding:8, bg:null, borders:{ top:true,right:true,bottom:true,left:true } }, attrs: {} };
      grid[r][c] = cid;
    }
  }
  return { id, type:'table', x:100, y:100, w:Math.max(200, colWidths.reduce((a,b)=>a+b,0)), h: rowHeights.reduce((a,b)=>a+b,0), rows, cols, colWidths, rowHeights, border:{ inner:1, outer:1, color:'#000', style:'solid' }, cells, grid };
}

// ----- pure ops -----
function tableAddRow(t, at) {
  t = clone(t);
  at = Math.min(Math.max(at, 0), t.rows);

  const rowHeights = t.rowHeights.slice();
  // Clone height from the row above (or the first row when inserting at 0)
  const srcRowForHeight = at > 0 ? at - 1 : 0;
  const insertRowHeight = Number.isFinite(rowHeights[srcRowForHeight]) ? rowHeights[srcRowForHeight] : 40;
  rowHeights.splice(at, 0, insertRowHeight);

  const cells = clone(t.cells);
  const newGrid = [];
  const newlyCreated = new Set();
  const expandedAnchors = new Set();
  const cols = t.cols;

  // Build grid with the inserted row
  for (let r = 0; r <= t.rows; r++) {
    if (r === at) {
      const newRow = [];
      for (let c = 0; c < cols; c++) {
        // If inserting inside a vertical span, map to the anchor and grow its rowSpan once
        let expandId = null;
        if (at > 0) {
          const upId = t.grid[at - 1][c];
          const upCell = upId ? t.cells[upId] : null;
          if (upCell && upCell.row < at && at <= (upCell.row + (upCell.rowSpan || 1) - 1)) {
            expandId = upId;
          }
        }
        if (expandId) {
          newRow[c] = expandId;
          if (!expandedAnchors.has(expandId)) {
            cells[expandId].rowSpan = (cells[expandId].rowSpan || 1) + 1;
            expandedAnchors.add(expandId);
          }
        } else {
          const cid = generateId('cell');
          // Determine source row for style cloning: prefer row above, otherwise the first row
          const srcR = at > 0 ? at - 1 : 0;
          const srcId = t.grid[srcR]?.[c];
          const srcCell = srcId ? t.cells[srcId] : null;
          const defaultStyles = { alignH:'left', alignV:'top', padding:8, bg:null, borders:{ top:true, right:true, bottom:true, left:true } };
          const clonedStyles = srcCell && srcCell.styles ? clone(srcCell.styles) : defaultStyles;
          const clonedAttrs = srcCell && srcCell.attrs ? clone(srcCell.attrs) : {};
          cells[cid] = {
            id: cid, row: at, col: c,
            rowSpan: 1, colSpan: 1, hidden: false,
            content: "", styles: clonedStyles, attrs: clonedAttrs
          };
          newRow[c] = cid;
          newlyCreated.add(cid);
        }
      }
      newGrid[r] = newRow;
    } else {
      const srcR = r > at ? r - 1 : r;
      newGrid[r] = t.grid[srcR].slice();
    }
  }

  // Shift row index for all existing cells at/after 'at' except the ones we just made
  Object.values(cells).forEach(cell => {
    if (!newlyCreated.has(cell.id) && cell.row >= at) cell.row += 1;
  });

  const h = rowHeights.reduce((a,b)=>a+b,0);
  return { ...t, rows: t.rows + 1, rowHeights, grid: newGrid, cells, h };
}
function tableAddColumn(t, at) {
  t = clone(t);
  at = Math.min(Math.max(at, 0), t.cols);

  const colWidths = t.colWidths.slice();
  // Clone width from the column to the left (or the first column when inserting at 0)
  const srcColForWidth = at > 0 ? at - 1 : 0;
  const insertColWidth = Number.isFinite(colWidths[srcColForWidth]) ? colWidths[srcColForWidth] : 100;
  colWidths.splice(at, 0, insertColWidth);

  const cells = clone(t.cells);
  const newGrid = [];
  const newlyCreated = new Set();
  const expandedAnchors = new Set();

  for (let r = 0; r < t.rows; r++) {
    const row = [];
    for (let c = 0; c <= t.cols; c++) {
      if (c === at) {
        // If inserting inside a horizontal span, map to the anchor and grow its colSpan once
        let expandId = null;
        if (at > 0) {
          const leftId = t.grid[r][at - 1];
          const leftCell = leftId ? t.cells[leftId] : null;
          if (leftCell && leftCell.col < at && at <= (leftCell.col + (leftCell.colSpan || 1) - 1)) {
            expandId = leftId;
          }
        }
        if (expandId) {
          row[c] = expandId;
          if (!expandedAnchors.has(expandId)) {
            cells[expandId].colSpan = (cells[expandId].colSpan || 1) + 1;
            expandedAnchors.add(expandId);
          }
        } else {
          const cid = generateId('cell');
          // Determine source column for style cloning: prefer column to the left, otherwise the first column
          const srcC = at > 0 ? at - 1 : 0;
          const srcId = t.grid[r]?.[srcC];
          const srcCell = srcId ? t.cells[srcId] : null;
          const defaultStyles = { alignH:'left', alignV:'top', padding:8, bg:null, borders:{ top:true, right:true, bottom:true, left:true } };
          const clonedStyles = srcCell && srcCell.styles ? clone(srcCell.styles) : defaultStyles;
          const clonedAttrs = srcCell && srcCell.attrs ? clone(srcCell.attrs) : {};
          cells[cid] = {
            id: cid, row: r, col: at,
            rowSpan: 1, colSpan: 1, hidden: false,
            content: "", styles: clonedStyles, attrs: clonedAttrs
          };
          row[c] = cid;
          newlyCreated.add(cid);
        }
      } else {
        const srcC = c > at ? c - 1 : c;
        row[c] = t.grid[r][srcC];
      }
    }
    newGrid[r] = row;
  }

  // Shift column index for all existing cells at/after 'at' except the newly created ones
  Object.values(cells).forEach(cell => {
    if (!newlyCreated.has(cell.id) && cell.col >= at) cell.col += 1;
  });

  const w = colWidths.reduce((a,b)=>a+b,0);
  return { ...t, cols: t.cols + 1, colWidths, grid: newGrid, cells, w };
}
function tableDeleteRow(t, at) {
  if (t.rows <= 1) return t; t = clone(t);
  const cells = clone(t.cells);
  const rowHeights = t.rowHeights.slice(); rowHeights.splice(at,1);

  // Adjust spans for merged cells that intersect the deleted row
  const toDelete = new Set();
  Object.values(cells).forEach(cell => {
    if (!cell) return;
    const top = cell.row; const bottom = cell.row + (cell.rowSpan || 1) - 1;
    if (at >= top && at <= bottom) {
      if ((cell.rowSpan || 1) > 1) {
        // Deleting inside this vertical span reduces its height by 1
        cell.rowSpan = (cell.rowSpan || 1) - 1;
        // If the anchor starts at the deleted row, keep anchor at same index after splice
      } else {
        // Single-height cell fully removed by this row delete
        toDelete.add(cell.id);
      }
    }
    // Shift anchors below the deleted row
    if (cell.row > at) cell.row -= 1;
  });

  // Remove the row from the grid
  const grid = t.grid.slice();
  grid.splice(at, 1);

  // Drop cells that have been fully removed
  toDelete.forEach(id => { delete cells[id]; });

  const h = rowHeights.reduce((a,b)=>a+b,0);
  return { ...t, rows: t.rows - 1, grid, rowHeights, cells, h };
}
function tableDeleteColumn(t, at) {
  if (t.cols <= 1) return t; t = clone(t);
  const cells = clone(t.cells);
  const colWidths = t.colWidths.slice(); colWidths.splice(at,1);

  // Adjust spans for merged cells that intersect the deleted column
  const toDelete = new Set();
  Object.values(cells).forEach(cell => {
    if (!cell) return;
    const left = cell.col; const right = cell.col + (cell.colSpan || 1) - 1;
    if (at >= left && at <= right) {
      if ((cell.colSpan || 1) > 1) {
        // Deleting inside this horizontal span reduces its width by 1
        cell.colSpan = (cell.colSpan || 1) - 1;
        // If the anchor starts at the deleted column, keep anchor at same index after splice
      } else {
        // Single-width cell fully removed by this column delete
        toDelete.add(cell.id);
      }
    }
    // Shift anchors to the right of the deleted column
    if (cell.col > at) cell.col -= 1;
  });

  // Remove the column from the grid
  const grid = t.grid.map(r => { const x = r.slice(); x.splice(at, 1); return x; });

  // Drop cells that have been fully removed
  toDelete.forEach(id => { delete cells[id]; });

  const w = colWidths.reduce((a,b)=>a+b,0);
  return { ...t, cols: t.cols - 1, grid, colWidths, cells, w };
}
function tableDeleteRowsRange(t, r0, r1){
	if (!t) return t;
	const rr0 = Math.max(0, Math.min(r0, r1));
	const rr1 = Math.min((t.rows || 0) - 1, Math.max(r0, r1));
	if (!Number.isFinite(rr0) || !Number.isFinite(rr1) || rr1 < rr0) return t;
	let next = t;
	for (let i = rr0; i <= rr1; i++){
		next = tableDeleteRow(next, rr0);
		if (next.rows <= 1) break;
	}
	// Recompute height after batch
	if (next && Array.isArray(next.rowHeights)) next.h = next.rowHeights.reduce((a,b)=>a+b,0);
	return next;
}
function tableDeleteColsRange(t, c0, c1){
	if (!t) return t;
	const cc0 = Math.max(0, Math.min(c0, c1));
	const cc1 = Math.min((t.cols || 0) - 1, Math.max(c0, c1));
	if (!Number.isFinite(cc0) || !Number.isFinite(cc1) || cc1 < cc0) return t;
	let next = t;
	for (let i = cc0; i <= cc1; i++){
		next = tableDeleteColumn(next, cc0);
		if (next.cols <= 1) break;
	}
	// Recompute width after batch
	if (next && Array.isArray(next.colWidths)) next.w = next.colWidths.reduce((a,b)=>a+b,0);
	return next;
}
function tableSplitAnchor(t, r, c){ const id = t.grid[r][c]; const cell = t.cells[id]; if (!cell) return t; if (cell.rowSpan===1 && cell.colSpan===1) return t; const {row, col, rowSpan, colSpan} = cell; for (let rr=row; rr<row+rowSpan; rr++){ for (let cc=col; cc<col+colSpan; cc++){ const cid = (rr===row && cc===col) ? id : generateId('cell'); if (!t.cells[cid]) t.cells[cid] = { id:cid, row:rr, col:cc, rowSpan:1, colSpan:1, hidden:false, content:"", styles:clone(cell.styles), attrs: clone(cell.attrs||{}) }; t.grid[rr][cc] = cid; t.cells[cid].hidden = false; t.cells[cid].rowSpan = 1; t.cells[cid].colSpan = 1; } } cell.rowSpan = 1; cell.colSpan = 1; return t; }
function tableNormalizeRange(t, r0,c0,r1,c1){ t = clone(t); const {r0:rr0,c0:cc0,r1:rr1,c1:cc1} = normalizeRange(r0,c0,r1,c1); const seen = new Set(); for (let r=rr0;r<=rr1;r++){ for (let c=cc0;c<=cc1;c++){ const id = t.grid[r][c]; if (!seen.has(id)){ seen.add(id); const a = t.cells[id]; if (a.rowSpan>1 || a.colSpan>1) t = tableSplitAnchor(t, a.row, a.col); } } } return t; }
function tableMergeRange(t, r0,c0,r1,c1) { t = tableNormalizeRange(t, r0,c0,r1,c1); const { r0:rr0,c0:cc0,r1:rr1,c1:cc1 } = normalizeRange(r0,c0,r1,c1); const anchorId = t.grid[rr0][cc0]; const cell = t.cells[anchorId]; cell.row = rr0; cell.col = cc0; cell.rowSpan = rr1-rr0+1; cell.colSpan = cc1-cc0+1; for (let r=rr0;r<=rr1;r++){ for (let c=cc0;c<=cc1;c++){ const id = t.grid[r][c]; if (id !== anchorId){ t.cells[id].hidden = true; t.grid[r][c] = anchorId; } } } return t; }
function tableUnmerge(t, r, c) { t = clone(t); const anchorId = t.grid[r][c]; const cell = t.cells[anchorId]; if (!cell || (cell.rowSpan===1 && cell.colSpan===1)) return t; return tableSplitAnchor(t, cell.row, cell.col); }
function tableUnmergeRange(t, r0, c0, r1, c1){
	// Unmerge any merged blocks that intersect the range
	return tableNormalizeRange(t, r0, c0, r1, c1);
}

// ===== Table rendering =====
function renderTable(elModel, host) {
  host.classList.add('table'); host.innerHTML = '';
  const grid = document.createElement('div'); grid.className = 'table-grid';
  // A11y: grid semantics
  grid.setAttribute('role', 'grid');
  grid.setAttribute('aria-rowcount', String(elModel.rows));
  grid.setAttribute('aria-colcount', String(elModel.cols));
  grid.style.gridTemplateColumns = elModel.colWidths.map(px=>`${px}px`).join(' ');
  grid.style.gridTemplateRows    = elModel.rowHeights.map(px=>`${px}px`).join(' ');
  for (let r=0; r<elModel.rows; r++){
    for (let c=0; c<elModel.cols; c++){
      const id = elModel.grid[r][c]; const cell = elModel.cells[id];
      // Render only anchor positions of cells (skip duplicates mapped to the anchor id)
      if (!cell || cell.hidden || cell.row !== r || cell.col !== c) continue;
      const div = document.createElement('div'); div.className = 'table-cell'; div.dataset.tableId = elModel.id; div.dataset.r = r; div.dataset.c = c; div.dataset.id = id;
      div.setAttribute('role', 'gridcell');
      div.setAttribute('aria-rowindex', String(r+1));
      div.setAttribute('aria-colindex', String(c+1));
      div.setAttribute('aria-selected', 'false');
      // Roving tabindex: active cell focusable, others -1
      const isActive = tableSel ? (tableSel.tableId===elModel.id && r===Math.min(tableSel.r0, tableSel.r1) && c===Math.min(tableSel.c0, tableSel.c1)) : (r===0 && c===0);
      div.tabIndex = isActive ? 0 : -1;
      div.style.gridColumnStart = (c + 1);
      div.style.gridRowStart = (r + 1);
      div.style.gridColumnEnd = `span ${cell.colSpan}`;
      div.style.gridRowEnd = `span ${cell.rowSpan}`;
      // Apply per-cell attributes (including inline event handlers like onclick)
      try {
        const attrs = cell.attrs || {};
        Object.keys(attrs).forEach((name) => {
          const val = attrs[name];
          if (val === false || val == null || val === '') div.removeAttribute(name);
          else if (val === true) div.setAttribute(name, '');
          else div.setAttribute(name, String(val));
        });
      } catch {}
      applyCellStyles(div, cell); 
      div.textContent = cell.content || '';
      div.addEventListener('mousedown', onTableCellMouseDown);
      // Double-click: enter edit mode and place caret at click position
      div.addEventListener('dblclick', (ev) => startEditCell(ev, { caret: 'at-click' }));
      grid.appendChild(div);
    }
  }
  const outer = document.createElement('div'); outer.className = 'table-outer'; outer.style.borderColor = elModel.border.color;
  host.appendChild(grid); host.appendChild(outer);
  host.dataset.id = elModel.id;

  // Ghost resizer
  const ghostV = document.createElement('div'); ghostV.className = 'table-resizer v'; ghostV.style.display='none';
  const ghostH = document.createElement('div'); ghostH.className = 'table-resizer h'; ghostH.style.display='none';
  host.appendChild(ghostV); host.appendChild(ghostH);

  // Hover & drag on grid
  let dragRC = null; // { kind:'row'|'col', index, start, startSizes }
  grid.addEventListener('mousemove', (e)=>{
    if (dragRC) return; // dragging, ghost is driven elsewhere
    // In view mode, never show resize affordances or cursors
    if (!Model || !Model.document || !Model.document.editMode){
      ghostV.style.display='none'; ghostH.style.display='none';
      grid.classList.remove('resizing','row');
      return;
    }
    const hit = hitTableBoundary(host, elModel, e.clientX, e.clientY, 6);
    ghostV.style.display='none'; ghostH.style.display='none';
    grid.classList.remove('resizing','row');

    if (hit?.kind === 'col'){
      grid.classList.add('resizing'); grid.classList.remove('row');
      const x = getTableAccumSizes(elModel.colWidths)[hit.index+1];
      ghostV.style.left = x + 'px'; ghostV.style.top = 0; ghostV.style.bottom = 0; ghostV.style.display='block';
    } else if (hit?.kind === 'row'){
      grid.classList.add('resizing','row');
      const y = getTableAccumSizes(elModel.rowHeights)[hit.index+1];
      ghostH.style.top = y + 'px'; ghostH.style.left = 0; ghostH.style.right = 0; ghostH.style.display='block';
    }
  });

  grid.addEventListener('mouseleave', ()=>{
    if (!dragRC){ ghostV.style.display='none'; ghostH.style.display='none'; grid.classList.remove('resizing','row'); }
  });

  // Allow grabbing the ghost line itself
  function startResizeFromEvent(e){
    // Block resizing entirely in view mode
    if (!Model || !Model.document || !Model.document.editMode) return;
    const hit = hitTableBoundary(host, elModel, e.clientX, e.clientY, 6);
    if (!hit) return; e.stopPropagation(); e.preventDefault();
    commitHistory('table-resize'); // single history entry
    dragRC = { kind: hit.kind, index: hit.index, start: {x:e.clientX, y:e.clientY}, startSizes: { cols:[...elModel.colWidths], rows:[...elModel.rowHeights] } };
    document.addEventListener('mousemove', onDrag); document.addEventListener('mouseup', onUp);
    function onDrag(ev){
      const z = getZoom();
      const dx = (ev.clientX - dragRC.start.x) / z; const dy = (ev.clientY - dragRC.start.y) / z;
      // Always start from the latest model on the page to avoid reverting x/y (position) or other props
      const page = getCurrentPage();
      const idx = page.elements.findIndex(e => e.id === elModel.id);
      const current = idx !== -1 ? page.elements[idx] : elModel;
      const T = clone(current);
      if (dragRC.kind === 'col'){
        const i = dragRC.index;
        const next = Math.max(10, dragRC.startSizes.cols[i] + dx);
        if (tableSel && tableSel.tableId === elModel.id && i>=tableSel.c0 && i<=tableSel.c1){
          for (let c=tableSel.c0;c<=tableSel.c1;c++) T.colWidths[c] = next;
        } else {
          T.colWidths[i] = next;
        }
        T.w = T.colWidths.reduce((a,b)=>a+b,0);
      } else {
        const i = dragRC.index;
        const next = Math.max(10, dragRC.startSizes.rows[i] + dy);
        if (tableSel && tableSel.tableId === elModel.id && i>=tableSel.r0 && i<=tableSel.r1){
          for (let r=tableSel.r0;r<=tableSel.r1;r++) T.rowHeights[r] = next;
        } else {
          T.rowHeights[i] = next;
        }
        T.h = T.rowHeights.reduce((a,b)=>a+b,0);
      }
      // live update without stacking history: mutate page element in place and re-render table only
      if (idx !== -1) page.elements[idx] = T; else {
        // If element wasn't found (shouldn't happen), bail gracefully
        return;
      }
      renderPage(page);
    }
    function onUp(){
      document.removeEventListener('mousemove', onDrag);
      document.removeEventListener('mouseup', onUp);
      dragRC = null; ghostV.style.display='none'; ghostH.style.display='none'; grid.classList.remove('resizing','row');
    }
  }
  // Use capture so resize can start even when a cell's mousedown stops propagation
  grid.addEventListener('mousedown', startResizeFromEvent, true);
  ghostV.addEventListener('mousedown', startResizeFromEvent);
  ghostH.addEventListener('mousedown', startResizeFromEvent);
  // Also guard touch/pen
  grid.addEventListener('touchstart', startResizeFromEvent, { passive:false, capture:true });
  // Keyboard navigation per APG grid patterns
  grid.addEventListener('keydown', (e) => onTableGridKeydown(e, elModel.id));
  // Clicking anywhere outside the grid clears the selection
  const onDocClick = (ev) => {
    const t = ev.target;
    // Ignore clicks inside the table itself
    if (host.contains(t)) return;
    // Ignore clicks inside the format toolbar or other editor overlays
    const bar = formatToolbar();
    if (bar && bar.contains(t)) return;
    // Ignore clicks inside side panels (elements/properties)
    const propsPanel = document.getElementById('propertiesPanel');
    if (propsPanel && propsPanel.contains && propsPanel.contains(t)) return;
    const elsPanel = document.getElementById('elementsPanel');
    if (elsPanel && elsPanel.contains && elsPanel.contains(t)) return;
    const tblMenu = document.getElementById('tableActions');
    if (tblMenu && tblMenu.contains(t)) return;
    const bubble = elementActions && elementActions();
    if (bubble && bubble.contains && bubble.contains(t)) return;
    const selBox = selectionBoxEl && selectionBoxEl();
    if (selBox && selBox.contains && selBox.contains(t)) return;
    // Ignore clicks within custom color picker
    const colorPicker = document.querySelector('.custom-color-picker');
    if (colorPicker && colorPicker.contains && colorPicker.contains(t)) return;
    // Ignore while in picking mode
    if (window.__PICKING) return;
    clearTableSelection();
    document.removeEventListener('mousedown', onDocClick);
  };
  setTimeout(() => document.addEventListener('mousedown', onDocClick), 0);
}
function applyCellStyles(div, cell) {
  const h = cell.styles.alignH || 'left'; const v = cell.styles.alignV || 'top';
  div.style.justifyContent = h==='left' ? 'flex-start' : (h==='center' ? 'center' : 'flex-end');
  div.style.alignItems = v==='top' ? 'flex-start' : (v==='middle' ? 'center' : 'flex-end');
  // Ensure wrapped text inside cells follows horizontal alignment
  div.style.textAlign = h==='left' ? 'left' : (h==='center' ? 'center' : 'right');
  div.style.padding = (cell.styles.padding ?? 8) + 'px';
  if (cell.styles.bg) div.style.background = cell.styles.bg;
  if (cell.styles.textColor) div.style.color = cell.styles.textColor;
  if (cell.styles.fontFamily) div.style.fontFamily = cell.styles.fontFamily;
  if (cell.styles.fontSize) div.style.fontSize = (cell.styles.fontSize || 14) + 'pt';
  // Typography
  if (typeof cell.styles.bold !== 'undefined') div.style.fontWeight = cell.styles.bold ? '700' : '400';
  if (typeof cell.styles.italic !== 'undefined') div.style.fontStyle = cell.styles.italic ? 'italic' : 'normal';
  if (typeof cell.styles.underline !== 'undefined') div.style.textDecoration = cell.styles.underline ? 'underline' : 'none';
  // Borders per side
  const bw = Number(cell.styles.borderWidth ?? cell.styles.strokeWidth ?? 1);
  const bc = cell.styles.borderColor || cell.styles.strokeColor || '#000000';
  const sides = cell.styles.borders || { top:false,right:false,bottom:false,left:false };
  div.style.borderTop = sides.top ? `${bw}px solid ${bc}` : '0 solid transparent';
  div.style.borderRight = sides.right ? `${bw}px solid ${bc}` : '0 solid transparent';
  div.style.borderBottom = sides.bottom ? `${bw}px solid ${bc}` : '0 solid transparent';
  div.style.borderLeft = sides.left ? `${bw}px solid ${bc}` : '0 solid transparent';
}

// --- Table geometry helpers
function getTableAccumSizes(arr){ const out=[0]; let acc=0; for (const v of arr){ acc+=v; out.push(acc); } return out; }
function hitTableBoundary(tableNode, model, clientX, clientY, pad=6){
  const grid = tableNode.querySelector('.table-grid'); if (!grid) return null;
  const r = grid.getBoundingClientRect();
  const z = getZoom();
  const x = (clientX - r.left) / z, y = (clientY - r.top) / z;
  if (x < -pad || y < -pad || x > r.width+pad || y > r.height+pad) return null;
  const cols = getTableAccumSizes(model.colWidths);
  const rows = getTableAccumSizes(model.rowHeights);
  let vDist = Infinity, vIdx = -1; cols.forEach((cx,i)=>{ const d=Math.abs(x-cx); if (d< vDist){ vDist=d; vIdx=i; }});
  let hDist = Infinity, hIdx = -1; rows.forEach((cy,i)=>{ const d=Math.abs(y-cy); if (d< hDist){ hDist=d; hIdx=i; }});
  // Allow resizing on the outermost right/bottom boundaries as well
  const nearV = vDist<=pad && vIdx>0; // exclude left outer edge only
  const nearH = hDist<=pad && hIdx>0; // exclude top outer edge only
  if (!nearV && !nearH) return null;
  return { kind: nearV ? 'col' : 'row', index: nearV ? (vIdx-1) : (hIdx-1), rect: r };
}

// ===== Table selection state =====
let tableSel = null; // { tableId, r0,c0,r1,c1 }
let lastTableSel = null; // Track last table selection for fallback behavior
const isTableContext = () => !!tableSel || (getSelectedElement()?.type === 'table');
function getSelectedElement(){ return selectedIds.size===1 ? getElementById([...selectedIds][0]) : null; }
function setTableSelection(tableId, r0,c0,r1,c1){ 
  // Clear lastTableSel if switching to a different table
  if (lastTableSel && lastTableSel.tableId !== tableId) {
    lastTableSel = null;
  }
  
  // Normalize selection so ranges work regardless of drag direction
  const rr0 = Math.min(r0, (r1 ?? r0));
  const cc0 = Math.min(c0, (c1 ?? c0));
  const rr1 = Math.max(r0, (r1 ?? r0));
  const cc1 = Math.max(c0, (c1 ?? c0));
  
  tableSel = { tableId, r0: rr0, c0: cc0, r1: rr1, c1: cc1 }; 
  lastTableSel = { ...tableSel }; // Track for fallback behavior
  highlightTableSelection(); 
  updateToolbarForSelection(); 
  updateFormatToolbarVisibility(); 
}
function clearTableSelection(){
  tableSel = null;
  // Don't clear lastTableSel here - keep it for fallback behavior
  document.querySelectorAll('.table-cell.is-selected,.table-cell.is-range,.table-cell.selected').forEach(n=>{
    n.classList.remove('is-selected','is-range','selected');
    n.setAttribute('aria-selected','false');
    n.tabIndex = -1;
  });
  // Remove selection overlay if present
  document.querySelectorAll('.table-selection').forEach(n=> n.remove());
  updateToolbarForSelection(); updateFormatToolbarVisibility();
  const bar = document.getElementById('tableActions'); if (bar) bar.classList.add('hidden');
}
function highlightTableSelection(){
  document.querySelectorAll('.table-cell.is-selected,.table-cell.is-range,.table-cell.selected').forEach(n=>{
    n.classList.remove('is-selected','is-range','selected');
    n.setAttribute('aria-selected','false');
  });
  if (!tableSel) return;
  const {tableId,r0,c0,r1,c1} = tableSel; const tNode = getElementNode(tableId); if (!tNode) return;
  const cells = tNode.querySelectorAll('.table-cell');
  for (const div of cells){
    const r = +div.dataset.r, c=+div.dataset.c;
    if (r===r0 && c===c0 && r===r1 && c===c1){ div.classList.add('is-selected','selected'); div.setAttribute('aria-selected','true'); div.tabIndex = 0; }
    else if (r>=r0 && r<=r1 && c>=c0 && c<=c1){ div.classList.add('is-range'); div.setAttribute('aria-selected','true'); div.tabIndex = -1; }
    else { div.tabIndex = -1; }
  }
  // Draw single overlay rectangle around the selected range (handles merged cells)
  const grid = tNode.querySelector('.table-grid');
  if (grid){
    // Remove any existing selection overlays for this table
    grid.querySelectorAll(':scope > .table-selection').forEach(n=> n.remove());
    // Compute bounding box of selection using anchor cell DOM rects
    const a = grid.querySelector(`.table-cell[data-r="${r0}"][data-c="${c0}"]`);
    const b = grid.querySelector(`.table-cell[data-r="${r1}"][data-c="${c1}"]`);
    if (a && b){
      const ra = a.getBoundingClientRect();
      const rb = b.getBoundingClientRect();
      const rg = grid.getBoundingClientRect();
      const z = getZoom();
      // Work in viewport (transformed) pixels, then convert to unscaled CSS pixels
      const leftV = Math.min(ra.left, rb.left) - rg.left;
      const topV = Math.min(ra.top, rb.top) - rg.top;
      const rightV = Math.max(ra.right, rb.right) - rg.left;
      const bottomV = Math.max(ra.bottom, rb.bottom) - rg.top;
      const sel = document.createElement('div');
      sel.className = 'table-selection';
      sel.style.left = (leftV / z) + 'px';
      sel.style.top = (topV / z) + 'px';
      sel.style.width = ((rightV - leftV) / z) + 'px';
      sel.style.height = ((bottomV - topV) / z) + 'px';
      const handle = document.createElement('div'); handle.className = 'handle'; sel.appendChild(handle);
      grid.appendChild(sel);
    }
  }
  const sr = document.getElementById('srAnnouncer'); if (sr){ sr.textContent = `Selected ${r1-r0+1} by ${c1-c0+1} cells.`; }
  // Reflect anchor cell styles in toolbar every time selection changes
  const tModel = getElementById(tableSel.tableId);
  if (tModel) syncFormatToolbar(tModel);
  // Update Properties panel for cellId
  renderProperties();
}
function onTableCellMouseDown(e){
  // Do not alter selection while picker mode is active
  if (window.__PICKING) { e.preventDefault(); e.stopPropagation(); return; }
  if (e.button !== 0) return; // right-click shouldn't change selection
  e.stopPropagation();
  const div = e.currentTarget; const tableId = div.dataset.tableId; const r = +div.dataset.r, c = +div.dataset.c;
  setTableSelection(tableId, r, c);
  // Move focus to the active cell for keyboarding
  div.focus();
  const onMove = (ev)=>{ const over = ev.target.closest('.table-cell'); if (!over || over.dataset.tableId !== tableId) return; const rr = +over.dataset.r, cc = +over.dataset.c; setTableSelection(tableId, r, c, rr, cc); };
  const onUp = ()=>{ window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); };
  window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp);
}
function startEditCell(e, opts){
  const div = e.currentTarget; const tableId = div.dataset.tableId; const r = +div.dataset.r, c = +div.dataset.c;
  setTableSelection(tableId, r, c);
  // Use plaintext-only when available
  if (div.contentEditable !== 'plaintext-only') div.setAttribute('contenteditable','plaintext-only');
  div.setAttribute('role','textbox');
  div.focus();
  // If cell has a stored formula, show it while editing
  try {
    const t = getElementById(tableId); const id = t.grid[r][c];
    const cell = t.cells[id]; const ff = String(cell?.attrs?.formula || '').trim();
    if (ff) div.textContent = ff;
  } catch {}
  let before = div.textContent || '';
  // If entering with an existing formula or starts with '=', enable picker
  try {
    if ((div.textContent || '').trim().startsWith('=')) {
      if (typeof window.startInlineFormulaPicker === 'function') window.startInlineFormulaPicker(div);
    }
  } catch {}
  // Optional initial overwrite (for single-key typing)
  if (opts && Object.prototype.hasOwnProperty.call(opts, 'initialText')) {
    div.textContent = String(opts.initialText ?? '');
  }
  // Helper: place caret
  const placeCaret = () => {
    const sel = window.getSelection(); if (!sel) return;
    const textNode = div.firstChild;
    const wantClick = opts && opts.caret === 'at-click' && typeof e.clientX === 'number' && typeof e.clientY === 'number';
    if (wantClick && (document.caretPositionFromPoint || document.caretRangeFromPoint)){
      let range = null;
      if (document.caretPositionFromPoint){
        const pos = document.caretPositionFromPoint(e.clientX, e.clientY);
        if (pos) { range = document.createRange(); range.setStart(pos.offsetNode, pos.offset); }
      } else if (document.caretRangeFromPoint){
        range = document.caretRangeFromPoint(e.clientX, e.clientY);
      }
      if (range){ sel.removeAllRanges(); sel.addRange(range); return; }
    }
    // Default: end of content (continue typing after initialText)
    if (textNode && textNode.nodeType === Node.TEXT_NODE){
      const range = document.createRange();
      const len = textNode.textContent?.length || 0;
      range.setStart(textNode, len);
      range.collapse(true);
      sel.removeAllRanges(); sel.addRange(range);
    }
  };
  // Place caret after any initial overwrite or at click
  placeCaret();
  const commit = () => {
    const text = sanitizePlaintext(div.textContent || '');
    const t = getElementById(tableId); const id = t.grid[r][c];
    // If starts with '=', store into cell.attrs.formula and recalc
    if (text.trim().startsWith('=')){
      t.cells[id].attrs = Object.assign({}, t.cells[id].attrs, { formula: text.trim() });
      try { if (typeof window.recalculateAllFormulas === 'function') window.recalculateAllFormulas(); } catch {}
    } else {
      // direct content
      t.cells[id].content = text;
      if (t.cells[id].attrs && t.cells[id].attrs.formula && text.trim() === ''){
        delete t.cells[id].attrs.formula;
      }
    }
    // Fire a synthetic change event so inline onchange handlers on the cell can react after commit
    try {
      const evt = new Event('change', { bubbles: true });
      div.dispatchEvent(evt);
      // Also provide a custom event with details for power users
      const cust = new CustomEvent('cellchange', { bubbles: true, detail: { tableId, r, c, value: text } });
      div.dispatchEvent(cust);
    } catch {}
    renderPage(getCurrentPage());
    const cell = getElementNode(tableId)?.querySelector(`.table-cell[data-r="${r}"][data-c="${c}"]`);
    if (cell) cell.focus();
  };
  const cancel = () => { div.textContent = before; };
  const onBlur = () => { cleanup(); commit(); };
  const onKey = (ev) => {
    if (ev.key === 'Enter' && ev.shiftKey) { ev.preventDefault(); div.textContent = (div.textContent || '') + "\n"; placeCaret(); }
    else if (ev.key === 'Enter') { ev.preventDefault(); cleanup(); commit(); }
    else if (ev.key === 'Escape') { ev.preventDefault(); cancel(); cleanup(); renderPage(getCurrentPage()); }
    else if (ev.key.length === 1 && ev.key === '=' && div.textContent === before){
      // Start formula mode when first character is '='
      ev.preventDefault();
      div.textContent = '=';
      try { if (typeof window.startInlineFormulaPicker === 'function') window.startInlineFormulaPicker(div); } catch {}
    }
    else if (ev.key === 'Tab') {
      ev.preventDefault(); const backward = ev.shiftKey;
      cleanup(); commit();
      const t = getElementById(tableId); if (!t) return;
      let nr = r, nc = backward ? c - 1 : c + 1;
      if (nc < 0) { nc = t.cols - 1; nr = Math.max(0, r - 1); }
      if (nc >= t.cols) { nc = 0; nr = Math.min(t.rows - 1, r + 1); }
      const mapped = mapToAnchorCoords(t, nr, nc); nr = mapped.r; nc = mapped.c;
      setTableSelection(tableId, nr, nc);
      const node = getElementNode(tableId)?.querySelector(`.table-cell[data-r="${nr}"][data-c="${nc}"]`); if (node) node.focus();
    }
  };
  function cleanup(){ div.removeEventListener('blur', onBlur); div.removeEventListener('keydown', onKey); div.setAttribute('contenteditable','false'); div.removeAttribute('role'); }
  div.addEventListener('blur', onBlur);
  div.addEventListener('keydown', onKey);

  // Support inline picker for cell editing via global helper
  try {
    // When user clicks other elements while editing a formula, tokens should insert into this cell
    // The startInlineFormulaPicker returns a done() to stop; store it on node for blur cleanup
    if ((div.textContent || '').trim().startsWith('=') && typeof window.startInlineFormulaPicker === 'function'){
      const stop = window.startInlineFormulaPicker(div);
      div._pickerStop = stop;
      const prevOnBlur = onBlur;
    }
  } catch {}
}

function sanitizePlaintext(text){
  const t = String(text || '').replace(/\r\n?/g, '\n');
  return t; // preserve all spaces and trailing whitespace per user request
}

/* ===== Excel-style Clipboard (Table) ===== */

/** Parse clipboard text into a 2D grid. Supports TSV, CSV, and semicolon CSV. */
function parseClipboardGrid(text) {
  const norm = String(text || '').replace(/\r\n?/g, '\n').replace(/\n+$/, '');
  if (!norm) return [[]];

  const lines = norm.split('\n');

  // Detect delimiter: prefer tabs; otherwise choose between comma/semicolon by count
  let delim = '\t';
  if (!lines.some(l => l.includes('\t'))) {
    const comma = lines.reduce((a, l) => a + (l.match(/,/g)?.length || 0), 0);
    const semi  = lines.reduce((a, l) => a + (l.match(/;/g)?.length || 0), 0);
    delim = semi > comma ? ';' : ',';
  }

  return lines.map(line => {
    if (delim === '\t') return line.split('\t'); // TSV is simple
    // Basic CSV split (no quotes handling) — good enough for Excel simple exports
    // If you need full CSV, plug a small parser here.
    return line.split(delim);
  });
}

/** Serialize a 2D grid to TSV (Excel-friendly). */
function gridToTSV(grid) {
  return grid.map(row =>
    row.map(v => String(v ?? '').replace(/\r\n?/g, '\n')).join('\t')
  ).join('\n');
}

/** Extract a 2D grid of text from the current table selection. */
function extractGridFromSelection(t, r0, c0, r1, c1) {
  const rows = r1 - r0 + 1, cols = c1 - c0 + 1;
  const out = Array.from({ length: rows }, () => Array(cols).fill(''));
  for (let r = r0; r <= r1; r++) {
    for (let c = c0; c <= c1; c++) {
      const id = t.grid[r][c];
      const cell = t.cells[id];
      if (!cell || cell.hidden) continue;
      if (cell.row === r && cell.col === c) {
        const f = String(cell?.attrs?.formula || '').trim();
        out[r - r0][c - c0] = f ? f : String(cell.content ?? '');
      }
    }
  }
  return out;
}

/** Ensure table can contain target area; returns possibly modified table object. */
function ensureTableSize(t, needRows, needCols, startR, startC) {
  let next = clone(t);
  const targetRows = startR + needRows;
  const targetCols = startC + needCols;
  while (next.rows < targetRows) next = tableAddRow(next, next.rows);
  while (next.cols < targetCols) next = tableAddColumn(next, next.cols);
  return next;
}

/** Paste a grid into the table starting at (startR,startC); auto-expands and unmerges as needed. */
function pasteGridIntoTable(t, startR, startC, grid, opts) {
  const valuesOnly = !!(opts && opts.valuesOnly);
  const rows = grid.length;
  const cols = Math.max(...grid.map(r => r.length), 1);

  let next = ensureTableSize(t, rows, cols, startR, startC);
  // Unmerge target area so each destination cell is addressable
  next = tableNormalizeRange(next, startR, startC, startR + rows - 1, startC + cols - 1);

  for (let rr = 0; rr < rows; rr++) {
    for (let cc = 0; cc < cols; cc++) {
      const r = startR + rr, c = startC + cc;
      const id = next.grid[r][c];
      const cell = next.cells[id];
      if (!cell || cell.hidden) continue;
      const raw = String(grid[rr][cc] ?? '');
      if (valuesOnly) {
        if (raw.trim().startsWith('=')) {
          try {
            const ev = (typeof window !== 'undefined' && typeof window.evaluateFormulaExpression === 'function') ? window.evaluateFormulaExpression(raw) : null;
            cell.content = String(ev && Object.prototype.hasOwnProperty.call(ev, 'value') ? ev.value : raw.replace(/^=/, ''));
          } catch {
            cell.content = raw.replace(/^=/, '');
          }
        } else {
          cell.content = raw;
        }
        if (cell.attrs && cell.attrs.formula) delete cell.attrs.formula;
      } else {
        if (raw.trim().startsWith('=')) {
          cell.attrs = Object.assign({}, cell.attrs, { formula: raw.trim() });
          // Content will be recalculated after paste
        } else {
          cell.content = raw;
          if (cell.attrs && cell.attrs.formula && raw.trim() === '') delete cell.attrs.formula;
        }
      }
    }
  }
  return next;
}

/** Clear text content in all cells within [r0..r1] x [c0..c1] (anchors only). */
function tableClearRangeContent(t, r0, c0, r1, c1) {
  t = clone(t);
  const rr0 = Math.min(r0, r1), rr1 = Math.max(r0, r1);
  const cc0 = Math.min(c0, c1), cc1 = Math.max(c0, c1);
  for (let r = rr0; r <= rr1; r++) {
    for (let c = cc0; c <= cc1; c++) {
      const id = t.grid[r][c];
      const cell = t.cells[id];
      if (!cell || cell.hidden) continue;
      if (cell.row === r && cell.col === c) {
        cell.content = "";
      }
    }
  }
  return t;
}

/** When a table selection exists (or a focused .table-cell), return anchor coords. */
function getActiveTableAnchor() {
  if (tableSel) {
    return {
      tableId: tableSel.tableId,
      r: Math.min(tableSel.r0, tableSel.r1),
      c: Math.min(tableSel.c0, tableSel.c1),
    };
  }
  const active = document.activeElement;
  const div = active && active.classList && active.classList.contains('table-cell') ? active : null;
  if (div) {
    return {
      tableId: div.dataset.tableId,
      r: Number(div.dataset.r),
      c: Number(div.dataset.c),
    };
  }
  return null;
}

/** Bind global clipboard handlers for table copy/paste. */
function bindTableClipboard() {
  // COPY
  document.addEventListener('copy', (e) => {
    // Don't hijack when user is editing text inside a cell
    const active = document.activeElement;
    const isEditing = active && (active.isContentEditable || active.tagName === 'INPUT' || active.tagName === 'TEXTAREA');
    if (isEditing) return;

    const anchor = getActiveTableAnchor();
    if (!anchor) return;

    const t = getElementById(anchor.tableId);
    if (!t) return;

    const r0 = Math.min(tableSel?.r0 ?? anchor.r, tableSel?.r1 ?? anchor.r);
    const c0 = Math.min(tableSel?.c0 ?? anchor.c, tableSel?.c1 ?? anchor.c);
    const r1 = Math.max(tableSel?.r0 ?? anchor.r, tableSel?.r1 ?? anchor.r);
    const c1 = Math.max(tableSel?.c0 ?? anchor.c, tableSel?.c1 ?? anchor.c);

    const grid = extractGridFromSelection(t, r0, c0, r1, c1);
    const tsv = gridToTSV(grid);

    e.preventDefault();
    e.clipboardData.setData('text/plain', tsv);

    // Optional: lightweight HTML table
    const html = '<table>' + grid.map(row => '<tr>' + row.map(cell =>
      `<td>${String(cell ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;')}</td>`
    ).join('') + '</tr>').join('') + '</table>';
    e.clipboardData.setData('text/html', html);
  });

  // PASTE
  document.addEventListener('paste', (e) => {
    const active = document.activeElement;
    const isEditing = active && (active.isContentEditable || active.tagName === 'INPUT' || active.tagName === 'TEXTAREA');
    if (isEditing) return; // Let native paste work inside text editing

    const anchor = getActiveTableAnchor();
    if (!anchor) return;

    const text = e.clipboardData.getData('text/plain');
    if (!text) return;

    e.preventDefault();

    const t = getElementById(anchor.tableId);
    if (!t) return;

    const grid = parseClipboardGrid(text);
    const valuesOnly = !!(typeof window !== 'undefined' && window.__valuesOnlyPaste);
    let next = pasteGridIntoTable(t, anchor.r, anchor.c, grid, { valuesOnly });

    // Commit once, rerender, and select the pasted rectangle
    commitHistory('table-paste');
    updateElement(t.id, next);
    setTableSelection(t.id, anchor.r, anchor.c, anchor.r + grid.length - 1, anchor.c + Math.max(...grid.map(r => r.length), 1) - 1);
    try {
      if (typeof window.recalculateAllFormulas === 'function') window.recalculateAllFormulas();
      renderPage(getCurrentPage());
    } catch {}
    try { window.__valuesOnlyPaste = false; } catch {}
  });
}

// ===== Commands / toolbar integration =====
function updateToolbarForSelection(){ /* main toolbar remains generic */ }
function withActiveTable(fn){ const el = getSelectedElement(); if (el?.type === 'table') return fn(el.id, el); if (tableSel) return fn(tableSel.tableId, getElementById(tableSel.tableId)); }
function mapToAnchorCoords(tableModel, r, c){ const id = tableModel.grid[r]?.[c]; const cell = id ? tableModel.cells[id] : null; if (!cell) return { r, c }; return { r: cell.row, c: cell.col }; }
// APG grid keyboard controller
function onTableGridKeydown(e, tableId){
  if (!tableSel || tableSel.tableId !== tableId) return;
  const t = getElementById(tableId); if (!t) return;
  const { r0,c0,r1,c1 } = tableSel; const anchorR = Math.min(r0,r1), anchorC = Math.min(c0,c1);
  const maxR = t.rows - 1, maxC = t.cols - 1;
  // When editing a cell, let the editor handle keys
  const active = document.activeElement; if (active && active.isContentEditable) return;
  const grow = e.shiftKey;
  let nr = anchorR, nc = anchorC, er = Math.max(r0,r1), ec = Math.max(c0,c1);
  const prevent = () => { e.preventDefault(); };
  const commitAndFocus = () => {
    // If target lands inside a merged block, focus the anchor cell instead
    const mapped = mapToAnchorCoords(t, nr, nc); nr = mapped.r; nc = mapped.c;
    const aR = Math.min(r0,r1), aC = Math.min(c0,c1);
    const sR0 = grow ? Math.min(aR, nr) : nr;
    const sC0 = grow ? Math.min(aC, nc) : nc;
    const sR1 = grow ? Math.max(er, nr) : nr;
    const sC1 = grow ? Math.max(ec, nc) : nc;
    setTableSelection(tableId, sR0, sC0, sR1, sC1);
    const host = getElementNode(tableId); const node = host?.querySelector(`.table-cell[data-r="${nr}"][data-c="${nc}"]`); if (node) node.focus();
  };
  switch(e.key){
    case 'ArrowUp': prevent(); nr = Math.max(0, anchorR - 1); if (grow) er = Math.max(r0,r1); commitAndFocus(); break;
    case 'ArrowDown': prevent(); nr = Math.min(maxR, anchorR + 1); if (grow) er = Math.max(er, nr); commitAndFocus(); break;
    case 'ArrowLeft': prevent(); nc = Math.max(0, anchorC - 1); if (grow) ec = Math.max(c0,c1); commitAndFocus(); break;
    case 'ArrowRight': prevent(); nc = Math.min(maxC, anchorC + 1); if (grow) ec = Math.max(ec, nc); commitAndFocus(); break;
    case 'Tab': prevent(); nc = anchorC + (e.shiftKey?-1:1); if (nc<0){ nc=maxC; nr=Math.max(0,anchorR-1);} if (nc>maxC){ nc=0; nr=Math.min(maxR,anchorR+1);} commitAndFocus(); break;
    case 'Enter': prevent(); if (!grow){ nr = Math.min(maxR, Math.max(0, anchorR + (e.shiftKey?-1:1))); } commitAndFocus(); break;
    case 'Escape': clearTableSelection(); break;
    case 'Delete':
    case 'Backspace':
      e.preventDefault();
      e.stopPropagation();
      updateElement(tableId, tableClearRangeContent(t, r0, c0, r1, c1));
      // Preserve current selection after update
      setTableSelection(tableId, r0, c0, r1, c1);
      break;
    case 'F2': // start edit
      prevent();
      const node = getElementNode(tableId)?.querySelector(`.table-cell[data-r="${anchorR}"][data-c="${anchorC}"]`); if (node){ startEditCell({ currentTarget: node }); }
      break;
  }
  // Single-key typing starts edit and overwrites cell content
  if (!e.defaultPrevented && e.key && e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey){
    e.preventDefault();
    const node = getElementNode(tableId)?.querySelector(`.table-cell[data-r="${anchorR}"][data-c="${anchorC}"]`);
    if (node){ startEditCell({ currentTarget: node }, { initialText: e.key, caret: 'end' }); }
  }
}
function cmdTableAddRow(after=true){ withActiveTable((id, t)=>{ const at = tableSel ? (after ? tableSel.r1+1 : tableSel.r0) : t.rows; updateElement(id, tableAddRow(t, at)); renderPage(getCurrentPage()); highlightTableSelection(); }); }
function cmdTableAddColumn(after=true){
  withActiveTable((id, t)=>{
    const at = tableSel ? (after ? tableSel.c1+1 : tableSel.c0) : t.cols;
    // Add column without triggering block/page reflow side-effects
    if (typeof Controller === 'object') Controller.suppressReflow++;
    try {
      updateElement(id, tableAddColumn(t, at));
      renderPage(getCurrentPage());
    } finally {
      if (typeof Controller === 'object') Controller.suppressReflow = Math.max(0, (Controller.suppressReflow||0) - 1);
    }
    highlightTableSelection();
  });
}
function cmdTableDeleteRow(){ withActiveTable((id, t)=>{ if (tableSel){ const {r0,r1}=tableSel; updateElement(id, tableDeleteRowsRange(t, r0, r1)); } else { const at = t.rows-1; updateElement(id, tableDeleteRow(t, at)); } renderPage(getCurrentPage()); clearTableSelection(); }); }
function cmdTableDeleteColumn(){ withActiveTable((id, t)=>{ if (tableSel){ const {c0,c1}=tableSel; updateElement(id, tableDeleteColsRange(t, c0, c1)); } else { const at = t.cols-1; updateElement(id, tableDeleteColumn(t, at)); } renderPage(getCurrentPage()); clearTableSelection(); }); }
function cmdTableMerge(){ if (!tableSel) return; const {tableId,r0,c0,r1,c1} = tableSel; const t = getElementById(tableId); updateElement(tableId, tableMergeRange(t, r0,c0,r1,c1)); renderPage(getCurrentPage()); setTableSelection(tableId, r0,c0,r1,c1); }
function cmdTableUnmerge(){ if (!tableSel) return; const {tableId,r0,c0,r1,c1} = tableSel; const t = getElementById(tableId); const next = tableUnmergeRange(t, r0, c0, r1, c1); updateElement(tableId, next); renderPage(getCurrentPage()); setTableSelection(tableId, r0, c0, r1, c1); }
/* removed toolbar-table binding: using context menu instead */

// --- Context menu for table actions
(function bindTableContextMenu(){
  const menu = document.getElementById('tableMenu'); if (!menu) return;
  document.addEventListener('contextmenu', (e)=>{
    const cell = e.target.closest?.('.table-cell'); if (!cell) return;
    e.preventDefault();
    const tableId = cell.dataset.tableId; const r = +cell.dataset.r, c = +cell.dataset.c;
    if (!tableSel || tableSel.tableId !== tableId) setTableSelection(tableId, r, c);
    menu.style.left = e.clientX+'px'; menu.style.top = e.clientY+'px';
    menu.classList.remove('hidden');
  });
  document.addEventListener('click', (e)=>{ if (!menu.contains(e.target)) menu.classList.add('hidden'); });
  document.addEventListener('keydown', (e)=>{ if (e.key==='Escape') menu.classList.add('hidden'); });
  menu.addEventListener('click', (e)=>{
    const b = e.target.closest('[data-tm]'); if (!b) return; const act = b.dataset.tm; const s = tableSel; if (!s) return; const t = getElementById(s.tableId);
    if (act==='merge') { updateElement(t.id, tableMergeRange(t, s.r0,s.c0,s.r1,s.c1)); }
    if (act==='unmerge') { updateElement(t.id, tableUnmergeRange(t, s.r0,s.c0,s.r1,s.c1)); }
    if (act==='row-insert-above') { updateElement(t.id, tableAddRow(t, s.r0)); }
    if (act==='row-insert-below') { updateElement(t.id, tableAddRow(t, s.r1+1)); }
    if (act==='row-delete') { updateElement(t.id, tableDeleteRowsRange(t, s.r0, s.r1)); clearTableSelection(); }
    if (act==='col-insert-left') { updateElement(t.id, tableAddColumn(t, s.c0)); }
    if (act==='col-insert-right') { updateElement(t.id, tableAddColumn(t, s.c1+1)); }
    if (act==='col-delete') { updateElement(t.id, tableDeleteColsRange(t, s.c0, s.c1)); clearTableSelection(); }
    menu.classList.add('hidden');
  });
})();
// --- Minimal floating table action bar
(function bindFloatingTableActions(){
  const bar = document.getElementById('tableActions');
  if (!bar) return;

  function showIfTableSelection() {
    // Hide entirely in view mode
    const canShow = !!tableSel && (!!Model && !!Model.document && !!Model.document.editMode);
    if (canShow) bar.classList.remove('hidden');
    else bar.classList.add('hidden');
  }

  // Show/hide but DO NOT reposition
  const _set = setTableSelection;
  setTableSelection = function(...args){
    _set.apply(null, args);
    showIfTableSelection();
  };
  const _clear = clearTableSelection;
  clearTableSelection = function(){
    _clear();
    showIfTableSelection();
  };

  // Click actions
  bar.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-tact]');
    if (!btn || !tableSel) return;
    const t = getElementById(tableSel.tableId);
    switch(btn.dataset.tact){
      case 'row-add':
        updateElement(t.id, tableAddRow(t, tableSel.r1 + 1));
        // Keep selection on newly inserted band
        setTableSelection(t.id, tableSel.r0 + 1, tableSel.c0, tableSel.r1 + 1, tableSel.c1);
        break;
      case 'col-add':
        updateElement(t.id, tableAddColumn(t, tableSel.c1 + 1));
        // Keep selection on newly inserted band
        setTableSelection(t.id, tableSel.r0, tableSel.c0 + 1, tableSel.r1, tableSel.c1 + 1);
        break;
      case 'row-del':
        updateElement(t.id, tableDeleteRowsRange(t, tableSel.r0, tableSel.r1));
        clearTableSelection();
        break;
      case 'col-del':
        updateElement(t.id, tableDeleteColsRange(t, tableSel.c0, tableSel.c1));
        clearTableSelection();
        break;
      case 'merge':
        updateElement(t.id, tableMergeRange(t, tableSel.r0, tableSel.c0, tableSel.r1, tableSel.c1));
        break;
      case 'unmerge':
        updateElement(t.id, tableUnmergeRange(t, tableSel.r0, tableSel.c0, tableSel.r1, tableSel.c1));
        break;
    }
    showIfTableSelection();
  });

  // Initial state
  showIfTableSelection();
})();
// pure ops for resize/distribute/bg/borders
function tableResizeRows(t, range, delta){ t = clone(t); const {r0=0,r1=t.rows-1}=range; for (let r=r0;r<=r1;r++){ t.rowHeights[r] = Math.max(10, (t.rowHeights[r]||40) + delta); } return t; }
function tableResizeCols(t, range, delta){ t = clone(t); const {c0=0,c1=t.cols-1}=range; for (let c=c0;c<=c1;c++){ t.colWidths[c] = Math.max(10, (t.colWidths[c]||100) + delta); } return t; }
function tableDistributeRows(t, range){ t = clone(t); const {r0=0,r1=t.rows-1}=range; const n=r1-r0+1; const sum=t.rowHeights.slice(r0,r1+1).reduce((a,b)=>a+b,0); const avg=Math.round(sum/n); for (let r=r0;r<=r1;r++) t.rowHeights[r]=avg; return t; }
function tableDistributeCols(t, range){ t = clone(t); const {c0=0,c1=t.cols-1}=range; const n=c1-c0+1; const sum=t.colWidths.slice(c0,c1+1).reduce((a,b)=>a+b,0); const avg=Math.round(sum/n); for (let c=c0;c<=c1;c++) t.colWidths[c]=avg; return t; }
function tableApplyCellBg(t, range, color){ t = clone(t); const {r0,c0,r1,c1}=range; for (let r=r0;r<=r1;r++){ for (let c=c0;c<=c1;c++){ const id=t.grid[r][c]; const cell=t.cells[id]; if (cell.hidden) continue; cell.styles.bg = color; } } return t; }
function tableApplyBorders(t, range, mode, color, width){
  t = clone(t); const {r0,c0,r1,c1}=range;
  const inRange = (rr,cc)=> rr>=r0&&rr<=r1&&cc>=c0&&cc<=c1;
  // Initialize borders container
  for (let r=r0;r<=r1;r++){
    for (let c=c0;c<=c1;c++){
      const id=t.grid[r][c]; const cell=t.cells[id]; if (!cell || cell.hidden) continue;
      if (!cell.styles.borders) cell.styles.borders = {top:false,right:false,bottom:false,left:false};
    }
  }
  // Helper to set border on a side and its neighbor to keep seams aligned
  function setEdge(rr, cc, side, on){
    const id=t.grid[rr][cc]; const cell=t.cells[id]; if (!cell || cell.hidden) return;
    cell.styles.borderColor = color; cell.styles.borderWidth = width;
    if (!cell.styles.borders) cell.styles.borders = {top:false,right:false,bottom:false,left:false};
    cell.styles.borders[side] = on;
    // Mirror on neighbor
    let nr=rr, nc=cc, nside=null;
    if (side==='top'){ nr=rr-1; nc=cc; nside='bottom'; }
    if (side==='bottom'){ nr=rr+1; nc=cc; nside='top'; }
    if (side==='left'){ nr=rr; nc=cc-1; nside='right'; }
    if (side==='right'){ nr=rr; nc=cc+1; nside='left'; }
    if (inRange(nr,nc)){
      const nid=t.grid[nr][nc]; const ncell=t.cells[nid]; if (ncell && !ncell.hidden){
        if (!ncell.styles.borders) ncell.styles.borders = {top:false,right:false,bottom:false,left:false};
        ncell.styles.borderColor = color; ncell.styles.borderWidth = width;
        ncell.styles.borders[nside] = on;
      }
    }
  }
  // Clear current in-range borders when mode is not additive
  const clearAll = ()=>{
    for (let r=r0;r<=r1;r++) for (let c=c0;c<=c1;c++){
      const id=t.grid[r][c]; const cell=t.cells[id]; if (!cell || cell.hidden) continue;
      cell.styles.borderColor = color; cell.styles.borderWidth = width;
      cell.styles.borders = {top:false,right:false,bottom:false,left:false};
    }
  };
  if (mode==='none'){ clearAll(); return t; }
  clearAll();
  if (mode==='all'){
    for (let r=r0;r<=r1;r++) for (let c=c0;c<=c1;c++){
      setEdge(r,c,'top',true); setEdge(r,c,'right',true); setEdge(r,c,'bottom',true); setEdge(r,c,'left',true);
    }
  } else if (mode==='outer'){
    for (let r=r0;r<=r1;r++){
      for (let c=c0;c<=c1;c++){
        if (r===r0) setEdge(r,c,'top',true);
        if (r===r1) setEdge(r,c,'bottom',true);
        if (c===c0) setEdge(r,c,'left',true);
        if (c===c1) setEdge(r,c,'right',true);
      }
    }
  } else if (mode==='inner'){
    for (let r=r0;r<=r1;r++){
      for (let c=c0;c<=c1;c++){
        if (r<r1) setEdge(r,c,'bottom',true);
        if (c<c1) setEdge(r,c,'right',true);
      }
    }
  } else if (['top','right','bottom','left'].includes(mode)){
    for (let r=r0;r<=r1;r++) for (let c=c0;c<=c1;c++) setEdge(r,c,mode,true);
  }
  return t;
}

// Apply per-cell text color
function tableApplyTextColor(t, range, color){
  t = clone(t); const {r0,c0,r1,c1}=range;
  for (let r=r0;r<=r1;r++){
    for (let c=c0;c<=c1;c++){
      const id=t.grid[r][c]; const cell=t.cells[id]; if (cell.hidden) continue;
      cell.styles.textColor = color;
    }
  }
  return t;
}

// Apply per-cell alignment (pass undefined to leave as-is)
function tableApplyAlign(t, range, alignH, alignV){
  t = clone(t); const {r0,c0,r1,c1}=range;
  for (let r=r0;r<=r1;r++){
    for (let c=c0;c<=c1;c++){
      const id=t.grid[r][c]; const cell=t.cells[id]; if (cell.hidden) continue;
      if (alignH) cell.styles.alignH = alignH;
      if (alignV) cell.styles.alignV = alignV;
    }
  }
  return t;
}

// Generic per-cell style applier for a table selection
function tableApplyCellStyle(t, range, styleKey, value){
  t = clone(t); const {r0,c0,r1,c1}=range;
  for (let r=r0;r<=r1;r++){
    for (let c=c0;c<=c1;c++){
      const id=t.grid[r][c]; const cell=t.cells[id]; if (cell.hidden) continue;
      cell.styles[styleKey] = value;
      // If user adjusts stroke properties but borders are missing/disabled, enable all sides for visibility
      if ((styleKey === 'strokeColor' || styleKey === 'strokeWidth')){
        const sides = cell.styles.borders;
        const hasAny = sides && (sides.top || sides.right || sides.bottom || sides.left);
        if (!hasAny) cell.styles.borders = { top:true, right:true, bottom:true, left:true };
      }
    }
  }
  return t;
}

function tableAnyCellStyleOff(t, range, styleKey){
  const {r0,c0,r1,c1}=range;
  for (let r=r0;r<=r1;r++){
    for (let c=c0;c<=c1;c++){
      const id=t.grid[r][c]; const cell=t.cells[id]; if (cell.hidden) continue;
      if (!cell.styles[styleKey]) return true;
    }
  }
  return false;
}


  </script>

  <script>
// tables.ops.js
// Explicit export surface for table operations (pure).

const TableOps = {
	addRow: tableAddRow,
	addColumn: tableAddColumn,
	deleteRow: tableDeleteRow,
	deleteColumn: tableDeleteColumn,
	deleteRowsRange: tableDeleteRowsRange,
	deleteColsRange: tableDeleteColsRange,
	mergeRange: tableMergeRange,
	unmerge: tableUnmerge,
	unmergeRange: tableUnmergeRange,
	resizeRows: tableResizeRows,
	resizeCols: tableResizeCols,
	distributeRows: tableDistributeRows,
	distributeCols: tableDistributeCols,
	applyCellBg: tableApplyCellBg,
	applyTextColor: tableApplyTextColor,
	applyAlign: tableApplyAlign,
	applyCellStyle: tableApplyCellStyle,
	anyCellStyleOff: tableAnyCellStyleOff,
};



  </script>

  <script>
// persistence.service.js
// Facade over OPFS, localStorage, File System Access API.

const Persistence = (function(){
	// Debug helper
	function log(...args){ try { console.info('[Persistence]', ...args); } catch {} }
	function getFileScopeId(){
		try {
			const path = (window && window.location && window.location.pathname) ? window.location.pathname : '';
			const key = path.replace(/[^a-z0-9\-_.]/gi, '_').toLowerCase();
			return key || 'index';
		} catch (_) { return 'index'; }
	}
	function supportsOPFS(){ return typeof navigator !== 'undefined' && navigator.storage && navigator.storage.getDirectory; }
	async function opfsGetRoot(){ return await navigator.storage.getDirectory(); }
	async function opfsWriteFile(filename, text){ const root = await opfsGetRoot(); const fh = await root.getFileHandle(filename, { create: true }); const w = await fh.createWritable(); await w.write(text); await w.close(); }
	async function opfsReadTextIfExists(filename){ try { const root = await opfsGetRoot(); const fh = await root.getFileHandle(filename, { create: false }); const file = await fh.getFile(); return await file.text(); } catch (_) { return null; } }
	function localAutosaveKey(){ return `certificateMaker:autosave:v1:${getFileScopeId()}`; }
	function localSave(text){ try { localStorage.setItem(localAutosaveKey(), text); return true; } catch (_) { return false; } }
	function localLoad(){ try { return localStorage.getItem(localAutosaveKey()); } catch (_) { return null; } }
	let currentFileHandle = null;
	function supportsFSA(){ return typeof window !== 'undefined' && 'showSaveFilePicker' in window; }
	async function verifyPermission(fileHandle, withWrite){ const opts = {}; if (withWrite) opts.mode = 'readwrite'; if ((await fileHandle.queryPermission(opts)) === 'granted') return true; if ((await fileHandle.requestPermission(opts)) === 'granted') return true; return false; }
	async function writeHandle(handle, content){ const ok = await verifyPermission(handle, true); if (!ok) throw new Error('Permission denied'); const writable = await handle.createWritable(); await writable.write(content); await writable.close(); }

	// --- Persisting the file handle across reloads (IndexedDB) ---
	async function openDb(){
		return await new Promise((resolve, reject) => {
			try {
				const req = indexedDB.open('cm-persistence', 1);
				req.onupgradeneeded = () => { const db = req.result; if (!db.objectStoreNames.contains('handles')) db.createObjectStore('handles'); };
				req.onsuccess = () => resolve(req.result);
				req.onerror = () => reject(req.error);
			} catch (e) { reject(e); }
		});
	}
	async function storeHandle(handle){
		try { const db = await openDb(); await new Promise((res, rej) => { const tx = db.transaction('handles', 'readwrite'); tx.oncomplete = () => res(); tx.onerror = () => rej(tx.error); tx.objectStore('handles').put(handle, 'current'); }); log('Stored file handle'); return true; } catch (e) { log('Failed to store handle', e); return false; }
	}
	async function loadHandle(){
		try { const db = await openDb(); return await new Promise((res, rej) => { const tx = db.transaction('handles','readonly'); tx.onerror = () => rej(tx.error); const req = tx.objectStore('handles').get('current'); req.onsuccess = () => res(req.result || null); req.onerror = () => rej(req.error); }); } catch (e) { log('Failed to load handle', e); return null; }
	}
	async function restoreHandle(){
		if (!supportsFSA()) { log('FSA not supported; cannot restore handle'); return false; }
		try {
			const h = await loadHandle();
			if (h){
				try { await h.queryPermission?.({ mode: 'readwrite' }); } catch {}
				currentFileHandle = h; log('Restored file handle'); return true;
			}
		} catch (e) { log('Restore handle failed', e); }
		return false;
	}

	async function saveDocument(opts){
		const options = opts || {};
		log('saveDocument called', { silent: !!options.silent, isSecureContext: (typeof window!== 'undefined' && window.isSecureContext), supportsFSA: supportsFSA(), hasHandle: !!currentFileHandle, supportsOPFS: supportsOPFS() });
		// If we already have permission to a file handle, write silently.
		if (supportsFSA() && currentFileHandle){
			try { const html = buildSaveHtml(); await writeHandle(currentFileHandle, html); log('Saved via FSA'); return { ok:true, via:'fsa' }; } catch(e){ log('FSA save failed', e); }
		}
		// Silent background save path: try OPFS first, then localStorage as a last resort
		if (options.silent){
			try {
				const html = buildSaveHtml();
				if (supportsOPFS()) { await opfsWriteFile(`${getFileScopeId()}-autosave.html`, html); log('Saved via OPFS'); return { ok:true, via:'opfs' }; }
				// Fall back to localStorage snapshot
				localSave(html); log('Saved via localStorage');
				return { ok:true, via:'local' };
			} catch (e) { log('Silent save failed', e); }
		}
		// If not silent, fall back to a regular download of the HTML (prompts user)
		if (!options.silent){
			const currentFilename = (function(){ const path = window.location.pathname; const filename = path.split('/').pop(); if (filename && filename.toLowerCase().endsWith('.html')) return filename; return null; })();
			if (currentFilename){ const html = buildSaveHtml(); download(currentFilename, html, 'text/html'); log('Saved via download to', currentFilename); return { ok:true, via:'download' }; }
		}
		console.warn('[Persistence] Save failed');
		return { ok:false };
	}

	async function saveDocumentAs(){
		if (supportsFSA()){
			try {
				const defaultName = `certificate-maker-${new Date().toISOString().slice(0,19).replace(/[:.]/g,'-')}.html`;
				const handle =  await window.showSaveFilePicker({ suggestedName: defaultName, types:[{ description:'HTML', accept:{ 'text/html': ['.html','.htm'] } }] });
				currentFileHandle = handle;		
				
				console.log('Save As to handle', handle);

				const html = buildSaveHtml();
				await writeHandle(currentFileHandle, html);
				try { await storeHandle(handle); } catch {}
				log('Save As via FSA');
				return { ok:true, via:'fsa' };
			} catch(_){}
		}
		const defaultName = `certificate-maker-${new Date().toISOString().slice(0,19).replace(/[:.]/g,'-')}.html`;
		const html = buildSaveHtml();
		download(defaultName, html, 'text/html'); log('Save As via download', defaultName);
		return { ok:true, via:'download' };
	}

	async function tryAutoLoad(){
		// Only load if the document is embedded in the current HTML file.
		const saved = document.getElementById('__doc__');
		if (saved && saved.textContent) {
			try { deserializeDocument(saved.textContent.replaceAll('&lt;','<')); return { ok:true, via:'embedded' }; } catch {}
		}
		return { ok:false };
	}

	return { saveDocument, saveDocumentAs, tryAutoLoad, restoreHandle };
})();



  </script>

  <script>
// export.service.js
// Facade for PDF export with preflight.

const ExportService = (function(){
	async function loadExternalScript(src){
		return new Promise((resolve, reject) => {
			let existing = document.querySelector(`script[data-dynamic-src="${src}"]`);
			if (existing){ if (existing.dataset.loaded === 'true') return resolve(); existing.addEventListener('load', () => resolve()); existing.addEventListener('error', () => reject(new Error('Failed to load: '+src))); return; }
			const s = document.createElement('script'); s.src = src; s.async = true; s.crossOrigin = 'anonymous'; s.referrerPolicy = 'no-referrer'; s.dataset.dynamicSrc = src; s.addEventListener('load', () => { s.dataset.loaded = 'true'; resolve(); }); s.addEventListener('error', () => reject(new Error('Failed to load: '+src))); document.head.appendChild(s);
		});
	}
	async function ensureHtml2Canvas(){ if (typeof window.html2canvas === 'function') return window.html2canvas; await loadExternalScript('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js'); if (typeof window.html2canvas === 'function') return window.html2canvas; throw new Error('html2canvas is not available'); }
	async function ensureJsPDF(){ if (window.jspdf && typeof window.jspdf.jsPDF === 'function') return window.jspdf.jsPDF; if (typeof window.jsPDF === 'function') return window.jsPDF; await loadExternalScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js'); if (window.jspdf && typeof window.jspdf.jsPDF === 'function') return window.jspdf.jsPDF; if (typeof window.jsPDF === 'function') return window.jsPDF; throw new Error('jsPDF is not available'); }

	async function exportDocumentToPdf({ filename = 'myfile.pdf', dpi = 220, orientation = 'portrait' } = {}){
		const pages = Array.from(document.querySelectorAll('.page')); if (!pages.length) return;
		// Preflight
		try { if (document.fonts && document.fonts.ready) { await document.fonts.ready; } } catch {}
		const originalZoom = typeof getZoom === 'function' ? getZoom() : 1; if (typeof setZoomScale === 'function') setZoomScale(1);
		const html2canvasFn = await ensureHtml2Canvas();
		const jsPDF = await ensureJsPDF();
		const scale = Math.max(1, Math.round(dpi / 96));
		const canvasScrollX = -window.scrollX || -7;
		const canvasScrollY = -window.scrollY || 0;
		const firstPage = pages[0]; const widthPx = firstPage.offsetWidth; const heightPx = firstPage.offsetHeight;
		const pdf = new jsPDF({ unit:'px', format:[widthPx, heightPx], orientation, compress:true });
		for (let i=0;i<pages.length;i++){
			const page = pages[i];
			const prevShadow = page.style.boxShadow; const prevRadius = page.style.borderRadius; page.style.boxShadow = 'none'; page.style.borderRadius = '0';
			// Hide editor-only guides (including header/footer bands) while capturing
			const guides = Array.from(page.querySelectorAll('.guide, .hf-guide'));
			const prevGuideDisplay = guides.map(n => n.style.display);
			guides.forEach(n => n.style.display = 'none');
			const canvas = await html2canvasFn(page, { scale, useCORS:true, backgroundColor:'#ffffff', scrollX: canvasScrollX, scrollY: canvasScrollY });
			// Restore styles
			page.style.boxShadow = prevShadow; page.style.borderRadius = prevRadius;
			guides.forEach((n, idx) => { n.style.display = prevGuideDisplay[idx]; });
			const imgData = canvas.toDataURL('image/jpeg', 0.75);
			if (i>0) pdf.addPage([widthPx, heightPx], orientation);
			pdf.addImage(imgData, 'JPEG', 0, 0, widthPx, heightPx);
		}
		pdf.save(filename);
		if (typeof setZoomScale === 'function') setZoomScale(originalZoom);
	}

	// Export only the current page as an image (PNG/JPEG)
	async function exportCurrentPageToImage({ filename, format = 'png', quality = 0.9 } = {}){
		const page = (typeof getPageNode === 'function') ? getPageNode() : document.querySelector('.page');
		if (!page) return;
		const html2canvasFn = await ensureHtml2Canvas();
		// Temporarily remove page shadows/radius to avoid artifacts in capture
		const prevShadow = page.style.boxShadow; const prevRadius = page.style.borderRadius; page.style.boxShadow = 'none'; page.style.borderRadius = '0';
		const canvas = await html2canvasFn(page, { scale: Math.max(1, Math.round( (typeof getZoom === 'function' ? 96*getZoom() : 96) / 96 )), useCORS:true, backgroundColor:'#ffffff' });
		page.style.boxShadow = prevShadow; page.style.borderRadius = prevRadius;
		const mime = (String(format).toLowerCase() === 'jpg' || String(format).toLowerCase() === 'jpeg') ? 'image/jpeg' : 'image/png';
		const dataUrl = canvas.toDataURL(mime, quality);
		const name = filename || `page-${new Date().toISOString().replace(/[:.]/g,'-')}.${mime === 'image/png' ? 'png' : 'jpg'}`;
		// Trigger download
		const a = document.createElement('a'); a.href = dataUrl; a.download = name; document.body.appendChild(a); a.click(); a.remove();
		return dataUrl;
	}

	return { exportDocumentToPdf, exportCurrentPageToImage };
})();



  </script>

  <script>
// The users can use this file to add their own functions to the app.

// Functions register themselves to window.USER_FUNCTIONS (see below)
// Provide a global reader used by the Properties panel to populate the dropdown
function getUserFunctionChoices(){
    try {
        const list = Array.isArray(window.USER_FUNCTIONS) ? window.USER_FUNCTIONS : [];
        return list
            .filter(x => x && typeof x.name === 'string')
            .map(x => ({
                name: x.name,
                label: x.label || x.name,
                inputs: Number.isFinite(x.inputs) ? x.inputs : (typeof window[x.name] === 'function' ? window[x.name].length : 0),
                // optional array of placeholder strings for inputs
                placeholders: Array.isArray(x.placeholders) ? x.placeholders : []
            }));
    } catch { return []; }
}

// Register functions for the Properties panel dropdown
;(function(){
    try {
        if (!Array.isArray(window.USER_FUNCTIONS)) window.USER_FUNCTIONS = [];
        const ensure = (meta) => {
            if (!window.USER_FUNCTIONS.some(f => f && f.name === meta.name)) {
                window.USER_FUNCTIONS.push(meta);
            }
        };
        ensure({ name:'simpleConsoleLogFunction', label:'Console log', inputs:1, placeholders:["message to log"], triggers:['click','change','input','dblclick','focus','blur'] });
        ensure({ name:'coloringFunction', label:'coloringFunction', inputs:2, placeholders:["selected element (css selector)", "style string e.g. background:#ff0000; color:#fff;"], triggers:['click','change','input','dblclick','focus','blur'] });
        ensure({ name:'toggleVisibility', label:'Toggle visibility', inputs:1, placeholders:["target element (css selector)"], triggers:['click','change','input','dblclick','focus','blur'] });
        ensure({ name:'setVisibility', label:'Set visibility', inputs:2, placeholders:["target element (css selector)", "visible (true/false)"], triggers:['click','change','input','dblclick','focus','blur'] });
        ensure({
            name:'conditionalFormatByOffset',
            label:'Conditional Format (offsets)',
            inputs:4,
            placeholders:[
                'min col offset (e.g., -2)',
                'max col offset (e.g., -1)',
                'OK style CSS (e.g., background:#9ccc65;color:#000)',
                'NOK style CSS (e.g., background:#ff6b6b;color:#fff)'
            ],
            triggers:['click','change','input','dblclick','focus','blur']
        });
    } catch {}
})();

function normalizeColorToHex(val){
    if (val == null) return val;
    const str = String(val).trim();
    // #RRGGBB
    let m = str.match(/^#([0-9a-fA-F]{6})$/);
    if (m) return '#' + m[1].toLowerCase();
    // #RGB -> #RRGGBB
    m = str.match(/^#([0-9a-fA-F]{3})$/);
    if (m) return '#' + m[1].split('').map(x => x + x).join('').toLowerCase();
    // #RRGGBBAA -> drop alpha
    m = str.match(/^#([0-9a-fA-F]{8})$/);
    if (m) return '#' + m[1].slice(0,6).toLowerCase();
    // rgb/rgba
    m = str.match(/^rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})(?:\s*,\s*([\d.]+))?\s*\)$/i);
    if (m){
        const r = Math.max(0, Math.min(255, parseInt(m[1], 10))).toString(16).padStart(2,'0');
        const g = Math.max(0, Math.min(255, parseInt(m[2], 10))).toString(16).padStart(2,'0');
        const b = Math.max(0, Math.min(255, parseInt(m[3], 10))).toString(16).padStart(2,'0');
        return `#${r}${g}${b}`;
    }
    // Try browser normalization for named colors etc.
    try {
        const ctx = document.createElement('canvas').getContext('2d');
        ctx.fillStyle = str; // throws for invalid
        const out = ctx.fillStyle; // often '#rrggbb' or 'rgba(...)'
        if (/^#/.test(out)) return normalizeColorToHex(out);
        const rgbm = out.match(/^rgba?\((.*)\)$/i);
        if (rgbm) return normalizeColorToHex(out);
    } catch {}
    return str; // fall back
}

function styleToModelPatch(styleObj, model, opts){
    const patch = { styles: {} };
    const s = patch.styles;
    const get = (k) => styleObj[k] ?? styleObj[k.replace(/[A-Z]/g, m => '-' + m.toLowerCase())];

    const bg = get('background') ?? get('backgroundColor');
    if (bg != null) s.fill = normalizeColorToHex(bg);

    const txt = get('color') ?? get('textColor');
    if (txt != null) s.textColor = normalizeColorToHex(txt);

    const br = get('border');
    if (br){
        const str = String(br).trim();
        const wM = str.match(/(\d+(?:\.\d+)?)px/);
        if (wM) s.strokeWidth = Number(wM[1]) || 1;
        const cM = str.match(/(#[0-9a-fA-F]{3,8}|rgba?\([^\)]+\)|hsla?\([^\)]+\)|[a-zA-Z]+)\s*$/);
        if (cM) {
            const col = cM[1];
            const hex = normalizeColorToHex(col);
            if (/^#([0-9a-fA-F]{6})$/.test(hex)) s.strokeColor = hex;
        }
    }
    const brW = get('borderWidth'); if (brW != null) s.strokeWidth = Number(String(brW).replace('px','')) || 0;
    const brC = get('borderColor'); if (brC != null) {
        const hex = normalizeColorToHex(brC);
        if (/^#([0-9a-fA-F]{6})$/.test(hex)) s.strokeColor = hex;
    }

    const rad = get('borderRadius') ?? get('radius');
    if (rad != null) s.radius = Number(String(rad).replace('px','')) || 0;

    // Typography
    const ff = get('fontFamily'); if (ff != null) s.fontFamily = String(ff);
    const fzRaw = get('fontSize');
    if (fzRaw != null){
        const raw = String(fzRaw).trim();
        const num = parseFloat(raw);
        if (!isNaN(num)){
            if (/px$/i.test(raw)) s.fontSize = Math.round((num * 72) / 96); // px -> pt
            else s.fontSize = Math.round(num); // assume pt or unitless means pt
        }
    }
    const fw = get('fontWeight');
    if (fw != null){
        const w = String(fw).toLowerCase();
        const wNum = parseInt(w, 10);
        s.bold = w === 'bold' || (!isNaN(wNum) && wNum >= 600) ? true : (w === 'normal' ? false : s.bold);
    }
    const fst = get('fontStyle');
    if (fst != null){
        const v = String(fst).toLowerCase();
        if (v === 'italic' || v === 'normal') s.italic = (v === 'italic');
    }
    const tdec = get('textDecoration') ?? get('textDecorationLine');
    if (tdec != null){
        const v = String(tdec).toLowerCase();
        if (v.includes('underline')) s.underline = true;
        if (v === 'none') s.underline = false;
    }

    // Alignment
    const ta = get('textAlign');
    if (ta != null){
        const v = String(ta).toLowerCase();
        if (v === 'left' || v === 'center' || v === 'right') s.textAlignH = v;
    }
    const ai = get('alignItems');
    if (ai != null){
        const v = String(ai).toLowerCase();
        if (v === 'flex-start') s.textAlignH = s.textAlignH || 'left';
        if (v === 'center') s.textAlignH = s.textAlignH || 'center';
        if (v === 'flex-end') s.textAlignH = s.textAlignH || 'right';
    }
    const jc = get('justifyContent');
    if (jc != null){
        const v = String(jc).toLowerCase();
        if (v === 'flex-start') s.textAlignV = 'top';
        if (v === 'center') s.textAlignV = 'middle';
        if (v === 'flex-end') s.textAlignV = 'bottom';
    }

    // Rotation
    const rot = get('rotate');
    if (rot != null){
        const m = String(rot).match(/-?\d+(?:\.\d+)?/);
        if (m) s.rotate = Number(m[0]);
    }
    const tf = get('transform');
    if (tf != null){
        const m = String(tf).match(/rotate\((-?\d+(?:\.\d+)?)deg\)/i);
        if (m) s.rotate = Number(m[1]);
    }

    // If nothing mapped, return null so we don't commit empty patches
    if (Object.keys(s).length === 0) return null;

    // Optional: emit table-ready keys instead of generic element keys
    if (opts && opts.target === 'table'){
        const tableStyles = modelPatchToCellStyle(s);
        if (!tableStyles || Object.keys(tableStyles).length === 0) return null;
        return { styles: tableStyles };
    }
    return patch;
}

function parseStyleString(styleString){
    const out = {};
    if (!styleString) return out;
    const src = String(styleString);
    // Split on ';' or ',' but only when outside parentheses (e.g., rgb(...))
    const parts = [];
    let buf = '';
    let depth = 0; // parentheses depth
    for (let i = 0; i < src.length; i++){
        const ch = src[i];
        if (ch === '(') { depth++; buf += ch; continue; }
        if (ch === ')') { depth = Math.max(0, depth-1); buf += ch; continue; }
        if ((ch === ';' || ch === ',') && depth === 0){
            const seg = buf.trim(); if (seg) parts.push(seg); buf='';
            continue;
        }
        buf += ch;
    }
    if (buf.trim()) parts.push(buf.trim());
    parts.forEach(part => {
        const idx = part.indexOf(':');
        const k = (idx >= 0 ? part.slice(0, idx) : '').trim();
        const v = (idx >= 0 ? part.slice(idx+1) : '').trim();
        if (!k || !v) return;
        out[k] = v;
    });
    return out;
}


//border-top-left-radius:25px; border-top-right-radius:25px; border-bottom-right-radius:25px; border-bottom-left-radius:25px; background-image:initial; background-position-x:initial; background-position-y:initial; background-size:initial; background-repeat:initial; background-attachment:initial; background-origin:initial; background-clip:initial; background-color:rgb(28, 210, 4); border-top-width:9px; border-right-width:9px; border-bottom-width:9px; border-left-width:9px; border-top-style:solid; border-right-style:solid; border-bottom-style:solid; border-left-style:solid; border-top-color:rgb(17, 24, 39); border-right-color:rgb(17, 24, 39); border-bottom-color:rgb(17, 24, 39); border-left-color:rgb(17, 24, 39); border-image-source:initial; border-image-slice:initial; border-image-width:initial; border-image-outset:initial; border-image-repeat:initial; color:rgb(17, 24, 39); font-family:system-ui; font-size:14pt; font-weight:400; font-style:normal; text-decoration-line:none; text-decoration-thickness:initial; text-decoration-style:initial; text-decoration-color:initial; transform-origin:50% 50%; display:flex; flex-direction:column; align-items:flex-start; justify-content:flex-start; text-align:left


//your function in here!!


// --- Visibility helpers (simple, reusable) ---
function __resolveTargetIds(targetSelector){
    const ids = [];
    try {
        if (typeof targetSelector === 'string' && targetSelector.trim()){
            const sel = String(targetSelector).trim().replace(/^['"]|['"]$/g, '');
            // Search across the entire document so selectors work on any page
            let nodes = [];
            try { nodes = Array.from(document.querySelectorAll(sel)); } catch {}
            if (!nodes.length && sel.startsWith('#')){
                const token = sel.slice(1);
                const byData = Array.from(document.querySelectorAll(`.page [data-id="${token}"]`));
                if (byData.length) nodes.push(...byData);
            }
            nodes.forEach(n => { const el = n.closest?.('.element[data-id]') || n; const id = el?.getAttribute?.('data-id'); if (id) ids.push(id); });
        } else if (this && this.nodeType === 1){
            const el = this.closest?.('.element[data-id]') || this;
            const id = el?.getAttribute?.('data-id'); if (id) ids.push(id);
        } else {
            document.querySelectorAll('.page .element.selected').forEach(n => { const id = n.getAttribute('data-id'); if (id) ids.push(id); });
        }
    } catch {}
    return [...new Set(ids)];
}

function setVisibility(targetSelector, visible){
    try {
        if (!Model || !Model.document || typeof updateElement !== 'function') return;
        const ids = __resolveTargetIds.call(this, targetSelector);
        if (!ids.length) { console.warn('setVisibility: no targets'); return; }
        const nextHidden = !Boolean(visible);
        // Use CSS selector targeting so updates re-render all pages
        ids.forEach(id => updateElement(`[data-id="${id}"]`, { attrs: { hidden: nextHidden } }));
        try { if (typeof window.reflowStacks === 'function') window.reflowStacks(getCurrentPage()); } catch {}
        try { if (typeof renderPage === 'function') renderPage(getCurrentPage()); } catch {}
    } catch(err){ console.warn('setVisibility failed', err); }
}

function toggleVisibility(targetSelector){
    try {
        if (!Model || !Model.document || typeof updateElement !== 'function') return;
        const ids = __resolveTargetIds.call(this, targetSelector);
        if (!ids.length) { console.warn('toggleVisibility: no targets'); return; }
        ids.forEach(id => {
            // Find model on any page so we can invert reliably
            let m = null;
            try {
                const pages = (Model && Model.document && Model.document.pages) || [];
                for (let i = 0; i < pages.length && !m; i++){
                    const arr = (pages[i] && pages[i].elements) || [];
                    m = arr.find(e => e && e.id === id) || null;
                }
            } catch {}
            if (!m) return;
            let hidden = false;
            try { hidden = typeof isElementHidden === 'function' ? !!isElementHidden(m) : !!(m.attrs && (m.attrs.hidden === true || m.attrs.hidden === 'true')); } catch {}
            // Apply via selector so cross-page updates trigger renderAll()
            updateElement(`[data-id="${id}"]`, { attrs: { hidden: !hidden } });
        });
        try { if (typeof window.reflowStacks === 'function') window.reflowStacks(getCurrentPage()); } catch {}
        try { if (typeof renderPage === 'function') renderPage(getCurrentPage()); } catch {}
    } catch(err){ console.warn('toggleVisibility failed', err); }
}

// Ensure global for inline onclick
try {
    window.toggleVisibility = toggleVisibility;
    window.setVisibility = setVisibility;
    window.simpleConsoleLogFunction = simpleConsoleLogFunction;
    window.coloringFunction = coloringFunction;
    window.conditionalFormatByOffset = conditionalFormatByOffset;
} catch {}


function simpleConsoleLogFunction(message){
    try {
        if (typeof Model === 'undefined' || !Model.document) return;
        // Allow preview execution in edit mode when override flag set
        if (Model.document.editMode && !window.__ALLOW_USER_FUNCTIONS_IN_EDIT) return;
        console.log(message);
    } catch {}
}

function coloringFunction(targetSelector, styleString){
    try {
        if (typeof Model === 'undefined' || !Model.document) return;
        if (Model.document.editMode && !window.__ALLOW_USER_FUNCTIONS_IN_EDIT) return;
        // Normalize inputs (strip wrapping quotes if any)
        const normalizeArg = (v) => String(v == null ? '' : v).trim().replace(/^['"]|['"]$/g, '');
        const sel = normalizeArg(targetSelector);

        // Resolve styles: accept string (CSS style fragment) or object
        const rawStyle = (styleString && typeof styleString === 'object') ? styleString : parseStyleString(normalizeArg(styleString));
        // Drop outline-related props (picker-only visual aid)
        const style = Object.keys(rawStyle || {}).reduce((acc, key) => {
            const normKey = String(key).replace(/[A-Z]/g, m => '-' + m.toLowerCase()).toLowerCase();
            if (normKey === 'outline' || normKey.startsWith('outline-')) return acc;
            acc[key] = rawStyle[key];
            return acc;
        }, {});

        // Convert style object to editor model patch
        const patch = styleToModelPatch(style, null);
        if (!patch) return; // nothing to apply

        if (typeof updateElement !== 'function') return;

        // Decide how to target: selector string, triggering element id, or current selection
        if (sel) {
            updateElement(sel, patch);
        } else {
            const el = (this && this.nodeType === 1) ? this : null;
            const id = el?.dataset?.id;
            if (id) updateElement(id, patch);
            else updateElement(null, patch);
        }
    }
    catch(err){ console.warn('coloringFunction failed', err); }
}





//onclick="coloringFunction('#el-2', 'background:red;')"
//onclick="coloringFunction('[data-id="el-2"]', 'background:red;')"


// Map generic element patch.styles to table cell style keys
function modelPatchToCellStyle(patchStyles){
    if (!patchStyles) return null;
    const s = patchStyles; const out = {};
    if (s.fill) out.bg = s.fill;
    if (s.textColor) out.textColor = s.textColor;
    if (Object.prototype.hasOwnProperty.call(s, 'strokeWidth')) out.borderWidth = s.strokeWidth;
    if (s.strokeColor) out.borderColor = s.strokeColor;
    if (s.fontFamily) out.fontFamily = s.fontFamily;
    if (s.fontSize) out.fontSize = s.fontSize;
    if (Object.prototype.hasOwnProperty.call(s, 'bold')) out.bold = !!s.bold;
    if (Object.prototype.hasOwnProperty.call(s, 'italic')) out.italic = !!s.italic;
    if (Object.prototype.hasOwnProperty.call(s, 'underline')) out.underline = !!s.underline;
    if (s.textAlignH) out.alignH = s.textAlignH;
    if (s.textAlignV) out.alignV = s.textAlignV;
    return out;
}

// Conditional formatting using relative column offsets within the same row
function conditionalFormatByOffset(minColOffset, maxColOffset, styleIfOk, styleIfNok){
    try {
        if (typeof Model === 'undefined' || !Model.document) return;
        if (Model.document.editMode && !window.__ALLOW_USER_FUNCTIONS_IN_EDIT) return;
        const normalizeArg = (v) => String(v == null ? '' : v).trim().replace(/^['"]|['"]$/g, '');
        const offMin = parseInt(minColOffset, 10); const offMax = parseInt(maxColOffset, 10);
        const dMin = Number.isFinite(offMin) ? offMin : 0;
        const dMax = Number.isFinite(offMax) ? offMax : 0;

        // Resolve context cell (prefer DOM "this" from inline handler; fallback to active table anchor)
        let tableId = null, r = null, c = null;
        if (this && this.nodeType === 1 && this.classList && this.classList.contains('table-cell')){
            tableId = this.dataset.tableId; r = Number(this.dataset.r); c = Number(this.dataset.c);
        } else if (typeof getActiveTableAnchor === 'function'){
            const a = getActiveTableAnchor(); if (a){ tableId = a.tableId; r = a.r; c = a.c; }
        }
        if (!tableId) return;

        const t = getElementById(tableId); if (!t) return;
        if (typeof mapToAnchorCoords === 'function'){ const mapped = mapToAnchorCoords(t, r, c); r = mapped.r; c = mapped.c; }

        const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));
        const cMin = clamp(c + dMin, 0, t.cols - 1);
        const cMax = clamp(c + dMax, 0, t.cols - 1);
        const idMin = t.grid[r]?.[cMin];
        const idMax = t.grid[r]?.[cMax];
        const idSelf = t.grid[r]?.[c];
        if (idMin == null || idMax == null || idSelf == null) return;

        const num = (v) => {
            const raw = String(v ?? '').trim();
            // Keep numbers like "1,234.56" by dropping non-numeric except . - +
            const cleaned = raw.replace(/[^0-9+\-.]/g, '');
            const n = parseFloat(cleaned);
            return Number.isFinite(n) ? n : null;
        };
        const vMin = num(t.cells[idMin]?.content);
        const vMax = num(t.cells[idMax]?.content);
        const vSelf = num(t.cells[idSelf]?.content);
        if (vMin == null || vMax == null || vSelf == null) return;

        const lo = Math.min(vMin, vMax);
        const hi = Math.max(vMin, vMax);
        const isOk = vSelf >= lo && vSelf <= hi;

        // Resolve styles
        const rawOk = styleIfOk && typeof styleIfOk === 'object' ? styleIfOk : parseStyleString(normalizeArg(styleIfOk));
        const rawNok = styleIfNok && typeof styleIfNok === 'object' ? styleIfNok : parseStyleString(normalizeArg(styleIfNok));
        const okPatch = styleToModelPatch(rawOk || {}, null, { target: 'table' });
        const nokPatch = styleToModelPatch(rawNok || {}, null, { target: 'table' });
        const okCell = okPatch ? okPatch.styles : null;
        const nokCell = nokPatch ? nokPatch.styles : null;
        const nextStyle = isOk ? okCell : nokCell;
        if (!nextStyle) return;

        // Apply to the single cell
        const next = JSON.parse(JSON.stringify(t));
        const tgt = next.cells[idSelf];
        tgt.styles = { ...(tgt.styles || {}), ...nextStyle };
        updateElement(next.id, next);
    } catch(err){ console.warn('conditionalFormatByOffset failed', err); }
}

// Example usage on a table cell (inline attribute):
// onclick="conditionalFormatByOffset(-2, -1, 'background:#9ccc65;color:#000', 'background:#ff6b6b;color:#fff')"


  </script>

  <script>
// app.view.render.js
// View-only render helpers extracted from editor.app.js (idempotent DOM updates only)

function getPageNode(id = Model.document.currentPageId) {
	return document.querySelector(`.page-wrapper[data-page-id="${id}"] .page`);
}

function ensureElementNode(elModel) {
	const pageNode = getPageNode(elModel.pageId || Model.document.currentPageId);
	let node = pageNode.querySelector(`[data-id="${elModel.id}"]`);
	if (!node) {
		node = document.createElement('div');
		node.className = `element ${elModel.type}`;
		node.dataset.id = elModel.id;
		pageNode.appendChild(node);
		// Keep resize cursor behavior; suppress in view mode (no state mutations)
		node.addEventListener('mousemove', (e) => { if (!Model || !Model.document || !Model.document.editMode){ node.style.cursor = ''; return; } updateResizeCursor(e, node); });
		node.addEventListener('mouseleave', () => { node.style.cursor = ''; });
	}
	return node;
}

function applyElementStyles(node, m, pageForParentLookup) {
	let relX = m.x, relY = m.y;
	if (m.parentId){
		let parent = null;
		try {
			if (pageForParentLookup && Array.isArray(pageForParentLookup.elements)){
				parent = pageForParentLookup.elements.find(e => e && e.id === m.parentId) || null;
			} else {
				parent = getElementById(m.parentId);
			}
		} catch {}
		if (parent){ relX = (m.x - parent.x); relY = (m.y - parent.y); }
	}
	node.style.left = relX + 'px';
	node.style.top = relY + 'px';
	// Apply raw attributes first so subsequent style assignments can override
	// any generic cssText coming from attrs.style (avoids wiping width/height)
	const attrs = m.attrs || {};
	Object.keys(attrs).forEach((name) => {
		const val = attrs[name];
		// In edit mode, suppress inline event attributes (onclick, oninput, ...)
		// unless the element explicitly opts in (role="button" or data-run-actions-in-edit="true").
		if (/^on[a-z]/i.test(String(name))) {
			if (Model && Model.document && Model.document.editMode) {
				const role = String(attrs.role || '').toLowerCase();
				const runInEdit = String(attrs['data-run-actions-in-edit'] || '').toLowerCase();
				const allow = (role === 'button') || (runInEdit === 'true');
				if (!allow) { node.removeAttribute(name); return; }
			}
		}
		if (val === false || val == null || val === '') node.removeAttribute(name);
		else if (val === true) node.setAttribute(name, '');
		else node.setAttribute(name, String(val));
	});

	// Determine hidden status from attrs once and apply at the end to win the cascade
	let isHidden = false;
	try {
		if (attrs && (attrs.hidden === true || attrs.hidden === 'true')) isHidden = true;
		const st = String(attrs && attrs.style ? attrs.style : '');
		if (/display\s*:\s*none/i.test(st)) isHidden = true;
	} catch {}
	if (m.type !== 'line') {
		if (m.type === 'table'){
			const minW = (m.colWidths || []).reduce((a,b)=>a+b, 0) || 0;
			const minH = (m.rowHeights || []).reduce((a,b)=>a+b, 0) || 0;
			m.w = Math.max(m.w || 0, minW);
			m.h = Math.max(m.h || 0, minH);
		}
		node.style.width = (m.w || 0) + 'px';
		node.style.height = (m.h || 0) + 'px';
		node.style.borderRadius = (m.styles.radius || 0) + 'px';
		if (m.type !== 'image') {
			node.style.background = m.styles.fill || 'transparent';
		}
		node.style.border = `${m.styles.strokeWidth || 0}px solid ${m.styles.strokeColor || 'transparent'}`;
		node.style.color = m.styles.textColor || '#111827';
		node.style.fontFamily = m.styles.fontFamily || 'system-ui';
		node.style.fontSize = (m.styles.fontSize || 14) + 'pt';
		node.style.fontWeight = m.styles.bold ? '700' : '400';
		node.style.fontStyle = m.styles.italic ? 'italic' : 'normal';
		node.style.textDecoration = m.styles.underline ? 'underline' : 'none';
		const rot = Number(m.styles.rotate || 0);
		node.style.transformOrigin = '50% 50%';
		node.style.transform = rot ? `rotate(${rot}deg)` : '';
		if (m.type === 'text' || m.type === 'field' || m.type === 'rect'){
			// Defer display assignment until after we evaluated hidden
			node.style.flexDirection = 'column';
			node.style.justifyContent = (m.styles.textAlignV || 'top') === 'top' ? 'flex-start' : ((m.styles.textAlignV || 'top') === 'middle' ? 'center' : 'flex-end');
			node.style.alignItems = (m.styles.textAlignH || 'left') === 'left' ? 'flex-start' : ((m.styles.textAlignH || 'left') === 'center' ? 'center' : 'flex-end');
			node.style.textAlign = m.styles.textAlignH || 'left';
		}
	}
	if (m.type === 'line'){
		const dx = (m.x2 ?? m.x) - m.x;
		const dy = (m.y2 ?? m.y) - m.y;
		const length = Math.sqrt(dx*dx + dy*dy);
		node.style.width = `${length}px`;
		node.style.height = '0px';
		node.style.borderTop = `${m.styles.strokeWidth || 1}px solid ${m.styles.strokeColor || '#111827'}`;
		const angle = Math.atan2(dy, dx) * 180 / Math.PI;
		node.style.transformOrigin = '0 0';
		node.style.transform = `rotate(${angle}deg)`;
	}
	if (typeof m.z === 'number') node.style.zIndex = String(100 + (m.z||0));

	// Finally, enforce visibility
	// Respect model hidden state in both modes; mode only gates inline handlers
	if (isHidden) {
		node.style.display = 'none';
	} else {
		if (m.type === 'text' || m.type === 'field' || m.type === 'rect') node.style.display = 'flex';
		else node.style.display = '';
	}

	// Free move: no special visual treatment now; ensure classes removed
	try { node.classList.remove('free-move'); node.classList.remove('outside-page'); } catch {}

	// If element repeats in header/footer, make it non-interactive and pinned band-wise
	try {
		if (m.repeatInHeader || m.repeatInFooter) {
			node.classList.add('repeated');
			// Width/height already applied; leave top adjusted in renderPage for current page
		}
	} catch {}
}

// Toggle only inline event attributes according to edit mode without re-rendering everything
function applyEventAttributesForMode(page = getCurrentPage()){
    try {
        if (!page) return;
        const allowInEdit = (attrs) => {
            const role = String((attrs && attrs.role) || '').toLowerCase();
            const runInEdit = String((attrs && attrs['data-run-actions-in-edit']) || '').toLowerCase();
            return (role === 'button') || (runInEdit === 'true');
        };
        const pageNode = getPageNode(page.id);
        if (!pageNode) return;
        (page.elements || []).forEach((elm) => {
            try {
                // Element-level inline handlers
                const node = pageNode.querySelector(`.element[data-id="${elm.id}"]`);
                const attrs = (elm && elm.attrs) ? elm.attrs : {};
                if (node && attrs){
                    Object.keys(attrs).forEach((name) => {
                        if (!/^on[a-z]/i.test(String(name))) return;
                        if (Model && Model.document && Model.document.editMode){
                            if (!allowInEdit(attrs)) node.removeAttribute(name);
                            else if (attrs[name] === false || attrs[name] == null || attrs[name] === '') node.removeAttribute(name);
                            else node.setAttribute(name, String(attrs[name]));
                        } else {
                            if (attrs[name] === false || attrs[name] == null || attrs[name] === '') node.removeAttribute(name);
                            else node.setAttribute(name, String(attrs[name]));
                        }
                    });
                }
                // Table cell-level inline handlers
                if (elm && elm.type === 'table' && elm.cells){
                    Object.keys(elm.cells).forEach((cid) => {
                        try {
                            const cell = elm.cells[cid];
                            const cattrs = (cell && cell.attrs) ? cell.attrs : {};
                            if (!cattrs) return;
                            const div = pageNode.querySelector(`.table-cell[data-id="${cid}"]`);
                            if (!div) return;
                            Object.keys(cattrs).forEach((name) => {
                                if (!/^on[a-z]/i.test(String(name))) return;
                                if (Model && Model.document && Model.document.editMode){
                                    if (!allowInEdit(cattrs)) div.removeAttribute(name);
                                    else if (cattrs[name] === false || cattrs[name] == null || cattrs[name] === '') div.removeAttribute(name);
                                    else div.setAttribute(name, String(cattrs[name]));
                                } else {
                                    if (cattrs[name] === false || cattrs[name] == null || cattrs[name] === '') div.removeAttribute(name);
                                    else div.setAttribute(name, String(cattrs[name]));
                                }
                            });
                        } catch {}
                    });
                }
            } catch {}
        });
    } catch {}
}
try { window.applyEventAttributesForMode = applyEventAttributesForMode; } catch {}

function renderPage(page) {
	const container = getPageNode(page.id);
	if (!container) return;
	// Before rendering, recalc formulas so displayed content is up to date
	try { if (typeof window.recalculateAllFormulas === 'function') window.recalculateAllFormulas(); } catch {}
	try { console.log('[RENDER] renderPage', { pageId: page.id, elements: page.elements?.length }); } catch {}
	Array.from(container.querySelectorAll('.element')).forEach(n => n.remove());
	if (!page) return;

	// Repeat-in-header/footer elements: clone from the first page's models if needed
	try {
		const doc = Model && Model.document ? Model.document : { pages: [] };
		const first = (doc.pages || [])[0];
		if (first && page && page.id !== first.id) {
			const shared = (first.elements || []).filter(e => (e && (e.repeatOnAllPages === true || e.repeatOnAllPages === 'true')));
			shared.forEach((tpl) => {
				const clone = Object.assign({}, tpl, { pageId: page.id });
				let node = ensureElementNode(clone);
				applyElementStyles(node, clone, page);
				node.classList.add('repeated');
				// Populate content for all element types so images/tables/text render in clones
				if (clone.type === 'text' || clone.type === 'field' || clone.type === 'rect'){
					const txt = typeof clone.content === 'string' ? clone.content : '';
					if (node.textContent !== txt) node.textContent = txt;
				} else if (clone.type === 'image'){
					if (!node.querySelector('img')){ const img = document.createElement('img'); img.alt=''; node.appendChild(img); }
					const img = node.querySelector('img'); if (img && clone.src) img.src = clone.src;
				} else if (clone.type === 'table'){
					renderTable(clone, node);
				}
				container.appendChild(node);
			});
		}
	} catch {}

	const roots = page.elements.filter(e => !e.parentId);
	const childrenByParent = new Map();
	page.elements.filter(e => e.parentId).forEach(e => {
		if (!childrenByParent.has(e.parentId)) childrenByParent.set(e.parentId, []);
		childrenByParent.get(e.parentId).push(e);
	});
	const renderOne = (elm, parentNode) => {
		const node = ensureElementNode({ ...elm, pageId: page.id });
		applyElementStyles(node, elm, page);
		// (no extra clamping needed; header/footer sizing only affects stacking, not rendering)
		try { console.log('[RENDER] applyElementStyles', elm.id, elm.type); } catch {}
		// Populate content for text-like elements so edits persist after re-render
		if (elm.type === 'text' || elm.type === 'field' || elm.type === 'rect') {
			const txt = typeof elm.content === 'string' ? elm.content : '';
			// Only touch when different to avoid caret jumps if future live updates occur
			if (node.textContent !== txt) node.textContent = txt;
		}
		if (elm.type === 'image') {
			if (!node.querySelector('img')) {
				const img = document.createElement('img');
				img.alt = '';
				node.appendChild(img);
				node.addEventListener('dblclick', async () => {
					if (!Model.document.editMode) return;
					const input = document.createElement('input');
					input.type = 'file'; input.accept = 'image/*';
					input.onchange = () => {
						const file = input.files?.[0]; if (!file) return;
						const reader = new FileReader();
						reader.onload = () => { 
							const src = String(reader.result || '');
							img.src = src;
							updateElement(elm.id, { src: src });
						};
						reader.readAsDataURL(file);
					};
					input.click();
				});
			}
			const img = node.querySelector('img');
			if (img && elm.src) img.src = elm.src;
		} else if (elm.type === 'table') {
			renderTable(elm, node);
		}
		(parentNode || container).appendChild(node);
		const kids = childrenByParent.get(elm.id) || [];
		if (kids.length){ kids.forEach(k => renderOne(k, node)); }
	};
	roots.forEach(r => renderOne(r, null));
	updateSelectionBox();
}



  </script>

  <script>
// editor.app.js
// Extracted from script.js on 2025-08-20T18:47:33.901424Z
// Range: [53602:132968] bytes

/* ----------------------- Rendering ----------------------- */
function renderAll() {
  renderPagesList();
  clearSelection();
  // Do not force visibility when editing; users expect all elements visible in edit mode
  if (!(Model && Model.document && Model.document.editMode)) enforceVisibilityForAllPages();
}

/* ----------------------- Hub + Inline Docs ----------------------- */
// Lightweight app state with persistence
const AppState = (function(){
  const KEY = 'certificateMaker:appState';
  const defaults = { view: 'hub', activeDocId: null, activeFolderId: null };
  function read(){
    try { return Object.assign({}, defaults, JSON.parse(localStorage.getItem(KEY) || '{}')); }
    catch { return { ...defaults }; }
  }
  function write(data){ try { localStorage.setItem(KEY, JSON.stringify(data)); } catch {} }
  function get(k){ return read()[k]; }
  function set(k,v){ const s = read(); s[k] = v; write(s); }
  function all(){ return read(); }
  return { get, set, all, view: 'hub', activeDocId: null };
})();

// Lightweight settings store persisted in localStorage
const Settings = (function(){
  const KEY = 'certificateMaker:settings';
  const defaults = { autosaveEnabled: true };
  function read(){
    try { return Object.assign({}, defaults, JSON.parse(localStorage.getItem(KEY) || '{}')); }
    catch { return { ...defaults }; }
  }
  function write(data){ try { localStorage.setItem(KEY, JSON.stringify(data)); } catch {} }
  function get(k){ return read()[k]; }
  function set(k,v){ const s = read(); s[k] = v; write(s); }
  function all(){ return read(); }
  return { get, set, all };
})();

function setView(name){
  try {
    AppState.set('view', name);
    AppState.view = name;
    const hv = document.getElementById('hubView');
    const ev = document.getElementById('editorView');
    if (hv) hv.hidden = name !== 'hub';
    if (ev) ev.hidden = name !== 'editor';
    const backBtn = document.getElementById('backToHubBtn');
    if (backBtn) backBtn.hidden = name !== 'editor';
    // Hide editor-only UI when in hub
    document.body.classList.toggle('in-hub', name === 'hub');
  } catch {}
}

const InlineDocs = (function(){
  function node(){ return document.getElementById('__docs__'); }
  function safeParse(text){
    try { return JSON.parse(text); }
    catch { return { catalog:[], docs:{}, folders:[], docFolders:{} }; }
  }
  function ensureShape(data){
    const d = data || {};
    if (!Array.isArray(d.catalog)) d.catalog = [];
    if (!d.docs || typeof d.docs !== 'object') d.docs = {};
    if (!Array.isArray(d.folders)) d.folders = [];
    if (!d.docFolders || typeof d.docFolders !== 'object') d.docFolders = {};
    return d;
  }
  let hydratedOnce = false;
  function read(){
    const n = node();
    const raw = n ? safeParse(n.textContent || '{"catalog":[],"docs":{}}') : { catalog:[], docs:{} };
    return ensureShape(raw);
  }
  function write(data){
    const n = node(); if (n) n.textContent = JSON.stringify(ensureShape(data));
    try {
      // Respect global autosave setting: only persist to localStorage when enabled
      if (Settings.get('autosaveEnabled') !== false) {
        localStorage.setItem('certificateMaker:inlineDocs', JSON.stringify(ensureShape(data)));
      }
    } catch {}
  }
  function hydrateFromLocal(){
    try {
      if (hydratedOnce) return;
      hydratedOnce = true;
      // Hydrate from localStorage only when the in-memory store is empty.
      // This ensures hub changes (when autosave is off) are not overwritten.
      const current = read();
      const hasRuntimeData = !!(current && (
        (Array.isArray(current.catalog) && current.catalog.length > 0) ||
        (current.docs && Object.keys(current.docs).length > 0)
      ));
      if (hasRuntimeData) return;
      const s = localStorage.getItem('certificateMaker:inlineDocs');
      if (s){
        const data = safeParse(s);
        const hasPersistentData = !!(data && (
          (Array.isArray(data.catalog) && data.catalog.length > 0) ||
          (data.docs && Object.keys(data.docs).length > 0)
        ));
        if (hasPersistentData) write(data);
      }
    } catch {}
  }
  function list(){ return read().catalog; }
  function get(id){ return read().docs[id]; }
  function set(id, doc, name){
    const data = read();
    if (!data.docs[id]) data.catalog.push({ id, name: name || 'Untitled', createdAt: Date.now(), updatedAt: Date.now() });
    else data.catalog = data.catalog.map(r => r.id===id ? { ...r, name: name ?? r.name, updatedAt: Date.now() } : r);
    data.docs[id] = doc;
    write(data);
  }
  function remove(id){ const data = read(); data.catalog = data.catalog.filter(r => r.id !== id); delete data.docs[id]; if (data.docFolders) delete data.docFolders[id]; write(data); try { if (!data.catalog || data.catalog.length === 0) localStorage.removeItem('certificateMaker:inlineDocs'); } catch {} }
  function rename(id, name){ const data = read(); data.catalog = data.catalog.map(r => r.id===id ? { ...r, name, updatedAt: Date.now() } : r); write(data); }
  function move(id, targetIndex){
    const data = read();
    const fromIndex = data.catalog.findIndex(r => r.id === id);
    if (fromIndex === -1) return;
    const [item] = data.catalog.splice(fromIndex, 1);
    let to = Math.max(0, Math.min(Number(targetIndex) || 0, data.catalog.length));
    data.catalog.splice(to, 0, item);
    write(data);
  }
  function moveBefore(id, beforeId){
    const data = read();
    const fromIndex = data.catalog.findIndex(r => r.id === id);
    const rawIndex = beforeId ? data.catalog.findIndex(r => r.id === beforeId) : data.catalog.length;
    const toIndex = Math.max(0, rawIndex - (fromIndex !== -1 && fromIndex < rawIndex ? 1 : 0));
    move(id, toIndex);
  }
  // Folders API
  function listFolders(){ return read().folders; }
  function getFolder(id){ return (read().folders || []).find(f => f.id === id) || null; }
  function docsInFolder(folderId){ const data = read(); const map = data.docFolders || {}; return (data.catalog || []).filter(r => map[r.id] === folderId).map(r => r.id); }
  function createFolder(name){
    const data = read();
    const id = 'fld-' + (crypto?.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));
    const rec = { id, name: name || 'New folder', createdAt: Date.now(), updatedAt: Date.now() };
    data.folders.push(rec);
    write(data);
    return rec;
  }
  function renameFolder(id, name){ const data = read(); data.folders = (data.folders||[]).map(f => f.id===id ? { ...f, name, updatedAt: Date.now() } : f); write(data); }
  function removeFolder(id){
    const data = read();
    data.folders = (data.folders||[]).filter(f => f.id !== id);
    // Un-assign docs from this folder
    if (data.docFolders){ Object.keys(data.docFolders).forEach(did => { if (data.docFolders[did] === id) delete data.docFolders[did]; }); }
    write(data);
  }
  function assignDocToFolder(docId, folderId){ const data = read(); data.docFolders = data.docFolders || {}; if (!folderId) delete data.docFolders[docId]; else data.docFolders[docId] = folderId; write(data); }
  function docFolderId(docId){ const data = read(); return (data.docFolders || {})[docId] || null; }
  return { list, get, set, remove, rename, hydrateFromLocal, move, moveBefore, listFolders, getFolder, createFolder, renameFolder, removeFolder, assignDocToFolder, docFolderId, docsInFolder };
})();

function renderHub(){
  try {
    InlineDocs.hydrateFromLocal();
    const allList = InlineDocs.list();
    // Selected folder (persisted)
    let activeFolder = AppState.get('activeFolderId') || null;
    // Filter list by folder if selected
    const list = (activeFolder ? allList.filter(r => InlineDocs.docFolderId(r.id) === activeFolder) : allList);
    const host = document.getElementById('docList');
    if (!host) return;
    // Render folder bar
    const folderBar = document.getElementById('folderBar');
    if (folderBar){
      const folders = InlineDocs.listFolders();
      const makePill = (id, name, isActive, deletable) => `
        <button class="folder-pill${isActive?' active':''}" data-fid="${id}" ${isActive?'aria-current="page"':''}>
          <svg class="icon" width="14" height="14" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 7h6l2 2h10v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" fill="currentColor"/></svg>
          <span class="folder-name">${name}</span>
          ${deletable?'<span class="close-btn" title="Delete" aria-label="Delete">×</span>':''}
        </button>`;
      folderBar.innerHTML = [
        makePill('all','All', !activeFolder, false),
        ...(folders||[]).map(f => makePill(f.id, f.name, activeFolder===f.id, true)).join(''),
        `<button class="folder-plus" id="addFolderBtn" title="New folder" aria-label="New folder">+
        </button>`
      ].join('');
      // Defer click action to allow dblclick to cancel it
      let folderClickTimer = null;
      // Click select
      folderBar.querySelectorAll('.folder-pill').forEach(pill => {
        pill.addEventListener('click', (e) => {
          // Ignore clicks inside inline rename input
          if (e.target && (e.target.tagName === 'INPUT' || e.target.closest('input'))) return;
          // Delete if clicking X — ask whether to delete contained docs too
          if (e.target && e.target.classList.contains('close-btn')){
            const fid = pill.dataset.fid; if (!fid || fid === 'all') return;
            // Internal dialog with two explicit options
            confirmChoices({
              title: 'Delete folder',
              message: 'What would you like to delete?',
              buttons: [
                { id:'del-with-docs', label:'Delete folder and documents', class:'danger' },
                { id:'del-folder-only', label:'Delete folder only', class:'primary' },
                { id:'cancel', label:'Cancel', class:'light' }
              ]
            }).then((choice) => {
              if (choice === 'del-with-docs'){
                try { InlineDocs.docsInFolder(fid).forEach(id => InlineDocs.remove(id)); } catch {}
                InlineDocs.removeFolder(fid);
              } else if (choice === 'del-folder-only'){
                InlineDocs.removeFolder(fid); // unassign docs to All
              } else {
                return; // cancelled
              }
              if (activeFolder===fid) { activeFolder = null; AppState.set('activeFolderId', null); }
              renderHub();
            });
            return;
          }
          // Normal select with click-delay to allow dblclick to cancel
          clearTimeout(folderClickTimer);
          folderClickTimer = setTimeout(() => {
            const fid = pill.dataset.fid;
            const next = (fid === 'all') ? null : fid;
            AppState.set('activeFolderId', next);
            renderHub();
          }, 220);
        });
        // Inline rename on double-click
        pill.addEventListener('dblclick', (e) => {
          // Cancel pending click selection
          clearTimeout(folderClickTimer);
          const fid = pill.dataset.fid; if (!fid || fid==='all') return;
          e.preventDefault(); if (e.stopPropagation) e.stopPropagation();
          const nameEl = pill.querySelector('.folder-name'); if (!nameEl) return;
          const current = (nameEl.textContent||'').trim();
          const inp = document.createElement('input');
          inp.type = 'text'; inp.value = current; inp.className = 'rename-input';
          nameEl.replaceWith(inp);
          const done = (commit) => { const v = String(inp.value||'').trim()||'Untitled'; if (commit && v!==current) InlineDocs.renameFolder(fid, v); renderHub(); };
          inp.addEventListener('keydown', (ev) => { if (ev.key==='Enter'){ ev.preventDefault(); inp.blur(); } if (ev.key==='Escape'){ ev.preventDefault(); done(false); } });
          inp.addEventListener('blur', () => done(true));
          setTimeout(() => { try { inp.focus(); inp.select(); } catch {} }, 0);
        });
        // Allow dropping docs on folder with visual indication
        pill.addEventListener('dragenter', (ev) => { ev.preventDefault(); pill.classList.add('drag-over'); });
        pill.addEventListener('dragover', (ev) => { try { if (ev.dataTransfer) ev.dataTransfer.dropEffect = 'move'; } catch{} ev.preventDefault(); pill.classList.add('drag-over'); });
        pill.addEventListener('dragleave', () => { pill.classList.remove('drag-over'); });
        pill.addEventListener('drop', (ev) => {
          ev.preventDefault();
          let docId = null; try { docId = ev.dataTransfer.getData('text/plain'); } catch {}
          if (!docId) return;
          const fid = pill.dataset.fid;
          const targetFolder = (fid === 'all') ? null : fid;
          InlineDocs.assignDocToFolder(docId, targetFolder);
          // If user dropped into a different folder, switch view to it
          AppState.set('activeFolderId', targetFolder);
          pill.classList.remove('drag-over');
          renderHub();
        });
      });
      const addBtn = document.getElementById('addFolderBtn');
      if (addBtn){
        addBtn.onclick = () => {
          const rec = InlineDocs.createFolder('New folder');
          AppState.set('activeFolderId', rec.id);
          // After render, switch the new pill into inline rename mode
          renderHub();
          setTimeout(() => {
            const pill = document.querySelector(`.folder-pill[data-fid="${rec.id}"]`);
            if (!pill) return;
            const nameEl = pill.querySelector('.folder-name');
            const inp = document.createElement('input'); inp.type='text'; inp.value = rec.name; inp.className='rename-input';
            nameEl.replaceWith(inp);
            const finish = (commit) => { const v = String(inp.value||'').trim()||'Untitled'; if (commit) InlineDocs.renameFolder(rec.id, v); renderHub(); };
            inp.addEventListener('keydown',(ev)=>{ if (ev.key==='Enter'){ ev.preventDefault(); inp.blur(); } if (ev.key==='Escape'){ ev.preventDefault(); finish(false); } });
            inp.addEventListener('blur', ()=> finish(true));
            setTimeout(() => { try { inp.focus(); inp.select(); } catch {} }, 0);
          }, 0);
        };
      }
    }
    host.innerHTML = (list || []).map(r => `
      <div class="doc-row" data-id="${r.id}" draggable="true">
        <div class="doc-name">${r.name}</div>
        <div style="display:flex;align-items:center;gap:8px">
          <div class="doc-meta">${new Date(r.updatedAt || r.createdAt || Date.now()).toLocaleString()}</div>
          <div class="doc-actions">
            <button class="btn" data-act="open" title="Open"><svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 12h16M12 4l8 8-8 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button>
            <button class="btn" data-act="rename" title="Rename"><svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z" fill="currentColor"/></svg></button>
            <button class="btn" data-act="duplicate" title="Duplicate"><svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><rect x="9" y="3" width="12" height="12" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/><rect x="3" y="9" width="12" height="12" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/></svg></button>
            <button class="btn" data-act="delete" title="Delete"><svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 6h18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M8 6V4h8v2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><rect x="6" y="6" width="12" height="14" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/><path d="M10 11v6M14 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg></button>
          </div>
        </div>
      </div>
    `).join('');
    // Inline rename helper (supports hover mode without auto-focus)
    function beginInlineRename(row, opts){
      try {
        const options = opts || {};
        const shouldFocus = options.focus !== false; // default true
        const hoverMode = options.hoverMode === true;
        if (!row) return; const id = row.dataset.id; if (!id) return;
        if (row.classList.contains('editing')) return;
        row.classList.add('editing');
        const nameEl = row.querySelector('.doc-name'); if (!nameEl) return;
        const current = (nameEl.textContent || '').trim();
        const input = document.createElement('input');
        input.type = 'text'; input.value = current; input.className = 'doc-edit';
        // Match font metrics of the text so width measurement is accurate
        try {
          const cs = getComputedStyle(nameEl);
          input.style.fontFamily = cs.fontFamily;
          input.style.fontSize = cs.fontSize;
          input.style.fontWeight = cs.fontWeight;
          input.style.fontStyle = cs.fontStyle;
          input.style.letterSpacing = cs.letterSpacing;
        } catch {}
        // Prevent row click opening while editing when interacting with the input
        ['click','mousedown','mouseup','dblclick'].forEach(evt => input.addEventListener(evt, ev => ev.stopPropagation(), true));
        // Create a hidden measurer to auto-size the input to text width + 20px
        let measurer = null;
        try {
          measurer = document.createElement('span');
          const cs = getComputedStyle(nameEl);
          measurer.style.position = 'fixed';
          measurer.style.left = '-9999px';
          measurer.style.top = '-9999px';
          measurer.style.visibility = 'hidden';
          measurer.style.whiteSpace = 'pre';
          measurer.style.fontFamily = cs.fontFamily;
          measurer.style.fontSize = cs.fontSize;
          measurer.style.fontWeight = cs.fontWeight;
          measurer.style.fontStyle = cs.fontStyle;
          measurer.style.letterSpacing = cs.letterSpacing;
          document.body.appendChild(measurer);
        } catch {}
        function updateWidth(){
          try {
            if (!measurer) return; 
            // Ensure at least one character so we don't collapse too far
            const t = input.value || '';
            measurer.textContent = t.length > 0 ? t : ' ';
            const w = Math.ceil(measurer.getBoundingClientRect().width) + 20; // text width + 20px
            input.style.width = Math.max(40, w) + 'px';
            // Keep a safe hard cap to avoid breaking layout in extreme cases
            input.style.maxWidth = '100%';
          } catch {}
        }
        const finish = (commit) => {
          try {
            const newName = commit ? String(input.value || '').trim() || 'Untitled' : current;
            if (commit && newName !== current) { InlineDocs.rename(id, newName); }
          } catch {}
          try { if (measurer && measurer.parentNode) measurer.remove(); } catch {}
          renderHub();
        };
        input.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter') { ev.preventDefault(); input.blur(); }
          if (ev.key === 'Escape') { ev.preventDefault(); finish(false); }
        });
        input.addEventListener('input', updateWidth);
        input.addEventListener('blur', () => finish(true));
        nameEl.replaceWith(input);
        updateWidth();
        // In hover mode, if the user leaves the row without focusing the input, revert gracefully
        if (hoverMode) {
          const onLeave = () => { if (document.activeElement !== input) finish(false); };
          row.addEventListener('mouseleave', onLeave, { once: true });
        }
        // Focus after replacing so selection works on Windows (unless explicitly disabled)
        if (shouldFocus) setTimeout(() => { try { input.focus(); input.select(); } catch {} }, 0);
      } catch {}
    }

    // Show inline rename input when hovering over the name text (no auto-focus)
    host.addEventListener('mouseover', (e) => {
      const name = e.target.closest('.doc-name'); if (!name) return;
      const row = name.closest('.doc-row'); if (!row) return;

      // Only trigger rename when hovering over actual text content, not empty space
      let isOverText = false;
      const walk = document.createTreeWalker(name, NodeFilter.SHOW_TEXT, null, false);
      let textNode;
      while (textNode = walk.nextNode()) {
        if (textNode.textContent.trim()) {
          const range = document.createRange();
          range.selectNode(textNode);
          const rect = range.getBoundingClientRect();
          if (e.clientX >= rect.left && e.clientX <= rect.right &&
              e.clientY >= rect.top && e.clientY <= rect.bottom) {
            isOverText = true;
            break;
          }
        }
      }

      if (isOverText) {
        beginInlineRename(row, { focus: false, hoverMode: true });
      }
    });

    let clickTimer = null;
    host.onclick = (e) => {
      const row = e.target.closest('.doc-row'); if (!row) return;
      const id = row.dataset.id; const act = e.target.closest('button')?.dataset.act;
      // If clicking any action button
      if (act) {
        if (act === 'open') openDocument(id);
        if (act === 'rename') beginInlineRename(row);
        if (act === 'delete') { if (confirm('Delete this document?')) { InlineDocs.remove(id); renderHub(); } }
        if (act === 'duplicate') {
          const copyId = `doc-${(crypto && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2))}`;
          const cur = InlineDocs.get(id);
          if (cur) {
            const name = (row.querySelector('.doc-name')?.textContent || 'Document') + ' copy';
            InlineDocs.set(copyId, JSON.parse(JSON.stringify(cur)), name);
            const activeFolder = AppState.get('activeFolderId') || null;
            InlineDocs.assignDocToFolder(copyId, activeFolder);
          }
          renderHub();
        }
        return;
      }

      // If currently in inline edit mode, allow clicks inside input to edit; clicking elsewhere opens
      if (row.classList.contains('editing')) {
        if (e.target.closest('.doc-edit')) return; // keep editing
        // If not clicking on input or action button, open the document
        if (!e.target.closest('button')) { openDocument(id); }
        return;
      }

      // If clicking on the name, delay to detect a double-click (which triggers rename)
      if (e.target.closest('.doc-name')) {
        clearTimeout(clickTimer);
        clickTimer = setTimeout(() => { try { openDocument(id); } catch {} }, 250);
        return;
      }

      // Otherwise open immediately
      openDocument(id);
    };

    // Double click on the name -> inline rename
    host.addEventListener('dblclick', (e) => {
      const name = e.target.closest('.doc-name'); if (!name) return;
      const row = e.target.closest('.doc-row'); if (!row) return;
      clearTimeout(clickTimer);
      e.preventDefault(); e.stopPropagation();
      beginInlineRename(row);
    }, true);

    // Drag & drop reordering with single global drop marker
    let draggingId = null;
    let dropMarker = null;
    function ensureMarker(){
      if (!dropMarker){
        dropMarker = document.createElement('div');
        dropMarker.className = 'doc-drop-marker';
      }
      if (!dropMarker.parentNode) host.appendChild(dropMarker);
      return dropMarker;
    }
    host.ondragstart = (e) => {
      const row = e.target.closest('.doc-row'); if (!row) return;
      draggingId = row.dataset.id;
      row.classList.add('dragging');
      try { e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', draggingId); } catch {}
    };
    host.ondragend = () => {
      draggingId = null;
      host.querySelectorAll('.doc-row').forEach(r => r.classList.remove('dragging'));
      if (dropMarker && dropMarker.parentNode) dropMarker.remove();
    };
    host.ondragover = (e) => {
      if (!draggingId) return; e.preventDefault();
      try { if (e.dataTransfer) e.dataTransfer.dropEffect = 'move'; } catch {}
      const rows = Array.from(host.querySelectorAll('.doc-row'));
      const others = rows.filter(r => r.dataset.id !== draggingId);
      const marker = ensureMarker();
      const hostRect = host.getBoundingClientRect();
      const y = e.clientY - hostRect.top + host.scrollTop;
      // Determine insertion index among non-dragging rows
      let index = 0;
      for (let i = 0; i < others.length; i++){
        const rr = others[i].getBoundingClientRect();
        const mid = rr.top - hostRect.top + host.scrollTop + rr.height / 2;
        if (y > mid) index = i + 1; else break;
      }
      // Place marker at exact boundary without reflow
      let top = 0;
      if (others.length === 0){
        top = 0;
      } else if (index === 0){
        const rr0 = others[0].getBoundingClientRect();
        top = rr0.top - hostRect.top + host.scrollTop;
      } else if (index >= others.length){
        const rrl = others[others.length - 1].getBoundingClientRect();
        top = rrl.top - hostRect.top + host.scrollTop + rrl.height;
      } else {
        const rrB = others[index - 1].getBoundingClientRect();
        top = rrB.top - hostRect.top + host.scrollTop + rrB.height;
      }
      marker.style.top = Math.max(0, Math.floor(top)) + 'px';
      marker.dataset.index = String(index);
    };
    host.ondrop = (e) => {
      if (!draggingId) return; e.preventDefault();
      let destIndex = Number(dropMarker?.dataset?.index || 0);
      // Convert index among non-dragging rows into full list index
      const rows = Array.from(host.querySelectorAll('.doc-row'));
      const fromIndex = rows.findIndex(r => r.dataset.id === draggingId);
      const others = rows.filter(r => r.dataset.id !== draggingId);
      // Position relative to others, then adjust for removal when moving down
      const afterRemovalIndex = destIndex + (fromIndex !== -1 && fromIndex < destIndex ? 1 : 0);
      try { InlineDocs.move(draggingId, afterRemovalIndex); } catch {}
      renderHub();
    };
  } catch {}
}

// Reusable internal confirm with multiple buttons
function confirmChoices({ title = 'Confirm', message = '', buttons = [] } = {}){
  return new Promise((resolve) => {
    const dlg = document.getElementById('confirmDialog');
    const titleEl = document.getElementById('confirmTitle');
    const msgEl = document.getElementById('confirmMessage');
    const btnsEl = document.getElementById('confirmButtons');
    if (!dlg || !titleEl || !msgEl || !btnsEl){ resolve(null); return; }
    titleEl.textContent = title;
    msgEl.textContent = message;
    btnsEl.innerHTML = '';
    const close = (value) => { dlg.classList.add('hidden'); resolve(value); };
    document.getElementById('confirmCloseBtn')?.addEventListener('click', () => close(null), { once:true });
    buttons.forEach(b => {
      const btn = document.createElement('button');
      btn.className = `btn ${b.class||''}`.trim();
      btn.textContent = b.label || 'OK';
      btn.addEventListener('click', () => close(b.id || true));
      btnsEl.appendChild(btn);
    });
    dlg.classList.remove('hidden');
  });
}

// Standalone function for inline document renaming (extracted from renderHub)
function beginInlineRename(row, opts){
  try {
    const options = opts || {};
    const shouldFocus = options.focus !== false; // default true
    const hoverMode = options.hoverMode === true;
    if (!row) return; const id = row.dataset.id; if (!id) return;
    if (row.classList.contains('editing')) return;
    row.classList.add('editing');
    const nameEl = row.querySelector('.doc-name'); if (!nameEl) return;
    const current = (nameEl.textContent || '').trim();
    const input = document.createElement('input');
    input.type = 'text'; input.value = current; input.className = 'doc-edit';
    // Match font metrics of the text so width measurement is accurate
    try {
      const cs = getComputedStyle(nameEl);
      input.style.fontFamily = cs.fontFamily;
      input.style.fontSize = cs.fontSize;
      input.style.fontWeight = cs.fontWeight;
      input.style.fontStyle = cs.fontStyle;
      input.style.letterSpacing = cs.letterSpacing;
    } catch {}
    // Prevent row click opening while editing when interacting with the input
    ['click','mousedown','mouseup','dblclick'].forEach(evt => input.addEventListener(evt, ev => ev.stopPropagation(), true));
    // Create a hidden measurer to auto-size the input to text width + 20px
    let measurer = null;
    try {
      measurer = document.createElement('span');
      const cs = getComputedStyle(nameEl);
      measurer.style.position = 'fixed';
      measurer.style.left = '-9999px';
      measurer.style.top = '-9999px';
      measurer.style.visibility = 'hidden';
      measurer.style.whiteSpace = 'pre';
      measurer.style.fontFamily = cs.fontFamily;
      measurer.style.fontSize = cs.fontSize;
      measurer.style.fontWeight = cs.fontWeight;
      measurer.style.fontStyle = cs.fontStyle;
      measurer.style.letterSpacing = cs.letterSpacing;
      document.body.appendChild(measurer);
    } catch {}
    function updateWidth(){
      try {
        if (!measurer) return;
        // Ensure at least one character so we don't collapse too far
        const t = input.value || '';
        measurer.textContent = t.length > 0 ? t : ' ';
        const w = Math.ceil(measurer.getBoundingClientRect().width) + 20; // text width + 20px
        input.style.width = Math.max(40, w) + 'px';
        // Keep a safe hard cap to avoid breaking layout in extreme cases
        input.style.maxWidth = '100%';
      } catch {}
    }
    const finish = (commit) => {
      try {
        const newName = commit ? String(input.value || '').trim() || 'Untitled' : current;
        if (commit && newName !== current) { InlineDocs.rename(id, newName); }
      } catch {}
      try { if (measurer && measurer.parentNode) measurer.remove(); } catch {}
      renderHub();
    };
    input.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter') { ev.preventDefault(); input.blur(); }
      if (ev.key === 'Escape') { ev.preventDefault(); finish(false); }
    });
    input.addEventListener('input', updateWidth);
    input.addEventListener('blur', () => finish(true));
    nameEl.replaceWith(input);
    updateWidth();
    // In hover mode, if the user leaves the row without focusing the input, revert gracefully
    if (hoverMode) {
      const onLeave = () => { if (document.activeElement !== input) finish(false); };
      row.addEventListener('mouseleave', onLeave, { once: true });
    }
    // Focus after replacing so selection works on Windows (unless explicitly disabled)
    if (shouldFocus) setTimeout(() => { try { input.focus(); input.select(); } catch {} }, 0);
  } catch {}
}

function newDocument(){
  const id = `doc-${(crypto && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2))}`;
  const name = 'New document'; // Default name, will be immediately editable
  const doc = { pages: [createPage('Page 1')], currentPageId: '', nextElementId: 1, editMode: true, headerHeight: 10, footerHeight: 10 };
  doc.currentPageId = doc.pages[0].id;
  InlineDocs.set(id, doc, name);
  // If a folder is active, assign the new doc to it
  try {
    const fid = AppState.get('activeFolderId');
    if (fid) InlineDocs.assignDocToFolder(id, fid);
  } catch {}

  // Re-render the hub to show the new document in the list
  renderHub();

  // Find the newly created document row and trigger inline rename
  setTimeout(() => {
    const row = document.querySelector(`.doc-row[data-id="${id}"]`);
    if (row) {
      beginInlineRename(row);
    }
  }, 0);

  try { const t = document.getElementById('docTitleInput'); if (t) t.value = name; } catch {}
}

function openDocument(id){
  const doc = InlineDocs.get(id);
  if (!doc) { alert('Document not found'); return; }
  Model.document = doc;
  // Always open in view mode as requested
  setEditMode(false);
  renderAll();
  AppState.set('activeDocId', id);
  AppState.activeDocId = id;
  setView('editor');
  try {
    // Update nav bar title text
    const r = (InlineDocs.list() || []).find(x => x.id === id);
    const t = document.getElementById('docTitleInput');
    if (t) t.value = r ? r.name : 'Untitled';
  } catch {}
}

function backToHub(){
  // Do not autosave when leaving the doc; navigate only
  AppState.set('activeDocId', null);
  AppState.activeDocId = null;
  setView('hub');
  renderHub();
}

function initializeHubRouter(){
  try {
    // Initial view: hub
    setView('hub');
    renderHub();
    const newBtn = document.getElementById('newDocBtn');
    if (newBtn) newBtn.addEventListener('click', newDocument);
    const hubSaveBtn = document.getElementById('hubSaveBtn');
    if (hubSaveBtn) hubSaveBtn.addEventListener('click', async () => { try { await saveDocument(); } catch {} });
    const backBtn = document.getElementById('backToHubBtn');
    if (backBtn) backBtn.addEventListener('click', backToHub);
    // Inline title editing
    const titleInput = document.getElementById('docTitleInput');
    if (titleInput){
      // Initialize from current record if available
      try {
        const list = InlineDocs.list() || [];
        const rec = list.find(r => r.id === AppState.activeDocId);
        if (rec && typeof rec.name === 'string') titleInput.value = rec.name;
      } catch {}
      titleInput.addEventListener('change', () => {
        const v = String(titleInput.value || '').trim() || 'Untitled';
        try { if (AppState.activeDocId) InlineDocs.rename(AppState.activeDocId, v); } catch {}
        titleInput.value = v;
      });
      titleInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); titleInput.blur(); } });
    }

    // Check if we should restore a previously opened document
    const persistedDocId = AppState.get('activeDocId');
    if (persistedDocId && InlineDocs.get(persistedDocId)) {
      // Small delay to ensure everything is initialized
      setTimeout(() => openDocument(persistedDocId), 100);
    }
  } catch {}
}

// Debounced inline autosave that mirrors the current doc into InlineDocs and
// performs a background file save (FSA/OPFS/local) without prompts.
let __inlineSaveTimer = null;
function autosaveInline(){
  try {
    if (Settings.get('autosaveEnabled') === false) return;
    if (!AppState.activeDocId) return;
    if (__inlineSaveTimer) clearTimeout(__inlineSaveTimer);
    __inlineSaveTimer = setTimeout(async () => {
      __inlineSaveTimer = null;
      // Mirror the standard save path: update inline snapshot then ask extension to save
      try { InlineDocs.set(AppState.activeDocId, Model.document); } catch {}
      try { indicateSaving(); } catch {}
      triggerExtensionSave();
      // Completion indicator is handled by cm-save-done / cm-save-error events
    }, 500);
  } catch {}
}

function enforceVisibilityForAllPages(){
  try {
    // Skip global visibility enforcement in edit mode to avoid re-applying view-mode hidden flags
    if (Model && Model.document && Model.document.editMode) return;
    (Model.document.pages || []).forEach((p) => {
      const container = document.querySelector(`.page-wrapper[data-page-id="${p.id}"] .page`);
      if (!container) return;
      (p.elements || []).forEach((elm) => {
        const node = container.querySelector(`.element[data-id="${elm.id}"]`);
        if (!node) return;
        const attrs = (elm && elm.attrs) ? elm.attrs : {};
        let isHidden = false;
        try {
          if (attrs.hidden === true || attrs.hidden === 'true') isHidden = true;
          const st = String(attrs.style || '');
          if (/display\s*:\s*none/i.test(st)) isHidden = true;
        } catch {}
        if (isHidden) {
          node.style.display = 'none';
        } else {
          node.style.display = (elm.type === 'text' || elm.type === 'field' || elm.type === 'rect') ? 'flex' : '';
        }
      });
    });
  } catch {}
}

// getPageNode moved to app.view.render.js

function renderPagesList() {
  const list = pagesList();
  list.innerHTML = '';
  Model.document.pages.forEach((p, index) => {
    const wrap = document.createElement('div');
    wrap.className = 'page-wrapper';
    wrap.dataset.pageId = p.id;

    const title = document.createElement('div');
    title.className = 'page-title';
    title.innerHTML = `
      <strong>Page ${index + 1}</strong>
      <span style="margin-left:6px;color:var(--muted)">${p.name}</span>
      <span class="title-actions" style="float:right;display:inline-flex;gap:6px">
        <button class="btn mini" data-act="move-up" title="Move up" aria-label="Move up">
          <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 6l-6 6h12z" fill="currentColor"/></svg>
        </button>
        <button class="btn mini" data-act="move-down" title="Move down" aria-label="Move down">
          <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 18l6-6H6z" fill="currentColor"/></svg>
        </button>
        <button class="btn mini" data-act="toggle-visibility" title="Show/Hide" aria-label="Show or hide">
          <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M1.5 12s4-7.5 10.5-7.5S22.5 12 22.5 12s-4 7.5-10.5 7.5S1.5 12 1.5 12z" fill="none" stroke="currentColor" stroke-width="2"/>
            <circle cx="12" cy="12" r="3" fill="currentColor"/>
          </svg>
        </button>
        <button class="btn mini" data-act="duplicate" title="Duplicate" aria-label="Duplicate">
          <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
            <rect x="9" y="3" width="12" height="12" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
            <rect x="3" y="9" width="12" height="12" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
          </svg>
        </button>
        <button class="btn mini" data-act="delete" title="Delete" aria-label="Delete">
          <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M3 6h18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            <path d="M8 6V4h8v2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            <rect x="6" y="6" width="12" height="14" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
            <path d="M10 11v6M14 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </button>
        <button class="btn mini" data-act="add-below" title="Add page below" aria-label="Add page below">
          <svg class="icon" width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </button>
      </span>`;
    wrap.appendChild(title);

    const stage = document.createElement('div');
    stage.className = 'page-stage';

    const page = document.createElement('div');
    page.className = 'page';
    page.setAttribute('aria-label', 'A4 canvas');

    // guides
    const guideV = document.createElement('div'); guideV.className = 'guide v hidden';
    const guideH = document.createElement('div'); guideH.className = 'guide h hidden';
    page.appendChild(guideV); page.appendChild(guideH);

    // Header/Footer guides
    const headerGuide = document.createElement('div');
    headerGuide.className = 'hf-guide header';
    const headerLabel = document.createElement('div'); headerLabel.className = 'hf-label'; headerLabel.textContent = '';
    const headerResize = document.createElement('div'); headerResize.className = 'hf-resize';
    headerGuide.appendChild(headerLabel); headerGuide.appendChild(headerResize);
    page.appendChild(headerGuide);

    const footerGuide = document.createElement('div');
    footerGuide.className = 'hf-guide footer';
    const footerLabel = document.createElement('div'); footerLabel.className = 'hf-label'; footerLabel.textContent = '';
    const footerResize = document.createElement('div'); footerResize.className = 'hf-resize';
    footerGuide.appendChild(footerLabel); footerGuide.appendChild(footerResize);
    page.appendChild(footerGuide);

    stage.appendChild(page);
    wrap.appendChild(stage);

    list.appendChild(wrap);

    // Render elements for this page
    renderPage(p);

    // Activate on click
    wrap.addEventListener('mousedown', (e) => {
      const clickedInsidePage = !!e.target.closest('.page');
      if (Model.document.currentPageId !== p.id) {
        Model.document.currentPageId = p.id;
        renderAll();
        e.preventDefault();
        return; // stop initiating drag on a different page
      }
      if (!clickedInsidePage) return;
    });

    // Controls actions (both title actions and any future controls)
    wrap.addEventListener('click', (e) => {
      const btn = e.target.closest('[data-act]'); if (!btn) return;
      if (btn.dataset.act === 'duplicate') { Model.document.currentPageId = p.id; duplicateCurrentPage(); }
      else if (btn.dataset.act === 'delete') { Model.document.currentPageId = p.id; removeCurrentPage(); }
      else if (btn.dataset.act === 'move-up') { Model.document.currentPageId = p.id; moveCurrentPage(-1); }
      else if (btn.dataset.act === 'move-down') { Model.document.currentPageId = p.id; moveCurrentPage(1); }
      else if (btn.dataset.act === 'add-below') { Model.document.currentPageId = p.id; addPage(); }
      else if (btn.dataset.act === 'toggle-visibility') { wrap.classList.toggle('hidden'); }
    });

    // Position header/footer guides using document settings
    try { updateHeaderFooterGuides(page); } catch {}

    // Enable drag-resize for header/footer on this page
    try { attachHeaderFooterResizers(page, p.id); } catch {}
  });
}

// ensureElementNode moved to app.view.render.js

// Attach user-defined action listeners to an element node
// Deprecated binder (kept no-op for compatibility with older documents that may carry an actions array)
function bindElementActions(){ /* no-op: using inline attributes approach */ }

// applyElementStyles moved to app.view.render.js

// renderPage moved to app.view.render.js
/* ----------------------- Header & Footer Guides ----------------------- */
function updateHeaderFooterGuides(pageNode){
  try {
    if (!pageNode) return;
    const hh = Number(Model?.document?.headerHeight || 0);
    const fh = Number(Model?.document?.footerHeight || 0);
    const header = pageNode.querySelector('.hf-guide.header');
    const footer = pageNode.querySelector('.hf-guide.footer');
    if (header){ header.style.height = Math.max(0, hh) + 'px'; header.style.display = hh > 0 ? 'block' : 'none'; }
    if (footer){ footer.style.height = Math.max(0, fh) + 'px'; footer.style.display = fh > 0 ? 'block' : 'none'; }
  } catch {}
}

function setHeaderFooterHeights({ header, footer }){
  commitHistory('set-header-footer');
  Model.document.headerHeight = Math.max(0, Number(header || 0));
  Model.document.footerHeight = Math.max(0, Number(footer || 0));
  // Update all page guides and reflow stacks for usable height
  try {
    document.querySelectorAll('.page').forEach(p => updateHeaderFooterGuides(p));
  } catch {}
  try { reflowStacks(getCurrentPage()); } catch {}
}

function attachHeaderFooterResizers(pageNode, pageId){
  try {
    const header = pageNode.querySelector('.hf-guide.header .hf-resize');
    const footer = pageNode.querySelector('.hf-guide.footer .hf-resize');
    const z = (typeof getZoom === 'function') ? (getZoom() || 1) : 1;
    if (header){
      let startY = 0; let startH = 0; let moving = false;
      header.addEventListener('mousedown', (e) => {
        if (!Model.document.editMode) return;
        moving = true; startY = e.clientY; startH = Number(Model.document.headerHeight || 0);
        document.body.classList.add('hf-resizing');
        e.preventDefault();
        e.stopPropagation();
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
      });
      window.addEventListener('mousemove', (e) => {
        if (!moving) return;
        const dy = (e.clientY - startY) / (z || 1);
        const nh = Math.max(0, Math.round(startH + dy));
        Model.document.headerHeight = nh;
        updateHeaderFooterGuides(pageNode);
      });
      window.addEventListener('mouseup', () => { if (moving){ moving = false; setHeaderFooterHeights({ header: Model.document.headerHeight, footer: Model.document.footerHeight }); document.body.classList.remove('hf-resizing'); } });
    }
    if (footer){
      let startY = 0; let startH = 0; let moving = false; const pageRect = () => pageNode.getBoundingClientRect();
      footer.addEventListener('mousedown', (e) => {
        if (!Model.document.editMode) return; moving = true; startY = e.clientY; startH = Number(Model.document.footerHeight || 0); document.body.classList.add('hf-resizing'); e.preventDefault(); e.stopPropagation(); if (e.stopImmediatePropagation) e.stopImmediatePropagation();
      });
      window.addEventListener('mousemove', (e) => {
        if (!moving) return; const dy = (startY - e.clientY) / (z || 1); const nh = Math.max(0, Math.round(startH + dy)); Model.document.footerHeight = nh; updateHeaderFooterGuides(pageNode);
      });
      window.addEventListener('mouseup', () => { if (moving){ moving = false; setHeaderFooterHeights({ header: Model.document.headerHeight, footer: Model.document.footerHeight }); document.body.classList.remove('hf-resizing'); } });
    }
  } catch {}
}


/* ----------------------- Updates ----------------------- */
function updateElement(id, patch) {
  const page = getCurrentPage();

  // If a CSS selector string is provided (and not a known model id), resolve and apply
  if (typeof id === 'string' && id) {
    const maybeModel = getElementById(id);
    if (!maybeModel) {
      // Preserve current element and table selections
      const prevSelIds = Array.from(document.querySelectorAll('.page .element.selected'))
        .map(n => n && n.getAttribute('data-id'))
        .filter(Boolean);
      const prevTableSel = tableSel ? { ...tableSel } : null;

      const targets = { elementIds: new Set(), cells: [] }; // cells: { tableId, r, c }
      function addElementId(eid){ if (eid) targets.elementIds.add(eid); }
      function addCellTarget(tableId, cellId){
        try {
          const tModel = getElementById(tableId);
          const grid = tModel?.grid || [];
          for (let r = 0; r < grid.length; r++){
            const row = grid[r] || [];
            for (let c = 0; c < row.length; c++){
              if (row[c] === cellId){ targets.cells.push({ tableId, r, c }); return; }
            }
          }
        } catch {}
      }

      let nodes = [];
      try { nodes = Array.from(document.querySelectorAll(id)); } catch {}
      if (!nodes.length) {
        const token = String(id).replace(/^#/, '');
        // Look for element with data-id across all pages
        const byData = document.querySelectorAll(`.page [data-id="${token}"]`);
        if (byData && byData.length) nodes.push(...byData);
      }
      nodes.forEach(node => {
        if (!node) return;
        if (node.classList && node.classList.contains('element') && node.dataset?.id){
          addElementId(node.dataset.id);
          return;
        }
        const container = node.closest('.element[data-id]');
        if (node.dataset?.id && container?.dataset?.id) { addCellTarget(container.dataset.id, node.dataset.id); return; }
        if (container?.dataset?.id) addElementId(container.dataset.id);
      });

      // Apply to elements and specific table cells in a single history entry
      if (targets.elementIds.size || targets.cells.length){
        commitHistory('update-multi');
        let doc = Model.document;
        if (targets.elementIds.size){
          // Apply across any page, not just current
          doc = applyPatchToElementsAnyPage(doc, [...targets.elementIds], patch);
        }
        if (targets.cells.length){
          const styles = (patch && patch.styles) || {};
          // Apply per-cell (table might be on any page)
          targets.cells.forEach(({ tableId, r, c }) => {
            doc = applyPatchToTableCellsAnyPage(doc, tableId, { r0:r, c0:c, r1:r, c1:c }, styles);
          });
        }
        Model.document = doc;
        // Re-render all pages because the change may be off the current page
        renderAll();
        updateSelectionUI();
      }

      // Restore previous selections
      if (prevTableSel && typeof setTableSelection === 'function') {
        setTableSelection(prevTableSel.tableId, prevTableSel.r0, prevTableSel.c0, prevTableSel.r1, prevTableSel.c1);
      }
      if (Array.isArray(prevSelIds) && prevSelIds.length && typeof setSelection === 'function') {
        setSelection(prevSelIds);
      }
      return;
    }
  }

  // Unified behavior: if id is null/undefined, apply to selection or table cells
  if (id == null) {
    // If there is an active table cell selection, apply patch via table helpers
    if (tableSel) {
      commitHistory('update-element');
      Model.document = applyPatchToTableCells(Model.document, tableSel.tableId, tableSel, (patch && patch.styles) || {});
      renderPage(getCurrentPage());
      setTableSelection(tableSel.tableId, tableSel.r0, tableSel.c0, tableSel.r1, tableSel.c1);
      return;
    }
    // Otherwise, apply to all currently selected elements (multi-update)
    if (selectedIds.size === 0) return;
    commitHistory('update-multi');
    Model.document = applyPatchToElements(Model.document, [...selectedIds], patch);
    renderPage(getCurrentPage());
    updateSelectionUI();
    return;
  }

  // Original behavior: update a single element by id
  commitHistory('update-element');
  // Preserve table cell selection if we're updating the same table
  const prevTableSel = (tableSel && tableSel.tableId === id) ? { ...tableSel } : null;
  // If the id is not on the current page, patch it by searching across all pages
  const curHas = !!(page && page.elements && page.elements.some(e => e.id === id));
  Model.document = curHas ? applyPatchToElements(Model.document, [id], patch)
                          : applyPatchToElementsAnyPage(Model.document, [id], patch);
  renderPage(getCurrentPage());
  
  if (prevTableSel) {
    // Re-apply table cell selection after re-render (don't change element selection)
    setTableSelection(prevTableSel.tableId, prevTableSel.r0, prevTableSel.c0, prevTableSel.r1, prevTableSel.c1);
  } else {
    // Only set element selection if we're not preserving table selection
    try {
      if (!Model.document.editMode) { clearSelection(); }
      else {
        const updated = getElementById(id);
        if (updated && isElementHidden(updated)) { clearSelection(); }
        else { setSelection([id]); }
      }
    } catch { if (Model.document.editMode) setSelection([id]); else clearSelection(); }
  }
}

/* ----------------------- Toolbar sync ----------------------- */
function syncFormatToolbar(m){
  const bar = formatToolbar(); if (!bar) return;
  const setVal = (sel, val) => { const el = bar.querySelector(sel); if (el && document.activeElement !== el) el.value = val ?? ''; };
  const press = (sel, on) => { const b = bar.querySelector(sel); if (b){ b.setAttribute('aria-pressed', on ? 'true':'false'); }};

  // If a table cell/range is active, reflect the anchor cell styles in the toolbar
  if (tableSel && m.type === 'table'){
    const tModel = m;
    const ar = Math.min(tableSel.r0, tableSel.r1);
    const ac = Math.min(tableSel.c0, tableSel.c1);
    const id = tModel.grid[ar]?.[ac];
    const cell = id ? tModel.cells[id] : null;
    const cs = cell ? cell.styles || {} : {};
    setVal('input[data-prop="styles.fill"]', cs.bg);
    setVal('input[data-prop="styles.textColor"]', cs.textColor);
    // Stroke properties are per-cell too in our applier
    setVal('input[data-prop="styles.strokeColor"]', cs.strokeColor ?? m.styles.strokeColor);
    setVal('input[data-prop="styles.strokeWidth"]', (cs.strokeWidth ?? m.styles.strokeWidth) || 0);
    setVal('select[data-prop="styles.fontFamily"]', cs.fontFamily ?? 'system-ui');
    setVal('select[data-prop="styles.fontSize"]', cs.fontSize ?? 14);
    press('[data-toggle="styles.bold"]', !!cs.bold);
    press('[data-toggle="styles.italic"]', !!cs.italic);
    press('[data-toggle="styles.underline"]', !!cs.underline);
  } else {
    // Normal element selection
  setVal('input[data-prop="styles.fill"]', m.styles.fill);
  setVal('input[data-prop="styles.textColor"]', m.styles.textColor);
  setVal('input[data-prop="styles.strokeColor"]', m.styles.strokeColor);
  setVal('input[data-prop="styles.strokeWidth"]', m.styles.strokeWidth || 0);
  setVal('input[data-prop="styles.radius"]', m.styles.radius || 0);
  setVal('select[data-prop="styles.fontFamily"]', m.styles.fontFamily);
  setVal('select[data-prop="styles.fontSize"]', m.styles.fontSize || 14);
  press('[data-toggle="styles.bold"]', !!m.styles.bold);
  press('[data-toggle="styles.italic"]', !!m.styles.italic);
  press('[data-toggle="styles.underline"]', !!m.styles.underline);
  }
  // text alignment
  const setPressed = (selector, value, expected) => {
    const btn = bar.querySelector(selector); if (btn) btn.setAttribute('aria-pressed', String(value === expected));
  };
  if (m.type === 'text' || m.type === 'field' || m.type === 'rect'){
    setPressed('[data-align-h="left"]', m.styles.textAlignH || 'left', 'left');
    setPressed('[data-align-h="center"]', m.styles.textAlignH || 'left', 'center');
    setPressed('[data-align-h="right"]', m.styles.textAlignH || 'left', 'right');
    setPressed('[data-align-v="top"]', m.styles.textAlignV || 'top', 'top');
    setPressed('[data-align-v="middle"]', m.styles.textAlignV || 'top', 'middle');
    setPressed('[data-align-v="bottom"]', m.styles.textAlignV || 'top', 'bottom');
  } else {
    ['left','center','right'].forEach(k => { const b = bar.querySelector(`[data-align-h="${k}"]`); if (b) b.setAttribute('aria-pressed','false'); });
    ['top','middle','bottom'].forEach(k => { const b = bar.querySelector(`[data-align-v="${k}"]`); if (b) b.setAttribute('aria-pressed','false'); });
  }
  const tbg = document.getElementById('bgTransparentToggle');
  if (tbg) tbg.checked = m.styles.fill === 'transparent';
}
/* deepMerge moved to editor.core.js */

/* ----------------------- Adding elements ----------------------- */
let pendingAddType = null; // 'text'|'rect'|'line' for single insertion
function armAdd(type){ pendingAddType = type; }

function placePendingAt(x, y, pageId = Model.document.currentPageId){
  if (!pendingAddType) return;
  commitHistory('add-element');
  const base = {
    id: generateId(), type: pendingAddType, x, y, w: 160, h: 60, z: 1,
    styles: { fill:'#ffffff', strokeColor:'#111827', strokeWidth:1, radius:4,
      textColor:'#111827', fontFamily:'system-ui', fontSize:14, bold:false, italic:false, underline:false }
  };
  base.freeMove = false; // default behavior keeps element constrained to page
  if (pendingAddType === 'rect') base.styles.fill = '#dbeafe';
  if (pendingAddType === 'line') Object.assign(base, { x2: x+120, y2: y });
  if (pendingAddType === 'text') base.content = '';
  if (pendingAddType === 'field') base.content = '';
  // Special: a simple function button element (free-moving by default)
  if (pendingAddType === 'funcbtn'){
    base.type = 'rect';
    base.w = 120; base.h = 36;
    base.styles.fill = '#fafafa';
    base.styles.strokeColor = '#111827';
    base.styles.radius = 6;
    base.styles.textAlignH = 'center';
    base.styles.textAlignV = 'middle';
    base.content = 'Run Action';
    base.attrs = Object.assign({}, base.attrs, {
      role: 'button',
      tabindex: 0,
      'data-run-actions-in-edit': 'true',
      onclick: "simpleConsoleLogFunction('clicked')"
    });
    base.freeMove = true; // make toolbar buttons free-move by default
  }
  if (pendingAddType === 'image') { base.type = 'image'; base.w = 160; base.h = 120; }
  if (pendingAddType === 'table') {
    const t = makeTableElement(3,4);
    Object.assign(base, t, { x, y });
    // Tables should not have an outer border by default
    base.styles.strokeWidth = 0;
  }
  // New stacked Block container
  if (pendingAddType === 'block') {
    base.type = 'block';
    base.w = 420; base.h = 180;
    base.styles.fill = '#ffffff';
    base.styles.strokeWidth = 1;
    base.styles.radius = 8;
    base.stackChildren = true;
    base.stackByPage = true;
    base.freeMove = false;
  }
  const page = Model.document.pages.find(p => p.id === pageId) || getCurrentPage();
  page.elements.push(base);
  Model.document.currentPageId = page.id;
  // If dropped inside a block, parent it before reflow
  try { reparentIntoBlocks(page, [base.id]); } catch {}
  // Immediately reflow page stacks so newly added elements snap into place
  try { reflowStacks(page); } catch {}
  pendingAddType = null; // single insertion
  renderPage(page);
  setSelection([base.id]);
}

/* ----------------------- Interaction ----------------------- */
function getCanvasPoint(evt, pageNode = getPageNode(), clamp = true){
  const r = pageNode.getBoundingClientRect();
  const z = getZoom();
  const cx = (evt.clientX ?? evt.touches?.[0]?.clientX);
  const cy = (evt.clientY ?? evt.touches?.[0]?.clientY);
  const x = (cx - r.left) / z;
  const y = (cy - r.top) / z;
  if (!clamp) return { x, y };
  const w = pageNode.clientWidth;
  const h = pageNode.clientHeight;
  return { x: Math.max(0, Math.min(w, x)), y: Math.max(0, Math.min(h, y)) };
}

// Compute which page is most visible within the viewport and return its node and id
function getMostVisiblePageInfo(){
  try {
    const vp = document.getElementById('pageViewport');
    if (!vp) return null;
    const vpr = vp.getBoundingClientRect();
    let best = null; let bestArea = 0;
    document.querySelectorAll('.page-wrapper .page').forEach((page) => {
      const pr = page.getBoundingClientRect();
      const left = Math.max(pr.left, vpr.left);
      const top = Math.max(pr.top, vpr.top);
      const right = Math.min(pr.right, vpr.right);
      const bottom = Math.min(pr.bottom, vpr.bottom);
      const w = Math.max(0, right - left);
      const h = Math.max(0, bottom - top);
      const area = w * h;
      if (area > bestArea){ bestArea = area; best = page; }
    });
    if (!best) return null;
    const wrap = best.closest('.page-wrapper');
    const pageId = wrap && wrap.dataset ? wrap.dataset.pageId : null;
    return pageId ? { pageNode: best, pageId } : null;
  } catch { return null; }
}

// Return a visible, viewport-aware point (logical coords) on the most visible page
function getVisibleInsertionPoint(){
  const info = getMostVisiblePageInfo(); if (!info) return null;
  const vp = document.getElementById('pageViewport'); if (!vp) return null;
  const vpr = vp.getBoundingClientRect();
  const pr = info.pageNode.getBoundingClientRect();
  const z = (typeof getZoom === 'function') ? (getZoom() || 1) : 1;
  const left = Math.max(pr.left, vpr.left);
  const top = Math.max(pr.top, vpr.top);
  const right = Math.min(pr.right, vpr.right);
  const bottom = Math.min(pr.bottom, vpr.bottom);
  let cx = (left + right) / 2;
  let cy = (top + bottom) / 2;
  // Fallback to page center if there is no intersection
  if (!(right > left && bottom > top)) { cx = pr.left + pr.width/2; cy = pr.top + pr.height/2; }
  let x = (cx - pr.left) / z;
  let y = (cy - pr.top) / z;
  // Nudge to stay within visible/safe area, accounting for header/footer
  try {
    const header = Number(Model?.document?.headerHeight || 0);
    const footer = Number(Model?.document?.footerHeight || 0);
    const w = info.pageNode.clientWidth;
    const h = info.pageNode.clientHeight;
    const margin = 20; // logical px
    const minX = margin;
    const maxX = Math.max(margin, w - margin);
    const minY = Math.max(margin, header + margin);
    const maxY = Math.max(minY, h - footer - margin);
    x = Math.max(minX, Math.min(maxX, x));
    y = Math.max(minY, Math.min(maxY, y));
  } catch {}
  return { pageId: info.pageId, x, y };
}

// Add element immediately to the most visible page at a visible point
function addElementToVisiblePage(type){
  const pt = getVisibleInsertionPoint();
  if (!pt) { pendingAddType = type; placePendingAt(40, 40); return; }
  Model.document.currentPageId = pt.pageId;
  pendingAddType = type;
  placePendingAt(pt.x, pt.y, pt.pageId);
}

// Internal guard to suppress click-add when a drag from the palette just occurred
let __addingByDrag = false;

let drag = null; // {id, start:{x,y}, orig:{...}, descendants?: Map}
let dragMaybe = null; // tentative single-element drag starter
let resize = null; // {id, start:{x,y}, orig:{...}, mode:'n|s|e|w|ne|nw|se|sw'}
const Controller = { snapState: { x:null, y:null }, suppressReflow: 0 };
let dragSelection = null; // { startBounds, starts: Map }
let resizeSelectionState = null; // { handle, startBounds, starts: Map }
let rotateSelectionState = null; // { startBounds, center:{x,y}, startAngle, starts: Map(id->startRotate) }

function getDescendantIds(rootId){
  const page = getCurrentPage();
  const out = [];
  const queue = [rootId];
  const seen = new Set([rootId]);
  while (queue.length){
    const cur = queue.shift();
    page.elements.forEach(e => {
      if (e.parentId === cur && !seen.has(e.id)){
        out.push(e.id);
        seen.add(e.id);
        queue.push(e.id);
      }
    });
  }
  return out;
}

function isElementHidden(el){
  try {
    const a = el && el.attrs ? el.attrs : {};
    if (a && (a.hidden === true || a.hidden === 'true')) return true;
    const st = String(a && a.style ? a.style : '');
    if (/display\s*:\s*none/i.test(st)) return true;
  } catch {}
  return false;
}

function reflowStacks(page){
  // Cross-page stack reflow for elements that opt-in via stackByPage.
  // 1) Lay out visible stackers top-to-bottom within each page
  // 2) If an item would overflow the page, move it to the next page and continue
  // 3) Allow elements to move forward AND backward across pages based on space
  // 4) Support an optional pageBreak flag to force element to start on next page
  // 5) After page-level positions are finalized, reflow children inside block containers
  try {
    const doc = Model && Model.document ? Model.document : { pages: [] };
    if (!Array.isArray(doc.pages) || doc.pages.length === 0) return;

    const PADDING_TOP = 16;
    const PADDING_GAP = 16;
    const PADDING_BOTTOM = 16;
    const HEADER_H = Number((Model && Model.document && Model.document.headerHeight) || 0);
    const FOOTER_H = Number((Model && Model.document && Model.document.footerHeight) || 0);

    function getLogicalPageHeightPx(p){
      try {
        const node = typeof getPageNode === 'function' ? getPageNode(p.id) : null;
        if (!node) return 0;
        const z = (typeof getZoom === 'function') ? (getZoom() || 1) : 1;
        return Math.round(node.getBoundingClientRect().height / (z || 1));
      } catch { return 0; }
    }

    function findPageIndexByElementId(eid){
      for (let i = 0; i < doc.pages.length; i++){
        const p = doc.pages[i];
        if ((p.elements || []).some(el => el && el.id === eid)) return i;
      }
      return -1;
    }

    // Collect all descendants (children, grandchildren, …) of a container across all pages
    function collectDescendants(rootId){
      const out = [];
      const queue = [rootId];
      const seen = new Set([rootId]);
      while (queue.length){
        const parent = queue.shift();
        for (let i = 0; i < doc.pages.length; i++){
          const pg = doc.pages[i];
          for (const el of (pg.elements || [])){
            if (!el) continue;
            if (el.parentId === parent && !seen.has(el.id)){
              out.push(el);
              seen.add(el.id);
              queue.push(el.id);
            }
          }
        }
      }
      return out;
    }

    const changedPageIds = new Set();
    let createdPages = false;
    let deletedPages = false;

    // Build a single, ordered list of all visible root-level stackers across pages.
    const allStackers = [];
    for (let pi = 0; pi < doc.pages.length; pi++){
      const p = doc.pages[pi];
      const locals = (p.elements || [])
  .filter(e => e && e.stackByPage === true && !e.freeMove && !e.parentId && !isElementHidden(e) && !e.repeatOnAllPages)
        .sort((a,b) => (a.y - b.y));
      locals.forEach(el => allStackers.push(el));
    }

    // Helper to ensure a page exists at index and return it
    const ensurePage = (index) => {
      while (doc.pages.length <= index){
        const newPage = createPage(`Page ${doc.pages.length + 1}`);
        doc.pages.push(newPage);
        createdPages = true;
      }
      return doc.pages[index];
    };

    // Lay out the global sequence into pages from the start, allowing backward moves
    let pi = 0;
    let p = ensurePage(pi);
    let pageHeight = getLogicalPageHeightPx(p);
    let limit = Math.max(0, pageHeight - FOOTER_H - PADDING_BOTTOM);
    let y = PADDING_TOP + HEADER_H;

    for (const el of allStackers){
      const h = Math.max(0, Number(el.h || 0));
      const wantsBreak = !!(el.pageBreak === true || el.pageBreak === 'true');

      // Forced page break before this element (unless it's already at the top of a fresh page)
      if (wantsBreak && y !== (PADDING_TOP + HEADER_H)){
        pi += 1; p = ensurePage(pi);
        pageHeight = getLogicalPageHeightPx(p);
        limit = Math.max(0, pageHeight - FOOTER_H - PADDING_BOTTOM);
        y = PADDING_TOP + HEADER_H;
      }

      // If it would overflow, advance pages until it fits or we've started a new page
      while (y + h > limit){
        pi += 1; p = ensurePage(pi);
        pageHeight = getLogicalPageHeightPx(p);
        limit = Math.max(0, pageHeight - FOOTER_H - PADDING_BOTTOM);
        y = PADDING_TOP + HEADER_H;
        // If the element itself is taller than a page, place it at the top and allow overflow
        if (h > (limit - (PADDING_TOP + HEADER_H))) break;
      }

      // Move element to the target page if needed
      const curIdx = findPageIndexByElementId(el.id);
      if (curIdx !== pi && curIdx !== -1){
        const from = doc.pages[curIdx];
        const idx = from.elements.findIndex(x => x && x.id === el.id);
        if (idx !== -1) from.elements.splice(idx, 1);
        changedPageIds.add(from.id);

        // Move all descendants with the block as well so they stay visible
        if (el.type === 'block'){
          const descendants = collectDescendants(el.id);
          for (const d of descendants){
            const dFromIdx = findPageIndexByElementId(d.id);
            if (dFromIdx !== -1){
              const fromPg = doc.pages[dFromIdx];
              const di = fromPg.elements.findIndex(x => x && x.id === d.id);
              if (di !== -1) fromPg.elements.splice(di, 1);
              changedPageIds.add(fromPg.id);
            }
            if (!p.elements.some(x => x && x.id === d.id)) p.elements.push(d);
            changedPageIds.add(p.id);
          }
        }

        if (!p.elements.some(x => x && x.id === el.id)) p.elements.push(el);
        changedPageIds.add(p.id);
      } else {
        // Element already on target page; ensure it's present in elements list
        if (!p.elements.some(x => x && x.id === el.id)) {
          p.elements.push(el);
          changedPageIds.add(p.id);
        }
      }

      // Position element within the page
      el.y = y;
      y += h + PADDING_GAP;
      changedPageIds.add(p.id);
    }

    // Remove trailing empty pages (only at the end to be safe)
    for (let i = doc.pages.length - 1; i >= 0 && doc.pages.length > 1; i--){
      const pg = doc.pages[i];
      const hasAnyElements = Array.isArray(pg.elements) && pg.elements.length > 0;
      if (hasAnyElements) break; // stop at first non-empty from the end
      const removed = doc.pages.pop();
      deletedPages = true;
      // Fix currentPageId if we removed the current one
      if (removed && removed.id === Model.document.currentPageId){
        const newIdx = Math.min(doc.pages.length - 1, i - 1);
        const safeIdx = newIdx >= 0 ? newIdx : 0;
        Model.document.currentPageId = doc.pages[safeIdx]?.id || doc.pages[0].id;
      }
    }

    // After page-level reflow, stack children within blocks on affected pages
    const affectedPages = Array.from(changedPageIds).map(id => doc.pages.find(p => p.id === id)).filter(Boolean);
    const pagesToProcess = affectedPages.length ? affectedPages : [page || getCurrentPage()];
    pagesToProcess.forEach((pg) => {
      const blocks = (pg.elements || []).filter(e => e && e.type === 'block');
      blocks.forEach(b => {
        if (!b.stackChildren) return;
        const kids = pg.elements
          .filter(e => e && e.parentId === b.id && e.type !== 'line' && !isElementHidden(e))
          .sort((a,bm) => (a.y - bm.y));
        let y = 8;
        kids.forEach(k => { k.y = b.y + y; y += (k.h || 0) + 8; });
      });
    });

    // Render only the pages that changed; if structure changed, rebuild the list
    if (changedPageIds.size || createdPages || deletedPages){
      try {
        if (createdPages || deletedPages){
          renderPagesList();
        } else {
          changedPageIds.forEach((pid) => {
            const pg = doc.pages.find(p => p.id === pid);
            if (pg) renderPage(pg);
          });
        }
      } catch {}
    }
  } catch {}
}

// expose for userFunctions
window.reflowStacks = reflowStacks;

// ---------- Block parenting helpers ----------
function elementBounds(el){ return { x: el.x || 0, y: el.y || 0, w: el.w || 0, h: el.h || 0 }; }
function rectContainsPoint(r, px, py){ return px >= r.x && px <= (r.x + r.w) && py >= r.y && py <= (r.y + r.h); }
/** Assign parentId for given element ids when their centers fall inside a block; clear when outside. */
function reparentIntoBlocks(page, ids){
  if (!page) page = getCurrentPage();
  const blocks = page.elements.filter(e => e.type === 'block');
  if (!blocks.length) return;
  // Prefer visually topmost (highest z) when multiple blocks overlap
  const pickHost = (cx, cy) => {
    let host = null; let bestZ = -Infinity;
    for (const b of blocks){
      const r = elementBounds(b);
      if (rectContainsPoint(r, cx, cy)){
        const z = Number(b.z || 0);
        if (z >= bestZ){ bestZ = z; host = b; }
      }
    }
    return host;
  };
  ids.forEach(id => {
    const idx = page.elements.findIndex(e => e.id === id);
    if (idx === -1) return;
    const el = page.elements[idx];
    if (!el || el.type === 'block') return; // don't parent blocks into blocks here
    const r = elementBounds(el);
    const cx = r.x + r.w/2; const cy = r.y + r.h/2;
    const host = pickHost(cx, cy);
    const nextParentId = host ? host.id : null;
    if ((el.parentId || null) !== nextParentId){
      // Mutate in place to be consistent with live gesture updates
      el.parentId = nextParentId;
      page.elements[idx] = el;
    }
  });
}

// Reparent root-level freeMove elements across pages when their centers move into another page.
function reparentFreeMoveAcrossPages(ids){
  try {
    if (!Array.isArray(ids) || ids.length === 0) return;
    const selIds = [...new Set(ids)];
    const z = getZoom ? (getZoom() || 1) : 1;
    // Collect page DOM rects once
    const pages = (Model.document.pages || []).map(p => ({ p, node: document.querySelector(`.page-wrapper[data-page-id="${p.id}"] .page`) })).filter(o => o.node);
    const pageRects = pages.map(o => ({ id:o.p.id, rect:o.node.getBoundingClientRect() }));
    const prevSelection = (typeof selectedIds !== 'undefined') ? [...selectedIds] : [];
    let lastTargetPageId = null;
    selIds.forEach((id) => {
      const m = getElementById ? getElementById(id) : null;
      if (!m || !m.freeMove || m.parentId) return; // only freeMove roots
      // Find current page containing the model
      const fromPage = Model.document.pages.find(pp => (pp.elements || []).some(el => el && el.id === id));
      if (!fromPage) return;
      const curNode = document.querySelector(`.page-wrapper[data-page-id="${fromPage.id}"] .page`);
      if (!curNode) return;
      const pr = curNode.getBoundingClientRect();
      const cx = pr.left + (m.x + ((m.w || 0) / 2)) * z;
      const cy = pr.top + (m.y + ((m.h || 0) / 2)) * z;
      const target = pageRects.find(prx => cy >= prx.rect.top && cy <= prx.rect.bottom && cx >= prx.rect.left && cx <= prx.rect.right);
      if (!target || target.id === fromPage.id) return;
      const toPage = Model.document.pages.find(pp => pp && pp.id === target.id);
      if (!toPage) return;
      // Move the element
      const idx = fromPage.elements.findIndex(el => el && el.id === id);
      if (idx === -1) return;
      const [moved] = fromPage.elements.splice(idx, 1);
      // Adjust coordinates so visual screen position remains the same after reparent
      try {
        const targetRect = document.querySelector(`.page-wrapper[data-page-id="${toPage.id}"] .page`)?.getBoundingClientRect();
        if (targetRect && pr){
          const dxLogical = (pr.left - targetRect.left) / z;
          const dyLogical = (pr.top - targetRect.top) / z;
          moved.x = (moved.x || 0) + dxLogical;
          moved.y = (moved.y || 0) + dyLogical;
          if (typeof moved.x2 === 'number') moved.x2 += dxLogical;
          if (typeof moved.y2 === 'number') moved.y2 += dyLogical;
        }
      } catch {}
      toPage.elements.push(moved);
      lastTargetPageId = toPage.id;
      // If moving a block, move its descendants too so they remain visible
      if (moved && moved.type === 'block' && typeof collectDescendants === 'function'){
        const desc = collectDescendants(moved.id);
        for (const d of desc){
          const dFromPage = Model.document.pages.find(pp => (pp.elements || []).some(el => el && el.id === d.id));
          if (!dFromPage || dFromPage === toPage) continue;
          const di = dFromPage.elements.findIndex(el => el && el.id === d.id);
          if (di !== -1){
            const [dm] = dFromPage.elements.splice(di, 1);
            if (!toPage.elements.some(el => el && el.id === dm.id)) toPage.elements.push(dm);
          }
        }
      }
    });
    // Re-render after any moves
    renderAll && renderAll();
    if (prevSelection && prevSelection.length && typeof setSelection === 'function') setSelection(prevSelection);
  } catch {}
}

function onMouseDown(e){
  // Ignore canvas interactions while a picker is active (element/style picker)
  if (window.__PICKING) { e.preventDefault(); return; }
  // Prevent moving/resizing when edit mode is off, but allow clicking/selection
  if (!Model.document.editMode) return;
  // If currently editing text/content, do not initiate drags
  const act = document.activeElement;
  if (act && (act.isContentEditable || act.tagName === 'INPUT' || act.tagName === 'TEXTAREA')) return;
  const target = e.target.closest('.element');
  // Avoid initiating drag on the first click of a double-click for text-like elements
  if (target && e.detail >= 2 && (target.classList.contains('text') || target.classList.contains('field') || target.classList.contains('rect'))){
    // Cancel any pending or active drag when entering edit mode via double-click
    drag = null; dragMaybe = null; dragSelection = null; resize = null;
    return; // let dblclick handler take over to enter edit mode
  }
  if (target && target.isContentEditable) { drag = null; dragMaybe = null; return; } // don't start drag when editing text
  // If potential target is freeMove we want unclamped start coords so deltas stay consistent when leaving page
  let unclamped = false;
  try {
    const tgtNode = e.target.closest('.element');
    const id = tgtNode ? tgtNode.dataset.id : null;
    if (id){ const m = getElementById(id); if (m && m.freeMove) unclamped = true; }
  } catch{}
  const pt = getCanvasPoint(e, getPageNode(), !unclamped);
  if (pendingAddType){ placePendingAt(pt.x, pt.y); return; }
  if (target){
    const id = target.dataset.id;
    console.log('[MOUSE] down on element', id);
    const page = getCurrentPage();
    const model = page.elements.find(el => el.id === id);
    // Respect locked layers
    if (model && model.attrs && (model.attrs.locked === true || model.attrs.locked === 'true')){
      // Allow selection but block drag/resize
      setSelection([id]);
      e.preventDefault();
      return;
    }
    // Alt-drag duplicate: when starting a drag with Alt pressed, clone selection first
    if ((e.altKey || e.metaKey && e.shiftKey) && (selectedIds.has(id) || selectedIds.size === 0)){
      // If nothing selected, select target first then clone
      if (!selectedIds.has(id)) setSelection([id]);
      copySelection(0); // duplicate at same position
      // Keep newly created clones selected and start dragging them
      // Offset start so immediate movement will be visible
    }
    const append = e.shiftKey || e.ctrlKey || e.metaKey;
    const toggle = e.ctrlKey || e.metaKey;
    if (!append && !toggle && model?.groupId) { setSelection(getElementsByGroup(model.groupId).map(e=>e.id)); }
    else if (toggle) toggleSelection(id);
    else if (append) addToSelection(id);
    else {
      setSelection([id]);
      // Fallback behavior: if clicking on table container and we have a last cell selection, restore it
      if (model?.type === 'table' && lastTableSel && lastTableSel.tableId === id) {
        setTableSelection(lastTableSel.tableId, lastTableSel.r0, lastTableSel.c0, lastTableSel.r1, lastTableSel.c1);
      }
    }
    const mode = getResizeMode(e, target, model);
    if (mode) {
      // snapshot before resize starts for undo
      commitHistory('resize');
      resize = { id, start: pt, orig: deepClone(model), mode };
      console.log(`[GESTURE] resize:start id=${id} mode=${mode}`);
    } else {
      if (selectedIds.has(id) && selectedIds.size > 1){
        const starts = new Map();
        [...selectedIds].forEach(sid => starts.set(sid, deepClone(getElementById(sid))));
        const startBounds = getSelectionBounds();
        // snapshot before move starts for undo
        commitHistory('move');
        // keep pointer offset to avoid jumping to top-left
        const pointerOffset = { ox: pt.x - startBounds.x, oy: pt.y - startBounds.y };
        dragSelection = { startBounds, starts, pointerOffset };
        console.log(`[GESTURE] multi-drag:start count=${selectedIds.size}`);
      } else {
        // Defer starting a drag until the pointer actually moves beyond a threshold
        // Capture possible descendants for blocks to move them together
        let descendants = null;
        if (model && model.type === 'block'){
          const ids = getDescendantIds(model.id);
          const map = new Map();
          ids.forEach(cid => { const cm = getElementById(cid); if (cm) map.set(cid, deepClone(cm)); });
          descendants = map;
        }
        dragMaybe = { id, start: pt, orig: deepClone(model), descendants };
        console.log(`[GESTURE] drag:maybe id=${id} x=${pt.x} y=${pt.y}`);
      }
    }
    // hide actions while dragging
    elementActions().classList.add('hidden');
    e.preventDefault();
  } else {
    clearSelection();
  }
}

function onMouseMove(e){
  // Safety: if no mouse button is down but a gesture is active, end it
  if ((e.buttons === 0 || e.type === 'mouseleave') && (drag || resize || dragSelection || resizeSelectionState || rotateSelectionState || dragMaybe)){
    onMouseUp();
    return;
  }
  // If editing text/content and no gesture is active, ignore move events
  const activeEl = document.activeElement;
  const isEditing = !!(activeEl && (activeEl.isContentEditable || activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA'));
  if (isEditing && !drag && !resize && !dragSelection && !resizeSelectionState && !rotateSelectionState && !dragMaybe) return;
  if (!drag && !resize && !dragSelection && !resizeSelectionState && !rotateSelectionState && !dragMaybe) return;
  // Determine if current gesture allows overflow (all active elements freeMove)
  let unclamp = false;
  if (dragSelection){
    try { unclamp = [...selectedIds].length && [...selectedIds].every(id => { const m = getElementById(id); return m && m.freeMove; }); } catch {}
  } else if (drag){
    try { const m = getElementById(drag.id); unclamp = !!(m && m.freeMove); } catch {}
  } else if (resize){
    try { const m = getElementById(resize.id); unclamp = !!(m && m.freeMove); } catch {}
  } else if (resizeSelectionState){
    try { unclamp = [...selectedIds].length && [...selectedIds].every(id => { const m = getElementById(id); return m && m.freeMove; }); } catch {}
  }
  const pt = getCanvasPoint(e, getPageNode(), !unclamp);
  const page = getCurrentPage();
  // Promote tentative drag if moved far enough
  if (!drag && dragMaybe){
    const dx0 = Math.abs(pt.x - dragMaybe.start.x);
    const dy0 = Math.abs(pt.y - dragMaybe.start.y);
    if (dx0 >= 3 || dy0 >= 3){
      console.log(`[GESTURE] drag:promote id=${dragMaybe.id}`);
      commitHistory('move');
      drag = dragMaybe; dragMaybe = null;
    }
  }
  if (rotateSelectionState){
    const sb = rotateSelectionState.startBounds;
    const cx = sb.x + sb.w/2; const cy = sb.y + sb.h/2;
    const curAngle = Math.atan2(pt.y - cy, pt.x - cx);
    const deltaRad = curAngle - rotateSelectionState.startAngle;
    const deltaDeg = deltaRad * (180/Math.PI);
    [...selectedIds].forEach(id => {
      const start = rotateSelectionState.starts.get(id);
      const out = deepClone(start);
      if (out.type !== 'line'){
        out.styles = out.styles || {};
        out.styles.rotate = (start.styles?.rotate || 0) + deltaDeg;
      } else {
        // Rotate line endpoints around selection center
        const cos = Math.cos(deltaRad), sin = Math.sin(deltaRad);
        const x1 = start.x, y1 = start.y; const x2 = start.x2 ?? start.x; const y2 = start.y2 ?? start.y;
        const rx1 = cx + (x1 - cx) * cos - (y1 - cy) * sin;
        const ry1 = cy + (x1 - cx) * sin + (y1 - cy) * cos;
        const rx2 = cx + (x2 - cx) * cos - (y2 - cy) * sin;
        const ry2 = cy + (x2 - cx) * sin + (y2 - cy) * cos;
        out.x = rx1; out.y = ry1; out.x2 = rx2; out.y2 = ry2;
      }
      const idx = page.elements.findIndex(e => e.id === id); if (idx !== -1) page.elements[idx] = out;
      const node = document.querySelector(`.page [data-id="${id}"]`); if (node) applyElementStyles(node, out);
    });
    updateSelectionBox();
    // Live reparenting for freeMove multi-drag root elements
    try { reparentFreeMoveAcrossPages([...selectedIds]); } catch {}
    return;
  }
  if (dragSelection){
    const ox = dragSelection.pointerOffset?.ox || 0;
    const oy = dragSelection.pointerOffset?.oy || 0;
    const dx = pt.x - (dragSelection.startBounds.x + ox);
    const dy = pt.y - (dragSelection.startBounds.y + oy);
  const tentative = { x: dragSelection.startBounds.x + dx, y: dragSelection.startBounds.y + dy, w: dragSelection.startBounds.w, h: dragSelection.startBounds.h };
    // Consistent snapping for movement
    const snapped = snapSelectionBounds(tentative, [...selectedIds], undefined, INTERACTIVE_SNAP);
    const snapDx = snapped.x - tentative.x; const snapDy = snapped.y - tentative.y;
    [...selectedIds].forEach(id => {
      const start = dragSelection.starts.get(id);
      const m = deepClone(start);
      m.x = start.x + dx + snapDx; m.y = start.y + dy + snapDy;
      // Clamp if this element is NOT freeMove
      if (!m.freeMove){
        const pageNode = getPageNode();
        if (pageNode){
          const pw = pageNode.clientWidth; const ph = pageNode.clientHeight;
          if (m.type === 'line' && typeof m.x2 === 'number'){
            const minX = Math.min(m.x, m.x2), maxX = Math.max(m.x, m.x2);
            const minY = Math.min(m.y, m.y2), maxY = Math.max(m.y, m.y2);
            const offX = Math.min(0, minX) + Math.max(0, maxX - pw);
            const offY = Math.min(0, minY) + Math.max(0, maxY - ph);
            m.x -= offX; m.y -= offY; m.x2 -= offX; m.y2 -= offY;
          } else {
            if (m.x < 0) m.x = 0;
            if (m.y < 0) m.y = 0;
            if (m.x + (m.w||0) > pw) m.x = Math.max(0, pw - (m.w||0));
            if (m.y + (m.h||0) > ph) m.y = Math.max(0, ph - (m.h||0));
          }
        }
      }
      if (m.type === 'line' && typeof m.x2 === 'number'){ m.x2 = (start.x2||start.x) + dx + snapDx; m.y2 = (start.y2||start.y) + dy + snapDy; }
      const idx = page.elements.findIndex(el => el.id === id); if (idx !== -1) page.elements[idx] = m;
      const node = document.querySelector(`.page [data-id="${id}"]`); if (node) applyElementStyles(node, m);
    });
    showGuidesForBounds(snapped, getPageNode());
    updateSelectionBox();
    // Live reparent for single freeMove drag
    try { if (drag && m.freeMove && !m.parentId) reparentFreeMoveAcrossPages([drag.id]); } catch{}
    return;
  }
  // If we're not actively dragging or resizing a single element, bail out.
  if (!drag && !resize) {
    return;
  }
  const active = drag || resize; // guaranteed non-null here
  const idx = page.elements.findIndex(el => el.id === active.id); if (idx === -1) return;
  const dx = pt.x - active.start.x; const dy = pt.y - active.start.y;
  const m = deepClone(active.orig);
  if (resize) {
    applyResize(m, dx, dy, resize.mode);
    // Apply snapping to single element resize
    const tentativeBounds = getBoundsForModel(m);
    // Provide preference so snapping uses the active resized edges
    const prefer = { x: resize.mode.includes('e') ? 'right' : resize.mode.includes('w') ? 'left' : undefined,
                     y: resize.mode.includes('s') ? 'bottom' : resize.mode.includes('n') ? 'top' : undefined };
    // Consistent snapping for resize (do not clamp to page when freeMove)
    const snappedBounds = snapSelectionBounds(tentativeBounds, [active.id], prefer, INTERACTIVE_SNAP);
    // Instead of shifting the whole element (which moves the opposite edge),
    // adjust the resized edge to the snapped coordinate.
    const tentLeft = tentativeBounds.x;
    const tentRight = tentativeBounds.x + tentativeBounds.w;
    const tentTop = tentativeBounds.y;
    const tentBottom = tentativeBounds.y + tentativeBounds.h;
    const snapLeft = snappedBounds.x;
    const snapRight = snappedBounds.x + snappedBounds.w;
    const snapTop = snappedBounds.y;
    const snapBottom = snappedBounds.y + snappedBounds.h;

    // Horizontal adjustment
    if (resize.mode.includes('e')) {
      const deltaRight = snapRight - tentRight;
      if (m.type === 'line' && typeof m.x2 === 'number'){
        m.x2 += deltaRight;
      } else {
        m.w = Math.max(10, (m.w || 0) + deltaRight);
      }
    } else if (resize.mode.includes('w')) {
      const newLeft = snapLeft;
      const newWidth = Math.max(10, tentRight - newLeft);
      if (m.type === 'line' && typeof m.x2 === 'number'){
        // Move left endpoint while keeping right endpoint fixed
        const rightX = Math.max(m.x, m.x2);
        const leftWas = Math.min(m.x, m.x2);
        const shift = newLeft - tentLeft;
        if (m.x <= m.x2) { m.x += shift; } else { m.x2 += shift; }
      } else {
        m.x = newLeft; m.w = newWidth;
      }
    }

    // Vertical adjustment
    if (resize.mode.includes('s')) {
      const deltaBottom = snapBottom - tentBottom;
      if (m.type === 'line' && typeof m.y2 === 'number'){
        m.y2 += deltaBottom;
      } else {
        m.h = Math.max(10, (m.h || 0) + deltaBottom);
      }
    } else if (resize.mode.includes('n')) {
      const newTop = snapTop;
      const newHeight = Math.max(10, tentBottom - newTop);
      if (m.type === 'line' && typeof m.y2 === 'number'){
        const topWas = Math.min(m.y, m.y2);
        const shift = newTop - tentTop;
        if (m.y <= m.y2) { m.y += shift; } else { m.y2 += shift; }
      } else {
        m.y = newTop; m.h = newHeight;
      }
    }
    showGuidesForBounds(snappedBounds, getPageNode());
  } else {
  if (m.type === 'line') { m.x += dx; m.y += dy; m.x2 += dx; m.y2 += dy; } else { m.x += dx; m.y += dy; }
    // snap and show guides for single element
    const tentative = getBoundsForModel(m);
    // Consistent snapping for movement
    const snapped = snapSelectionBounds(tentative, [active.id], undefined, INTERACTIVE_SNAP);
    const snapDx = snapped.x - tentative.x; const snapDy = snapped.y - tentative.y;
    if (m.type === 'line' && typeof m.x2 === 'number'){
      m.x += snapDx; m.y += snapDy; m.x2 += snapDx; m.y2 += snapDy;
    } else { m.x += snapDx; m.y += snapDy; }
    // Clamp if not freeMove
    if (!m.freeMove){
      const pageNode = getPageNode();
      if (pageNode){
        const pw = pageNode.clientWidth; const ph = pageNode.clientHeight;
        if (m.type === 'line' && typeof m.x2 === 'number'){
          const minX = Math.min(m.x, m.x2), maxX = Math.max(m.x, m.x2);
            const minY = Math.min(m.y, m.y2), maxY = Math.max(m.y, m.y2);
            const offX = Math.min(0, minX) + Math.max(0, maxX - pw);
            const offY = Math.min(0, minY) + Math.max(0, maxY - ph);
            m.x -= offX; m.y -= offY; m.x2 -= offX; m.y2 -= offY;
        } else {
          if (m.x < 0) m.x = 0;
          if (m.y < 0) m.y = 0;
          if (m.x + (m.w||0) > pw) m.x = Math.max(0, pw - (m.w||0));
          if (m.y + (m.h||0) > ph) m.y = Math.max(0, ph - (m.h||0));
        }
      }
    }
    showGuidesForBounds(snapped, getPageNode());
    // If dragging a block, translate its descendants by the block's total displacement (including snapping)
    if (active.descendants && active.orig && active.orig.type === 'block'){
      const totalDx = (m.x - active.orig.x);
      const totalDy = (m.y - active.orig.y);
      active.descendants.forEach((startChild, childId) => {
        const childIdx = page.elements.findIndex(el => el.id === childId);
        if (childIdx === -1) return;
        const ch = deepClone(startChild);
        if (ch.type === 'line' && typeof ch.x2 === 'number'){
          ch.x += totalDx; ch.y += totalDy; ch.x2 += totalDx; ch.y2 += totalDy;
        } else {
          ch.x += totalDx; ch.y += totalDy;
        }
        page.elements[childIdx] = ch;
        const nodeCh = document.querySelector(`.page [data-id="${childId}"]`);
        if (nodeCh) applyElementStyles(nodeCh, ch);
      });
    }
  }
  page.elements[idx] = m;
  applyElementStyles(document.querySelector(`.page [data-id="${active.id}"]`), m);
  updateFormatToolbarVisibility(); positionElementActions(); updateSelectionBox();
}

function onMouseUp(){
  // Detect whether a gesture actually occurred (move/resize/rotate)
  const hadGesture = !!drag || !!resize || !!dragSelection || !!resizeSelectionState || !!rotateSelectionState;
  const type = dragSelection ? 'multi-drag' : (resize ? 'resize' : (drag ? 'drag' : (rotateSelectionState ? 'rotate' : (dragMaybe ? 'dragMaybe' : 'none'))));
  if (hadGesture) {
    console.log(`[GESTURE] ${type}:end`);
  } else if (dragMaybe) {
    console.log('[GESTURE] drag:cancel');
  }
  // After a move/resize/rotate, reparent elements into blocks (if applicable) and reflow stacks
  if (hadGesture){
    const page = getCurrentPage();
    try {
      // Preserve current selection through the side-effects below
      const __prevSelection = [...selectedIds];
      // First reparent freeMove elements across pages (prevents reflow from relocating them)
      reparentFreeMoveAcrossPages([...selectedIds]);
      // Now reparent into blocks and reflow only for non-freeMove stackers
      reparentIntoBlocks(getCurrentPage(), [...selectedIds]);
      reflowStacks(getCurrentPage());
      renderAll();
      // Restore selection that existed prior to re-render
      if (__prevSelection && __prevSelection.length) setSelection(__prevSelection);
    } catch {}
  }
  // History was already captured at gesture start
  if (drag){ drag = null; }
  if (resize){ resize = null; }
  if (dragSelection){ dragSelection = null; }
  if (rotateSelectionState){ rotateSelectionState = null; }
  // Clear any pending, not-yet-promoted drag from a prior click to avoid accidental moves
  if (dragMaybe){ dragMaybe = null; }
  // hide guides and reshow actions
  hideGuides();
  positionElementActions();
  Controller.snapState = { x: null, y: null };
}

/* ----------------------- Resize helpers ----------------------- */
function getResizeMode(e, node){
  // Provide visual resize cursors when near element edges (single selection cue)
  const rect = node.getBoundingClientRect();
  const margin = 6;
  const x = e.clientX - rect.left; const y = e.clientY - rect.top;
  const left = x < margin; const right = x > rect.width - margin;
  const top = y < margin; const bottom = y > rect.height - margin;
  if ((left && top)) return 'nw';
  if ((right && top)) return 'ne';
  if ((left && bottom)) return 'sw';
  if ((right && bottom)) return 'se';
  if (top) return 'n'; if (bottom) return 's'; if (left) return 'w'; if (right) return 'e';
  return null;
}

function updateResizeCursor(e, node){
  // In view mode, never show resize cursors
  if (!Model || !Model.document || !Model.document.editMode){ node.style.cursor = ''; return; }
  const id = node.dataset.id; const page = getCurrentPage();
  const m = page?.elements.find(el => el.id === id) || {};
  const mode = getResizeMode(e, node, m);
  const map = { n: 'ns-resize', s:'ns-resize', e:'ew-resize', w:'ew-resize', ne:'nesw-resize', sw:'nesw-resize', nw:'nwse-resize', se:'nwse-resize' };
  node.style.cursor = map[mode] || '';
}

function applyResize(m, dx, dy, mode){
  if (m.type === 'line') return;
  const minW = 10, minH = 10;
  let minTableW = minW, minTableH = minH;
  if (m.type === 'table'){
    minTableW = (m.colWidths || []).reduce((a,b)=>a+b, 0) || minW;
    minTableH = (m.rowHeights || []).reduce((a,b)=>a+b, 0) || minH;
  }
  const clampW = (w) => Math.max(m.type==='table'?minTableW:minW, w);
  const clampH = (h) => Math.max(m.type==='table'?minTableH:minH, h);
  if (mode.includes('e')) m.w = clampW((m.w || 0) + dx);
  if (mode.includes('s')) m.h = clampH((m.h || 0) + dy);
  if (mode.includes('w')) { m.x += dx; m.w = clampW((m.w || 0) - dx); }
  if (mode.includes('n')) { m.y += dy; m.h = clampH((m.h || 0) - dy); }
}

/* -------- Selection resize helpers (multi) -------- */
function startSelectionResize(handle, event){
  if (selectedIds.size === 0) return;
  const startBounds = getSelectionBounds(); if (!startBounds) return;
  const pageNode = getPageNode();
  const pt = getCanvasPoint(event, pageNode);
  const starts = new Map();
  [...selectedIds].forEach(id => starts.set(id, deepClone(getElementById(id))));
  if (handle === 'move'){
    const pointerOffset = { ox: pt.x - startBounds.x, oy: pt.y - startBounds.y };
    commitHistory('move');
    dragSelection = { startBounds, starts, pointerOffset };
    return;
  }
  if (handle === 'rotate'){
    const cx = startBounds.x + startBounds.w/2; const cy = startBounds.y + startBounds.h/2;
    const startAngle = Math.atan2(pt.y - cy, pt.x - cx);
    commitHistory('rotate-multi');
    rotateSelectionState = { startBounds, starts, startAngle };
    return;
  }
  resizeSelectionState = { handle, startBounds, starts, startPoint: pt };
}

function applySelectionResize(event){
  if (!resizeSelectionState) return;
  const pageNode = getPageNode();
  const pt = getCanvasPoint(event, pageNode);
  const sb = resizeSelectionState.startBounds;
  const minW = 10, minH = 10; // Allow elements to be resized to minimum size
  let nx = sb.x, ny = sb.y, nw = sb.w, nh = sb.h;
  const h = resizeSelectionState.handle;
  const right = sb.x + sb.w, bottom = sb.y + sb.h;
  if (h.includes('e')) { nw = Math.max(minW, pt.x - sb.x); }
  if (h.includes('s')) { nh = Math.max(minH, pt.y - sb.y); }
  if (h.includes('w')) { nx = Math.min(pt.x, right - minW); nw = Math.max(minW, right - nx); }
  if (h.includes('n')) { ny = Math.min(pt.y, bottom - minH); nh = Math.max(minH, bottom - ny); }
  // Apply snapping to the new bounds before applying transformations
  const tentativeBounds = { x: nx, y: ny, w: nw, h: nh };
  const prefer = { x: resizeSelectionState?.handle?.includes('e') ? 'right' : resizeSelectionState?.handle?.includes('w') ? 'left' : undefined,
                   y: resizeSelectionState?.handle?.includes('s') ? 'bottom' : resizeSelectionState?.handle?.includes('n') ? 'top' : undefined };
  // Consistent snapping for resize
  const snappedBounds = snapSelectionBounds(tentativeBounds, [...selectedIds], prefer, INTERACTIVE_SNAP);
  
  // Adjust only the actively resized edges to the snapped coordinates,
  // keeping the opposite edges anchored to the original selection bounds.
  const tentLeft = tentativeBounds.x;
  const tentRight = tentativeBounds.x + tentativeBounds.w;
  const tentTop = tentativeBounds.y;
  const tentBottom = tentativeBounds.y + tentativeBounds.h;
  const snapLeft = snappedBounds.x;
  const snapRight = snappedBounds.x + snappedBounds.w;
  const snapTop = snappedBounds.y;
  const snapBottom = snappedBounds.y + snappedBounds.h;

  // Horizontal adjustments
  if (h.includes('e')) {
    const deltaRight = snapRight - tentRight;
    nw = Math.max(minW, nw + deltaRight);
  }
  if (h.includes('w')) {
    const newLeft = snapLeft;
    nx = newLeft;
    nw = Math.max(minW, right - nx);
  }

  // Vertical adjustments
  if (h.includes('s')) {
    const deltaBottom = snapBottom - tentBottom;
    nh = Math.max(minH, nh + deltaBottom);
  }
  if (h.includes('n')) {
    const newTop = snapTop;
    ny = newTop;
    nh = Math.max(minH, bottom - ny);
  }
  
  // Recalculate scaling factors with snapped bounds
  const sx = nw / sb.w;
  const sy = nh / sb.h;
  
  const page = getCurrentPage();
  [...selectedIds].forEach(id => {
    const start = resizeSelectionState.starts.get(id);
    const out = deepClone(start);
    if (start.type === 'line' && typeof start.x2 === 'number' && typeof start.y2 === 'number'){
      const rx1 = start.x - sb.x; const ry1 = start.y - sb.y;
      const rx2 = (start.x2 ?? start.x) - sb.x; const ry2 = (start.y2 ?? start.y) - sb.y;
      out.x = nx + rx1 * sx; out.y = ny + ry1 * sy;
      out.x2 = nx + rx2 * sx; out.y2 = ny + ry2 * sy;
    } else {
      const rx = start.x - sb.x; const ry = start.y - sb.y;
      out.x = nx + rx * sx; out.y = ny + ry * sy;
      if (typeof start.w === 'number') out.w = Math.max(minW, (start.w || 0) * sx);
      if (typeof start.h === 'number') out.h = Math.max(minH, (start.h || 0) * sy);
    }
    const idx = page.elements.findIndex(e => e.id === id); if (idx !== -1) page.elements[idx] = out;
    const node = document.querySelector(`.page [data-id="${id}"]`); if (node) applyElementStyles(node, out);
  });
  
  // Show guidelines with snapped bounds
  showGuidesForBounds(snappedBounds, getPageNode());
  
  updateSelectionBox();
}

/* ----------------------- Guides ----------------------- */
function getGuidesNodes(pageNode = getPageNode()) {
  const page = pageNode; if (!page) return {};
  return {
    v: page.querySelector('.guide.v'),
    h: page.querySelector('.guide.h'),
    rect: page.getBoundingClientRect(),
  };
}

function hideGuides(){
  const { v, h } = getGuidesNodes();
  if (v) v.classList.add('hidden');
  if (h) h.classList.add('hidden');
}

// Softer snapping so it feels less aggressive
const SNAP_THRESHOLD = 5; const STICKY_RANGE = 5;
// Use the same interactive snap config for move and resize gestures
const INTERACTIVE_SNAP = { threshold: SNAP_THRESHOLD, sticky: 0, noSticky: true };
function getGuidesForCurrentPage(excludeIds = []){
  const pageNode = getPageNode(); const page = getCurrentPage();
  const v = [0, pageNode.clientWidth/2, pageNode.clientWidth];
  const h = [0, pageNode.clientHeight/2, pageNode.clientHeight];
  page.elements.filter(e => !excludeIds.includes(e.id)).forEach(e => {
    const w = e.w || 0, hgt = e.h || 0; v.push(e.x, e.x + w/2, e.x + w); h.push(e.y, e.y + hgt/2, e.y + hgt);
  });
  return { v, h, pageNode };
}

function getBoundsForModel(m){
  if (m.type === 'line' && typeof m.x2 === 'number' && typeof m.y2 === 'number'){
    const left = Math.min(m.x, m.x2), top = Math.min(m.y, m.y2);
    const right = Math.max(m.x, m.x2), bottom = Math.max(m.y, m.y2);
    return { x:left, y:top, w:right-left, h:bottom-top };
  }
  return { x:m.x, y:m.y, w:m.w || 0, h:m.h || 0 };
}
function snapSelectionBounds(b, excludeIds = [], prefer, options){
  // Allow toggling snap off via UI
  if (typeof SNAP_ENABLED !== 'undefined' && !SNAP_ENABLED) {
    return { x: b.x, y: b.y, w: b.w, h: b.h };
  }
  const { v, h } = getGuidesForCurrentPage(excludeIds);
  const threshold = options?.threshold ?? SNAP_THRESHOLD;
  const stickyRange = options?.sticky ?? STICKY_RANGE;
  const disableSticky = options?.noSticky === true;
  const left=b.x, cx=b.x+b.w/2, right=b.x+b.w; const top=b.y, cy=b.y+b.h/2, bottom=b.y+b.h;
  const targetsX = prefer?.x === 'left' ? [left] : prefer?.x === 'center' ? [cx] : prefer?.x === 'right' ? [right] : [left,cx,right];
  const targetsY = prefer?.y === 'top' ? [top] : prefer?.y === 'middle' ? [cy] : prefer?.y === 'bottom' ? [bottom] : [top,cy,bottom];
  const nx = findNearest(v, targetsX, threshold); const ny = findNearest(h, targetsY, threshold);
  let outX = b.x, outY = b.y;
  // Only apply sticky snapping when no preference is set (i.e., moving) or when sticky matches preferred edge
  const canStickX = !disableSticky && (!prefer || (Math.min(...targetsX.map(t => Math.abs(t - (Controller.snapState.x ?? Infinity)))) <= stickyRange));
  const canStickY = !disableSticky && (!prefer || (Math.min(...targetsY.map(t => Math.abs(t - (Controller.snapState.y ?? Infinity)))) <= stickyRange));
  if (nx || (Controller.snapState.x!=null && canStickX)){
    const [c,whichIdx] = nx || [Controller.snapState.x, (targetsX.length===1?0:1)];
    // Map whichIdx back to left/center/right index against [left,cx,right]
    let which = whichIdx;
    if (targetsX.length !== 3){
      // derive which from preferred
      which = prefer?.x === 'left' ? 0 : prefer?.x === 'center' ? 1 : prefer?.x === 'right' ? 2 : 1;
    }
    outX = which===0? c : (which===1? c - b.w/2 : c - b.w); Controller.snapState.x = c;
  }
  if (ny || (Controller.snapState.y!=null && canStickY)){
    const [c,whichIdx] = ny || [Controller.snapState.y, (targetsY.length===1?0:1)];
    let which = whichIdx;
    if (targetsY.length !== 3){
      which = prefer?.y === 'top' ? 0 : prefer?.y === 'middle' ? 1 : prefer?.y === 'bottom' ? 2 : 1;
    }
    outY = which===0? c : (which===1? c - b.h/2 : c - b.h); Controller.snapState.y = c;
  }
  return { x: outX, y: outY, w: b.w, h: b.h };
}
function showGuidesForBounds(b, pageNode){
  if (typeof GUIDES_ENABLED !== 'undefined' && !GUIDES_ENABLED) { hideGuides(); return; }
  const { v, h } = getGuidesNodes(pageNode); if (!v || !h) return;
  // Compute nearest guides and prefer the currently active resize edge if any
  const left = b.x, cx = b.x + b.w/2, right = b.x + b.w;
  const top = b.y, cy = b.y + b.h/2, bottom = b.y + b.h;
  const { v: vg, h: hg } = getGuidesForCurrentPage([...selectedIds]);

  // Determine active edges for visualization
  const mode = (resize && resize.mode) || (resizeSelectionState && resizeSelectionState.handle) || '';
  const preferLeft = !!mode && mode.includes('w');
  const preferRight = !!mode && mode.includes('e');
  const preferTop = !!mode && mode.includes('n');
  const preferBottom = !!mode && mode.includes('s');

  const nx = preferRight ? findNearest(vg, [right], SNAP_THRESHOLD)
           : preferLeft ? findNearest(vg, [left], SNAP_THRESHOLD)
           : findNearest(vg, [left, cx, right], SNAP_THRESHOLD);
  const ny = preferBottom ? findNearest(hg, [bottom], SNAP_THRESHOLD)
           : preferTop ? findNearest(hg, [top], SNAP_THRESHOLD)
           : findNearest(hg, [top, cy, bottom], SNAP_THRESHOLD);

  const vx = nx ? nx[0] : (Controller.snapState.x != null ? Controller.snapState.x : (preferRight ? right : (preferLeft ? left : cx)));
  const vy = ny ? ny[0] : (Controller.snapState.y != null ? Controller.snapState.y : (preferBottom ? bottom : (preferTop ? top : cy)));

  v.style.left = vx + 'px'; v.style.top = '0px'; v.style.height = pageNode.clientHeight + 'px';
  h.style.left = '0px'; h.style.top = vy + 'px'; h.style.width = pageNode.clientWidth + 'px';
  v.classList.remove('hidden'); h.classList.remove('hidden');
}

function findNearest(candidates, targets, threshold){
  let best = null; let bestDist = Infinity; let bestWhich = -1;
  for (let i = 0; i < candidates.length; i++){
    const c = candidates[i];
    for (let t = 0; t < targets.length; t++){
      const d = Math.abs(c - targets[t]);
      if (d <= threshold && d < bestDist) { best = c; bestDist = d; bestWhich = t; }
    }
  }
  return best != null ? [best, bestWhich] : null;
}

/* ----------------------- Selection utilities ----------------------- */
/* getElementById moved to editor.core.js */

function getSelectionBounds(){
  const els = [...selectedIds].map(getElementById).filter(Boolean);
  if (!els.length) return null;
  const left = Math.min(...els.map(e => e.x));
  const top = Math.min(...els.map(e => e.y));
  const right = Math.max(...els.map(e => e.x + (e.w||0)));
  const bottom = Math.max(...els.map(e => e.y + (e.h||0)));
  return { x:left, y:top, w:right-left, h:bottom-top };
}

function applyPatchToSelection(patch, historyLabel = 'update-multi'){
  if (selectedIds.size === 0) return;
  commitHistory(historyLabel);
  const page = getCurrentPage();
  [...selectedIds].forEach(id => {
    const idx = page.elements.findIndex(e => e.id === id);
    if (idx !== -1) page.elements[idx] = deepMerge(page.elements[idx], patch);
  });
  renderPage(page); updateSelectionUI();
}

/* ----------------------- Align/Distribute ----------------------- */
function alignSelection(where){
  if (selectedIds.size < 2) return;
  const p = getCurrentPage(); const ids = [...selectedIds];
  const bounds = getSelectionBounds(); if (!bounds) return;
  commitHistory('align');
  ids.forEach(id => {
    const m = getElementById(id); if (!m) return; const out = deepClone(m);
    if (where === 'left') out.x = bounds.x;
    if (where === 'center') out.x = Math.round(bounds.x + (bounds.w - (m.w||0)) / 2);
    if (where === 'right') out.x = bounds.x + bounds.w - (m.w||0);
    if (where === 'top') out.y = bounds.y;
    if (where === 'middle') out.y = Math.round(bounds.y + (bounds.h - (m.h||0)) / 2);
    if (where === 'bottom') out.y = bounds.y + bounds.h - (m.h||0);
    const idx = p.elements.findIndex(e => e.id === id); if (idx !== -1) p.elements[idx] = out;
  });
  renderPage(p); updateSelectionUI();
}
function distributeSelection(axis){
  if (selectedIds.size < 3) return;
  const p = getCurrentPage(); const ids = [...selectedIds];
  // Order by position along axis
  const ordered = ids.map(id => getElementById(id)).filter(Boolean).sort((a,b)=> (axis==='h'?a.x:b.y) - (axis==='h'?b.x:a.y));
  if (ordered.length < 3) return;
  commitHistory('distribute');
  if (axis === 'h'){
    const left = Math.min(...ordered.map(e=>e.x));
    const right = Math.max(...ordered.map(e=>e.x + (e.w||0)));
    const totalW = ordered.reduce((s,e)=> s + (e.w||0), 0);
    const gap = (right - left - totalW) / (ordered.length - 1);
    let cur = left;
    ordered.forEach((el, i) => {
      const out = deepClone(el); out.x = Math.round(cur); cur += (el.w||0) + gap; const idx = p.elements.findIndex(e=>e.id===el.id); if (idx!==-1) p.elements[idx]=out; });
  } else {
    const top = Math.min(...ordered.map(e=>e.y));
    const bottom = Math.max(...ordered.map(e=>e.y + (e.h||0)));
    const totalH = ordered.reduce((s,e)=> s + (e.h||0), 0);
    const gap = (bottom - top - totalH) / (ordered.length - 1);
    let cur = top;
    ordered.forEach((el, i) => {
      const out = deepClone(el); out.y = Math.round(cur); cur += (el.h||0) + gap; const idx = p.elements.findIndex(e=>e.id===el.id); if (idx!==-1) p.elements[idx]=out; });
  }
  renderPage(p); updateSelectionUI();
}

/* ----------------------- Grouping helpers & actions ----------------------- */
function ensureGroupId(){ return 'grp-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,6); }
function getElementsByGroup(groupId){ return getCurrentPage().elements.filter(e => e.groupId === groupId); }
function getElementGroupId(id){ const m = getElementById(id); return m?.groupId ?? null; }
function assignGroup(ids, groupId){ const p = getCurrentPage(); ids.forEach(id => { const m = p.elements.find(e => e.id === id); if (m) m.groupId = groupId; }); }
function clearGroup(ids){ const p = getCurrentPage(); ids.forEach(id => { const m = p.elements.find(e => e.id === id); if (m) m.groupId = null; }); }

function groupSelection(){
  if (selectedIds.size < 2) return;
  const gid = ensureGroupId();
  commitHistory('group');
  assignGroup([...selectedIds], gid);
  renderPage(getCurrentPage()); updateSelectionUI();
}
function ungroupSelection(){
  if (selectedIds.size === 0) return;
  const first = getElementById([...selectedIds][0]);
  const gid = first?.groupId; if (!gid) return;
  const allSame = [...selectedIds].every(id => getElementById(id)?.groupId === gid);
  if (!allSame) return;
  commitHistory('ungroup');
  clearGroup([...selectedIds]);
  renderPage(getCurrentPage()); updateSelectionUI();
}

// Toggle group/ungroup for action bar button
function updateGroupToggleButton(){
  const actions = elementActions(); if (!actions) return;
  const btn = actions.querySelector('[data-group-toggle]'); if (!btn) return;
  const first = selectedIds.size ? getElementById([...selectedIds][0]) : null;
  const gid = first?.groupId;
  const allSame = gid && [...selectedIds].every(id => getElementById(id)?.groupId === gid);
  btn.textContent = allSame ? 'Ungroup' : 'Group';
  btn.disabled = selectedIds.size < 2 && !allSame;
}
function toggleGroupSelection(){
  const first = selectedIds.size ? getElementById([...selectedIds][0]) : null;
  const gid = first?.groupId;
  const allSame = gid && [...selectedIds].every(id => getElementById(id)?.groupId === gid);
  if (allSame) { ungroupSelection(); }
  else if (selectedIds.size >= 2) { groupSelection(); }
}

/* ----------------------- Multi copy/delete ----------------------- */
let clipboardElements = []; // Internal clipboard for elements

function copyToClipboard() {
  if (selectedIds.size === 0) return;
  clipboardElements = [...selectedIds].map(id => {
    const element = deepClone(getElementById(id));
    return element;
  });
}

function pasteFromClipboard() {
  if (clipboardElements.length === 0) return;
  
  const page = getCurrentPage();
  const clones = [];
  const offset = 12; // Offset for pasted elements
  
  clipboardElements.forEach(src => {
    const clone = deepClone(src);
    clone.id = generateId();
    clone.x += offset; 
    clone.y += offset;
    if (clone.type === 'line' && typeof clone.x2 === 'number' && typeof clone.y2 === 'number') {
      clone.x2 += offset; 
      clone.y2 += offset;
    }
    clones.push(clone);
  });
  
  if (clones.length === 0) return;
  commitHistory('paste-multi');
  page.elements.push(...clones);
  setSelection(clones.map(c => c.id));
  renderPage(page);
}

function copySelection(offset = 12){
  if (selectedIds.size === 0) return;
  const page = getCurrentPage();
  const clones = [];
  [...selectedIds].forEach(id => {
    const src = deepClone(getElementById(id));
    if (!src) return;
    src.id = generateId();
    src.x += offset; src.y += offset;
    if (src.type === 'line' && typeof src.x2 === 'number' && typeof src.y2 === 'number'){
      src.x2 += offset; src.y2 += offset;
    }
    clones.push(src);
  });
  if (clones.length === 0) return;
  commitHistory('copy-multi');
  page.elements.push(...clones);
  setSelection(clones.map(c => c.id));
  renderPage(page);
}

function deleteSelection(){
  if (selectedIds.size === 0) return;
  const page = getCurrentPage();
  commitHistory('delete-multi');
  page.elements = page.elements.filter(e => !selectedIds.has(e.id));
  clearSelection();
  renderPage(page);
  // Hide actions bubble after delete
  elementActions().classList.add('hidden');
}

/* ----------------------- Properties & Toolbar ----------------------- */
function bindFloatingToolbar(){
  const bar = formatToolbar();
  const hBtn = document.getElementById('alignHBtn');
  const vBtn = document.getElementById('alignVBtn');
  const tbg = document.getElementById('bgTransparentToggle');
  const readAlignForContext = () => {
    if (tableSel){
      const tModel = getElementById(tableSel.tableId);
      if (tModel){
        const ar = Math.min(tableSel.r0, tableSel.r1);
        const ac = Math.min(tableSel.c0, tableSel.c1);
        const id = tModel.grid[ar]?.[ac];
        const cell = id ? tModel.cells[id] : null;
        if (cell) return { h: cell.styles.alignH || 'left', v: cell.styles.alignV || 'top' };
      }
    }
    return readAlign();
  };
  bar.addEventListener('input', (e) => {
    const t = e.target;
    const prop = t.getAttribute('data-prop');
    if (!prop) return;
    
    const raw = (t.type === 'number' || t.type === 'range') ? Number(t.value) : t.value;
    
    // PRIORITY 1: If we have active table cell selection, always apply to cells
    if (tableSel) {
      const tModel = getElementById(tableSel.tableId);
      if (!tModel) return;
      
      // Handle different property types
      if (prop === 'styles.fill') {
        updateElement(tModel.id, tableApplyCellBg(tModel, tableSel, raw));
        return;
      }
      if (prop === 'styles.textColor') {
        updateElement(tModel.id, tableApplyTextColor(tModel, tableSel, raw));
        return;
      }
      
      // Handle cell-level styles (stroke, font, etc.)
      const cellStyleProps = ['styles.strokeColor', 'styles.strokeWidth', 'styles.fontFamily', 'styles.fontSize'];
      if (cellStyleProps.includes(prop)) {
        const key = prop.split('.')[1]; // Extract property name after 'styles.'
        updateElement(tModel.id, tableApplyCellStyle(tModel, tableSel, key, raw));
        return;
      }
    }
    
    // PRIORITY 2: If table elements are selected but no cells, try to restore last cell selection
    const selectedElements = [...selectedIds].map(id => getElementById(id)).filter(Boolean);
    const hasOnlyTables = selectedElements.length > 0 && selectedElements.every(el => el.type === 'table');
    
    if (hasOnlyTables && !tableSel && lastTableSel) {
      // Try to restore the last table selection for the selected table
      const selectedTable = selectedElements[0];
      if (selectedTable.id === lastTableSel.tableId) {
        setTableSelection(lastTableSel.tableId, lastTableSel.r0, lastTableSel.c0, lastTableSel.r1, lastTableSel.c1);
        // Now apply the formatting to the restored selection
        const tModel = getElementById(lastTableSel.tableId);
        if (tModel) {
          if (prop === 'styles.fill') {
            updateElement(tModel.id, tableApplyCellBg(tModel, tableSel, raw));
            return;
          }
          if (prop === 'styles.textColor') {
            updateElement(tModel.id, tableApplyTextColor(tModel, tableSel, raw));
            return;
          }
          const cellStyleProps = ['styles.strokeColor', 'styles.strokeWidth', 'styles.fontFamily', 'styles.fontSize'];
          if (cellStyleProps.includes(prop)) {
            const key = prop.split('.')[1];
            updateElement(tModel.id, tableApplyCellStyle(tModel, tableSel, key, raw));
            return;
          }
        }
      }
    }
    
    // PRIORITY 3: Prevent styling table containers when no cell selection exists
    if (hasOnlyTables && !tableSel) {
      // Block styling of table containers - user should select cells instead
      return;
    }
    
    // PRIORITY 4: Apply to regular element selection (non-table elements)
    if (selectedIds.size === 0) return;
    applyPatchToSelection(toPatch(prop, raw));
  });
  bar.addEventListener('click', (e) => {
    const t = e.target.closest('[data-toggle],[data-z]');
    if (!t) return;
    if (t.dataset.toggle){
      const key = t.dataset.toggle;
      
      // PRIORITY 1: If we have active table cell selection, always apply to cells
      if (tableSel && key.startsWith('styles.')){
        const tModel = getElementById(tableSel.tableId); 
        if (!tModel) return;
        const styleKey = key.split('.')[1];
        const anyOff = tableAnyCellStyleOff(tModel, tableSel, styleKey);
        updateElement(tModel.id, tableApplyCellStyle(tModel, tableSel, styleKey, anyOff));
        t.setAttribute('aria-pressed', String(anyOff));
        return;
      }
      
      // PRIORITY 2: If table elements are selected but no cells, try to restore last cell selection  
      const selectedElements = [...selectedIds].map(id => getElementById(id)).filter(Boolean);
      const hasOnlyTables = selectedElements.length > 0 && selectedElements.every(el => el.type === 'table');
      
      if (hasOnlyTables && !tableSel && lastTableSel && key.startsWith('styles.')) {
        const selectedTable = selectedElements[0];
        if (selectedTable.id === lastTableSel.tableId) {
          setTableSelection(lastTableSel.tableId, lastTableSel.r0, lastTableSel.c0, lastTableSel.r1, lastTableSel.c1);
          // Now apply the toggle to the restored selection
          const tModel = getElementById(lastTableSel.tableId);
          if (tModel) {
            const styleKey = key.split('.')[1];
            const anyOff = tableAnyCellStyleOff(tModel, tableSel, styleKey);
            updateElement(tModel.id, tableApplyCellStyle(tModel, tableSel, styleKey, anyOff));
            t.setAttribute('aria-pressed', String(anyOff));
            return;
          }
        }
      }
      
      // PRIORITY 3: Prevent styling table containers when no cell selection exists
      if (hasOnlyTables && !tableSel) {
        // Block styling of table containers - user should select cells instead
        return;
      }
      
      // PRIORITY 4: Apply to regular element selection (non-table elements)
      if (selectedIds.size === 0) return;
      const anyOff = [...selectedIds].some(id => !getByPath(getElementById(id), key));
      applyPatchToSelection(toPatch(key, anyOff));
      t.setAttribute('aria-pressed', String(anyOff));
    } else if (t.dataset.z){
      if (t.dataset.z === 'front') sendSelectionToFront();
      else if (t.dataset.z === 'back') sendSelectionToBack();
      else if (t.dataset.z === 'up') bringSelectionForward();
      else if (t.dataset.z === 'down') sendSelectionBackward();
    }
  });

  if (tbg) {
    tbg.addEventListener('change', () => {
      if (selectedIds.size === 0) return;
      const on = tbg.checked;
      if (on) {
        const first = getElementById([...selectedIds][0]);
        tbg.dataset.prevFill = String(first?.styles?.fill ?? '');
        applyPatchToSelection(toPatch('styles.fill', 'transparent'));
      } else {
        const prev = tbg.dataset.prevFill || '#ffffff';
        applyPatchToSelection(toPatch('styles.fill', prev));
        delete tbg.dataset.prevFill;
      }
    });
  }

  const cycle = (val, list) => list[(list.indexOf(val) + 1) % list.length];
  const readAlign = () => {
    if (selectedIds.size !== 1) return { h:'left', v:'top' };
    const m = getElementById([...selectedIds][0]);
    return { h: m?.styles?.textAlignH || 'left', v: m?.styles?.textAlignV || 'top' };
  };
  window.applyAlignButtonState = function applyAlignButtonState(){
    const {h,v} = readAlign();
    hBtn.classList.remove('h-left','h-center','h-right');
    vBtn.classList.remove('v-top','v-middle','v-bottom');
    hBtn.classList.add('h-'+h);
    vBtn.classList.add(v === 'middle' ? 'v-middle' : 'v-'+v);
    const t = selectedIds.size === 1 ? getElementById([...selectedIds][0])?.type : null;
    const pressed = selectedIds.size === 1 && (t === 'text' || t === 'field' || t === 'rect');
    hBtn.setAttribute('aria-pressed', String(pressed));
    vBtn.setAttribute('aria-pressed', String(pressed));
  };
  hBtn.addEventListener('click', () => {
    const {h} = readAlignForContext();
    const next = cycle(h, ['left','center','right']);
    if (tableSel){
      const tModel = getElementById(tableSel.tableId);
      if (tModel) updateElement(tModel.id, tableApplyAlign(tModel, tableSel, next, undefined));
    } else {
      applyPatchToSelection(toPatch('styles.textAlignH', next));
      window.applyAlignButtonState();
    }
  });
  vBtn.addEventListener('click', () => {
    const {v} = readAlignForContext();
    const next = cycle(v, ['top','middle','bottom']);
    if (tableSel){
      const tModel = getElementById(tableSel.tableId);
      if (tModel) updateElement(tModel.id, tableApplyAlign(tModel, tableSel, undefined, next));
    } else {
      applyPatchToSelection(toPatch('styles.textAlignV', next));
      window.applyAlignButtonState();
    }
  });

  // Initialize align toggle state on load
  window.applyAlignButtonState();
}

function toPatch(path, value){
  const keys = path.split('.');
  let obj = {}; let cur = obj;
  keys.forEach((k, i) => { if (i === keys.length - 1) cur[k] = value; else { cur[k] = {}; cur = cur[k]; } });
  return obj;
}
function getByPath(obj, path){
  const ks = path.split('.'); let cur = obj; for (const k of ks){ if (cur==null) return undefined; cur = cur[k]; } return cur;
}
function togglePatch(path){
  const keys = path.split('.');
  const page = getCurrentPage();
  const m = page.elements.find(e => selectedIds.has(e.id));
  let cur = m;
  for (let i = 0; i < keys.length - 1; i++) cur = cur[keys[i]];
  const last = keys[keys.length - 1];
  return toPatch(path, !cur[last]);
}

// Parse a string from the properties panel into a JS value
function parsePropertyValue(raw){
  const txt = String(raw ?? '').trim();
  if (txt === '') return '';
  if (txt === 'true') return true;
  if (txt === 'false') return false;
  if (txt === 'null') return null;
  // Try number
  const asNum = Number(txt);
  if (!Number.isNaN(asNum) && /^-?\d*(?:\.\d+)?$/.test(txt)) return asNum;
  // Try JSON for arrays/objects
  if ((txt.startsWith('{') && txt.endsWith('}')) || (txt.startsWith('[') && txt.endsWith(']'))){
    try { return JSON.parse(txt); } catch {}
  }
  return raw; // fallback to original string
}

// Keys that are part of the element model and should not be treated as HTML attributes
const RESERVED_MODEL_KEYS = new Set(['id','type','groupId','parentId','stackChildren','stackByPage','pageBreak','repeatOnAllPages','freeMove','x','y','w','h','z','x2','y2','content','src','styles','grid','rows','cols','rowHeights','colWidths']);

function getCustomAttributesFromModel(model){
  const attrs = Object.assign({}, model && model.attrs ? model.attrs : {});
  // Also treat unknown top-level primitives as attributes for backward-compat
  if (model && typeof model === 'object'){
    Object.keys(model).forEach((k) => {
      if (RESERVED_MODEL_KEYS.has(k)) return;
      if (k === 'attrs') return;
      const v = model[k];
      const isPrimitive = (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean');
      if (isPrimitive) attrs[k] = v;
    });
  }
  return attrs;
}

function renderProperties(){
  const box = propertiesContent();
  try { console.log('[RENDER] renderProperties: selectionSize=', selectedIds.size, 'tableSel=', !!tableSel); } catch {}
  box.innerHTML = '';
  if (selectedIds.size === 0 && !tableSel) return;
  const page = getCurrentPage();
  let m = null; let groupId = null; let cellId = '';
  if (tableSel){
    // Show cell id for the anchor cell when a table selection exists
    const tModel = getElementById(tableSel.tableId);
    if (tModel){
      const ar = Math.min(tableSel.r0, tableSel.r1);
      const ac = Math.min(tableSel.c0, tableSel.c1);
      const cid = tModel.grid[ar]?.[ac];
      if (cid) cellId = cid;
      m = tModel; // fall through to show table properties too
    }
  }
  if (!m){
    if (selectedIds.size === 1){
      const one = [...selectedIds][0];
      m = page.elements.find(e => e.id === one);
      groupId = m?.groupId || '';
    } else if (selectedIds.size > 1){
      // multi: if all have same group, show it
      const ids = [...selectedIds];
      const first = page.elements.find(e => e.id === ids[0]);
      const gid = first?.groupId;
      const same = gid && ids.every(id => page.elements.find(e => e.id === id)?.groupId === gid);
      if (same) groupId = gid;
      m = first;
    }
  }
  if (!m) m = page.elements.find(e => selectedIds.has(e.id));
  // Base rows from core model
  const rows = [
    ['id', m?.id || 'multi'], ['type', m?.type || 'multi'], ['groupId', groupId || ''], ['x', m?.x], ['y', m?.y], ['w', m?.w], ['h', m?.h], ['z', m?.z]
  ];
  if (cellId) rows.unshift(['cellId', cellId]);
  
  // Add editable text content + formula field for text-like elements
  if (m && (m.type === 'text' || m.type === 'field' || m.type === 'rect')) {
    rows.push(['content', m.content || '']);
    const formula = (m && m.attrs && typeof m.attrs.formula === 'string') ? m.attrs.formula : '';
    rows.push(['formula', formula]);
  }
  
  // Include custom attributes as flat props for editing
  let customAttrs = getCustomAttributesFromModel(m || {});
  // Avoid duplicating builtin formula row when attrs also contains formula
  if (m && (m.type === 'text' || m.type === 'field' || m.type === 'rect')){
    if (customAttrs && Object.prototype.hasOwnProperty.call(customAttrs, 'formula')){
      delete customAttrs.formula;
    }
  }
  const customAttrKeys = new Set(Object.keys(customAttrs));
  Object.keys(customAttrs).forEach((name) => {
    rows.push([name, customAttrs[name]]);
  });

  // When a table cell is selected, also expose its per-cell attrs.* for editing
  if (m && m.type === 'table' && tableSel) {
    const rr = Math.min(tableSel.r0, tableSel.r1);
    const cc = Math.min(tableSel.c0, tableSel.c1);
    const cid = m.grid?.[rr]?.[cc];
    const cell = cid ? m.cells?.[cid] : null;
    if (cell && cell.attrs){
      Object.keys(cell.attrs).forEach((name) => {
        rows.push([`cell.${name}`, cell.attrs[name]]);
      });
    }
  }

  rows.forEach(([k,v]) => {
    const row = document.createElement('div');
    row.className = 'row';
    const name = document.createElement('label');
    name.textContent = k;
    let control;
    // Controls by type
    if (k === 'fontSize') {
      control = document.createElement('select');
      control.innerHTML = '<option>8</option><option>9</option><option>10</option><option>11</option><option>12</option><option>14</option><option>16</option><option>18</option><option>20</option><option>24</option><option>28</option><option>32</option><option>36</option><option>48</option><option>72</option>';
      control.dataset.prop = 'styles.'+k;
      control.value = String(v);
    } else if (k === 'fontFamily') {
      control = document.createElement('select');
      control.innerHTML = '<option value="system-ui">System</option><option value="Arial">Arial</option><option value="Helvetica Neue">Helvetica</option><option value="Times New Roman">Times</option><option value="Georgia">Georgia</option><option value="Courier New">Courier</option>';
      control.dataset.prop = 'styles.'+k;
      control.value = String(v);
    } else if (k === 'textColor') {
      control = document.createElement('input'); control.type = 'color'; control.value = v || '#111827'; control.dataset.prop = 'styles.'+k;
    } else if (k === 'bold' || k === 'italic') {
      control = document.createElement('input'); control.type = 'checkbox'; control.checked = !!v; control.dataset.prop = 'styles.'+k;
    } else if (k === 'content' || k === 'formula' || (customAttrKeys.has(k) && typeof v === 'string')) {
      control = document.createElement('textarea');
      control.rows = 3;
      control.value = v ?? '';
      control.dataset.prop = k;
      if (k === 'formula'){
        // Element picker button beside textarea (inline)
        // Keep simple: when clicking, it inserts a '#id' token at caret
        const wrap = document.createElement('div'); wrap.style.display='grid'; wrap.style.gridTemplateColumns='1fr 28px'; wrap.style.gap='6px';
        const pick = document.createElement('button'); pick.type='button'; pick.className='btn mini';
        pick.innerHTML = '<svg class="icon" viewBox="0 0 24 24" width="14" height="14" aria-hidden="true"><circle cx="12" cy="12" r="3" fill="currentColor"/><circle cx="12" cy="12" r="7" fill="none" stroke="currentColor" stroke-width="2"/></svg>';
        const area = control;
        wrap.appendChild(area); wrap.appendChild(pick); control = wrap; // replace control with wrap
        // picker behavior: choose element or table cell and insert token
        pick.addEventListener('click', () => {
          // preserve selection
          const prevSelIds = Array.from(document.querySelectorAll('.page .element.selected')).map(n=>n.getAttribute('data-id')).filter(Boolean);
          const pageEl = document.querySelector('.page'); if (!pageEl) return;
          let last; window.__PICKING = true; document.body.classList.add('app-noselect');
          const block = (ev)=>{ ev.stopPropagation(); ev.preventDefault(); };
          document.addEventListener('pointerdown', block, true);
          document.addEventListener('mousedown', block, true);
          const onMove = (ev)=>{ const cell=ev.target.closest('.table-cell'); const el=cell||ev.target.closest('.page .element'); if (last===el) return; if (last) last.style.outline=''; last=el; if (last) last.style.outline='2px solid var(--primary)'; };
          const done = ()=>{ document.removeEventListener('mousemove', onMove, true); document.removeEventListener('click', onClick, true); document.removeEventListener('keydown', onKey, true); document.removeEventListener('pointerdown', block, true); document.removeEventListener('mousedown', block, true); if (last) last.style.outline=''; window.__PICKING=false; document.body.classList.remove('app-noselect'); if (Array.isArray(prevSelIds) && prevSelIds.length && typeof setSelection==='function') setSelection(prevSelIds); };
          const onKey = (e)=>{ if (e.key==='Escape'){ e.preventDefault(); done(); } };
          const onClick = (e)=>{ const cell=e.target.closest('.table-cell'); const el=cell||e.target.closest('.page .element'); if (!el){ done(); return; } e.preventDefault(); e.stopPropagation(); let token=''; if (cell){ const cid=cell.getAttribute('data-id'); if (cid) token = `#${cid}`; } else { const id=el.getAttribute('data-id'); if (id) token = `#${id}`; } const ta = wrap.querySelector('textarea'); if (ta){ const start = ta.selectionStart ?? ta.value.length; const end = ta.selectionEnd ?? ta.value.length; ta.value = ta.value.slice(0,start) + token + ta.value.slice(end); ta.dispatchEvent(new Event('change', { bubbles:true })); ta.focus(); ta.selectionStart = ta.selectionEnd = start + token.length; } done(); };
          document.addEventListener('mousemove', onMove, true);
          document.addEventListener('click', onClick, true);
          document.addEventListener('keydown', onKey, true);
        });
      }
    } else {
      control = document.createElement('input'); control.value = v ?? ''; control.dataset.prop = k;
    }
    row.appendChild(name);
    row.appendChild(control);
    box.appendChild(row);
  });

  // Block-specific: stacking children toggle
  if (m && m.type === 'block'){
    const row = document.createElement('div'); row.className = 'row'; row.style.display = 'flex'; row.style.alignItems = 'center';
    const lab = document.createElement('label'); lab.textContent = 'stackChildren';
    const ctl = document.createElement('input'); ctl.type='checkbox'; ctl.dataset.prop = 'stackChildren'; ctl.checked = !!m.stackChildren;
    row.appendChild(lab); row.appendChild(ctl); box.appendChild(row);
  }

  // Generic: stackByPage toggle available for all element types
  if (m){
    const row2 = document.createElement('div'); row2.className = 'row'; row2.style.display = 'flex'; row2.style.alignItems = 'center';
    const lab2 = document.createElement('label'); lab2.textContent = 'stackByPage';
    const ctl2 = document.createElement('input'); ctl2.type='checkbox'; ctl2.dataset.prop = 'stackByPage'; ctl2.checked = !!m.stackByPage;
    row2.appendChild(lab2); row2.appendChild(ctl2); box.appendChild(row2);

    // Page break toggle: forces this element to start on a new page
    const row3 = document.createElement('div'); row3.className = 'row'; row3.style.display = 'flex'; row3.style.alignItems = 'center';
    const lab3 = document.createElement('label'); lab3.textContent = 'pageBreak';
    const ctl3 = document.createElement('input'); ctl3.type='checkbox'; ctl3.dataset.prop = 'pageBreak'; ctl3.checked = !!m.pageBreak;
    row3.appendChild(lab3); row3.appendChild(ctl3); box.appendChild(row3);

    // Repeat flag (single checkbox)
    const row4 = document.createElement('div'); row4.className = 'row'; row4.style.display = 'flex'; row4.style.alignItems = 'center';
    const lab4 = document.createElement('label'); lab4.textContent = 'repeatOnAllPages';
    const ctl4 = document.createElement('input'); ctl4.type='checkbox'; ctl4.dataset.prop = 'repeatOnAllPages'; ctl4.checked = !!m.repeatOnAllPages;
    row4.appendChild(lab4); row4.appendChild(ctl4); box.appendChild(row4);

    // Free move (allow positioning outside page bounds, visible overflow)
    const row5 = document.createElement('div'); row5.className = 'row'; row5.style.display = 'flex'; row5.style.alignItems = 'center';
  const lab5 = document.createElement('label'); lab5.textContent = 'freeMove'; lab5.title = 'Allow this element to move/appear outside page bounds and across pages (live reparent).';
    const ctl5 = document.createElement('input'); ctl5.type='checkbox'; ctl5.dataset.prop = 'freeMove'; ctl5.checked = !!m.freeMove;
    row5.appendChild(lab5); row5.appendChild(ctl5); box.appendChild(row5);
  }

  // Actions UI (bubble layout): choose function, trigger, and inputs; stack multiple
  try {
    const actionsRow = document.createElement('div');
    actionsRow.className = 'row';
    const lbl = document.createElement('label');
    lbl.textContent = 'Actions';
    const container = document.createElement('div');
    container.setAttribute('data-actions','');
    container.style.width = '100%';
    actionsRow.appendChild(lbl);
    actionsRow.appendChild(container);
    box.appendChild(actionsRow);

    // Supported DOM events -> attribute names
    const SUPPORTED = [ 'click','change','input','dblclick','focus','blur' ];

   

    function splitCalls(expr){
      const out = [];
      if (!expr) return out;
      let cur = '', depth = 0, quote = '';
      for (let i=0;i<expr.length;i++){
        const ch = expr[i];
        if (quote){ if (ch === quote && expr[i-1] !== '\\') quote = ''; cur += ch; continue; }
        if (ch === '"' || ch === "'") { quote = ch; cur += ch; continue; }
        if (ch === '(') { depth++; cur += ch; continue; }
        if (ch === ')') { depth = Math.max(0, depth-1); cur += ch; continue; }
        if ((ch === ';' || ch === ',') && depth === 0){ if (cur.trim()) out.push(cur.trim()); cur = ''; continue; }
        cur += ch;
      }
      if (cur.trim()) out.push(cur.trim());
      return out;
    }
    function parseCall(call){
      const m = call.match(/^\s*([\w$]+)\s*\((.*)\)\s*$/);
      if (!m) return { fn:'', args:[] };
      const fn = m[1];
      const argsRaw = m[2].trim();
      if (!argsRaw) return { fn, args:[] };
      const parts = splitCalls(argsRaw).map(s => s.trim()).filter(Boolean);
      return { fn, args: parts };
    }
    function buildExpr(calls){
      return calls.filter(c => c && c.fn).map(c => `${c.fn}(${c.args.join(', ')})`).join('; ');
    }

    function collectExisting(){
      // If a table cell is selected, read actions from the cell's attrs
      if (m && m.type === 'table' && cellId){
        const cell = m.cells ? m.cells[cellId] : null;
        const attrs = (cell && cell.attrs) ? cell.attrs : {};
        const items = [];
        SUPPORTED.forEach(evt => {
          const key = 'on' + evt;
          const expr = String(attrs[key] || '');
          splitCalls(expr).map(parseCall).forEach(c => items.push({ event: evt, fn: c.fn, args: c.args }));
        });
        return items;
      }
      // Otherwise use element-level attrs
      const attrs = getCustomAttributesFromModel(m || {});
      const items = [];
      SUPPORTED.forEach(evt => {
        const key = 'on' + evt;
        const expr = String(attrs[key] || '');
        splitCalls(expr).map(parseCall).forEach(c => items.push({ event: evt, fn: c.fn, args: c.args }));
      });
      return items;
    }

    function writeBack(items){
      // Preserve current selection (elements or table cells) to avoid deselection during updates
      const prevSelIds = Array.from(document.querySelectorAll('.page .element.selected'))
        .map(n => n && n.getAttribute('data-id'))
        .filter(Boolean);
      // Group by event and write complete expressions for each
      const per = {};
      SUPPORTED.forEach(e => per[e] = []);
      items.forEach(it => { if (SUPPORTED.includes(it.event) && it.fn) per[it.event].push({ fn: it.fn, args: it.args || [] }); });

      // If a table cell is selected, write actions into that cell's attrs
      if (m && m.type === 'table' && cellId){
        const next = deepClone(m);
        if (!next.cells[cellId]) next.cells[cellId] = { attrs: {} };
        if (!next.cells[cellId].attrs) next.cells[cellId].attrs = {};
        SUPPORTED.forEach(evt => {
          const expr = buildExpr(per[evt]);
          next.cells[cellId].attrs['on' + evt] = expr;
        });
        updateElement(next.id, next);
        // Restore selection after update
        if (Array.isArray(prevSelIds) && prevSelIds.length && typeof setSelection === 'function') {
          setSelection(prevSelIds);
        }
        return;
      }

      // Otherwise, element-level attrs
      SUPPORTED.forEach(evt => {
        const path = `attrs.on${evt}`;
        const expr = buildExpr(per[evt]);
        applyPatchToSelection(toPatch(path, expr), 'actions-update');
      });
      // Restore selection after attributes update
      if (Array.isArray(prevSelIds) && prevSelIds.length && typeof setSelection === 'function') {
        setSelection(prevSelIds);
      }
    }

    function render(){
      container.innerHTML = '';
      const funcs = getUserFunctionChoices();
      let items = collectExisting();
      const openSet = (window.__ACTION_OPEN || (window.__ACTION_OPEN = new Set()));

      // Add header with + button
      const header = document.createElement('div');
      header.style.display = 'flex';
      header.style.alignItems = 'center';
      header.style.justifyContent = 'space-between';
      header.style.marginBottom = '6px';
        const title = document.createElement('div');
      title.textContent = 'Adding function (add a bubble)';
      title.style.color = 'var(--muted)';
      title.style.fontSize = '11px';
      const addBtn = document.createElement('button'); addBtn.type='button'; addBtn.className='btn mini';
      addBtn.innerHTML = '<svg class="icon" viewBox="0 0 24 24" width="16" height="16" aria-hidden="true"><path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
      header.appendChild(title); header.appendChild(addBtn);
      container.appendChild(header);

      function addEmpty(){
        const firstFn = funcs[0]?.name || '';
        const inputs = funcs[0]?.inputs || 0;
        items.push({ event: 'click', fn: firstFn, args: Array(inputs).fill("'"+""+"'") });
        writeBack(items); render();
      }
      addBtn.addEventListener('click', addEmpty);

      // List bubbles
      items.forEach((it, idx) => {
        const bubble = document.createElement('div');
        bubble.style.border = '1px solid var(--border)';
        bubble.style.borderRadius = '8px';
        bubble.style.padding = '8px';
        bubble.style.marginBottom = '8px';
        bubble.style.background = '#fafafa';
        bubble.style.width = '100%';
        bubble.style.boxSizing = 'border-box';

        // Top row: function + trigger + remove
        const top = document.createElement('div');
        top.style.display = 'grid';
  top.style.gridTemplateColumns = '28px minmax(0,1fr) 110px 28px 28px';
        top.style.gap = '6px';

        // expand/collapse toggle
        const keyOf = () => `${idx}:${it.event}:${it.fn}`;
        let collapsed = !openSet.has(keyOf());
        const expBtn = document.createElement('button');
        expBtn.type = 'button';
        expBtn.className = 'btn mini';
        expBtn.innerHTML = '<svg class="icon" viewBox="0 0 24 24" width="16" height="16" aria-hidden="true"><path d="M8 10l4 4 4-4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>';

        // Function dropdown (same style as trigger)
        const fnSel = document.createElement('select');
        fnSel.innerHTML = '<option value="">Select function…</option>' + funcs.map(f => `<option value="${f.name}">${f.label}</option>`).join('');
        fnSel.value = it.fn || '';
        fnSel.style.width = '100%';

        const trgSel = document.createElement('select');
        trgSel.innerHTML = SUPPORTED.map(e => `<option value="${e}">${'on'+e}</option>`).join('');
        trgSel.value = it.event;
        trgSel.style.width = '100%';

        const delBtn = document.createElement('button'); delBtn.type='button'; delBtn.className='btn mini';
        delBtn.innerHTML = '<svg class="icon" viewBox="0 0 24 24" width="14" height="14" aria-hidden="true"><path d="M6 6l12 12M18 6l-12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
        delBtn.style.width = '24px';
        delBtn.style.height = '24px';
        delBtn.style.padding = '0';
        delBtn.style.display = 'inline-flex';
        delBtn.style.alignItems = 'center';
        delBtn.style.justifyContent = 'center';
        delBtn.style.borderRadius = '999px';

        // Play button to execute the selected user function even in edit mode
        const playBtn = document.createElement('button'); playBtn.type='button'; playBtn.className='btn mini';
        playBtn.innerHTML = '<svg class="icon" viewBox="0 0 24 24" width="14" height="14" aria-hidden="true"><path d="M8 5v14l11-7z" fill="currentColor"/></svg>';
        playBtn.style.width='24px';
        playBtn.style.height='24px';
        playBtn.style.padding='0';
        playBtn.style.display='inline-flex';
        playBtn.style.alignItems='center';
        playBtn.style.justifyContent='center';
        playBtn.style.borderRadius='999px';
        playBtn.title = 'Run function now';
        playBtn.addEventListener('click', () => {
          try {
            const fnName = fnSel.value;
            if (!fnName) return;
            const fn = window[fnName];
            if (typeof fn !== 'function') return;
            // gather current args from inputs (without re-committing if user mid-edit)
            const argVals = Array.from(inputsWrap.querySelectorAll('input')).map(inputEl => {
              const v = String(inputEl.value || '').trim();
              // attempt to parse JSON-like values
              if ((v.startsWith('{') && v.endsWith('}')) || (v.startsWith('[') && v.endsWith(']'))){
                try { return JSON.parse(v); } catch { return v; }
              }
              if (/^-?\d+(?:\.\d+)?$/.test(v)) return parseFloat(v);
              if (/^(true|false)$/i.test(v)) return /true/i.test(v);
              if (/^null$/i.test(v)) return null;
              if (/^undefined$/i.test(v)) return undefined;
              return v; // treat as raw string/selector
            });
            // Temporarily allow execution in edit mode
            const prev = window.__ALLOW_USER_FUNCTIONS_IN_EDIT;
            window.__ALLOW_USER_FUNCTIONS_IN_EDIT = true;
            try { fn.apply(null, argVals); } finally { window.__ALLOW_USER_FUNCTIONS_IN_EDIT = prev; }
          } catch(err){ console.warn('Play function failed', err); }
        });

  top.appendChild(expBtn); top.appendChild(fnSel); top.appendChild(trgSel); top.appendChild(delBtn); top.appendChild(playBtn);
        bubble.appendChild(top);

        const inputsWrap = document.createElement('div');
        inputsWrap.style.display = 'grid';
        inputsWrap.style.gap = '6px';
        inputsWrap.style.marginTop = '6px';

        function rebuildInputs(){
          inputsWrap.innerHTML = '';
          const meta = funcs.find(f => f.name === fnSel.value);
          const count = meta ? (meta.inputs || 0) : 0;
          for (let i=0;i<count;i++){
            const r = document.createElement('div'); r.className='row'; r.style.display='contents';
            const lab = document.createElement('label'); lab.textContent = `input ${i+1}`;
            // input + pickers container
            const line = document.createElement('div');
            line.style.display = 'grid';
            line.style.gridTemplateColumns = '1fr 28px 28px';
            line.style.gap = '6px';
            const inp = document.createElement('input');
            // Prefer custom placeholders from function metadata, else default for first arg
            if (meta && Array.isArray(meta.placeholders) && meta.placeholders[i]) {
              inp.placeholder = String(meta.placeholders[i]);
            } else {
              inp.placeholder = i === 0 ? 'selected element (css selector)' : '';
            }
            // show clean value without surrounding quotes
            const raw = it.args?.[i] ? String(it.args[i]) : '';
            const unquoted = (raw.startsWith("'") && raw.endsWith("'")) || (raw.startsWith('"') && raw.endsWith('"')) ? raw.slice(1,-1) : raw;
            inp.value = unquoted;
            // Only commit on change/blur (finished editing)
            const finished = () => commit();
            inp.addEventListener('change', finished);
            inp.addEventListener('blur', finished);
            // element picker button (target icon)
            const pickBtn = document.createElement('button'); pickBtn.type='button'; pickBtn.className='btn mini';
            pickBtn.innerHTML = '<svg class="icon" viewBox="0 0 24 24" width="14" height="14" aria-hidden="true"><circle cx="12" cy="12" r="3" fill="currentColor"/><circle cx="12" cy="12" r="7" fill="none" stroke="currentColor" stroke-width="2"/></svg>';
            // style picker button (eyedropper)
            const styleBtn = document.createElement('button'); styleBtn.type='button'; styleBtn.className='btn mini';
            styleBtn.innerHTML = '<svg class="icon" viewBox="0 0 24 24" width="14" height="14" aria-hidden="true"><path d="M3 21l6-6m6-6l3 3-9 9H6v-3l9-9 3 3" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';

            line.appendChild(inp); line.appendChild(pickBtn); line.appendChild(styleBtn);
            r.appendChild(lab); r.appendChild(line);
            inputsWrap.appendChild(r);

            // Picker helpers
            function rgbToHex(rgb){
              const m = String(rgb||'').match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i); if (!m) return '#000000';
              const r = Number(m[1]).toString(16).padStart(2,'0');
              const g = Number(m[2]).toString(16).padStart(2,'0');
              const b = Number(m[3]).toString(16).padStart(2,'0');
              return `#${r}${g}${b}`;
            }
            function startElementPicker(kind){
              // Preserve selection before entering picker mode
              const prevSelIds = Array.from(document.querySelectorAll('.page .element.selected'))
                .map(n => n && n.getAttribute('data-id'))
                .filter(Boolean);
              const pageEl = document.querySelector('.page'); if (!pageEl) return;
              let last;
              window.__PICKING = true;
              document.body.classList.add('app-noselect');
              // Block pointer down inside the page so nothing re-targets selection
              const blockDown = (ev) => { ev.stopPropagation(); ev.preventDefault(); };
              document.addEventListener('pointerdown', blockDown, true);
              document.addEventListener('mousedown', blockDown, true);
              document.addEventListener('touchstart', blockDown, { capture:true, passive:false });
              const onMove = (ev) => {
                // Prefer highlighting a table cell if under pointer; otherwise the element box
                const cell = ev.target.closest('.table-cell');
                const el = cell || ev.target.closest('.page .element');
                if (last === el) return;
                if (last) last.style.outline = '';
                last = el;
                if (last) last.style.outline = '2px solid var(--primary)';
              };
              const done = () => {
                document.removeEventListener('mousemove', onMove, true);
                document.removeEventListener('click', onClick, true);
                document.removeEventListener('keydown', onKey, true);
                document.removeEventListener('pointerdown', blockDown, true);
                document.removeEventListener('mousedown', blockDown, true);
                document.removeEventListener('touchstart', blockDown, true);
                if (last) last.style.outline = '';
                document.body.classList.remove('app-noselect');
                window.__PICKING = false;
                // Restore selection after picking
                if (Array.isArray(prevSelIds) && prevSelIds.length && typeof setSelection === 'function') {
                  setSelection(prevSelIds);
                }
              };
              const onKey = (e) => { if (e.key === 'Escape'){ e.preventDefault(); done(); } };
              const onClick = (e) => {
                // Support picking individual table cells as well as whole elements
                const cell = e.target.closest('.table-cell');
                const el = cell || e.target.closest('.page .element');
                if (!el) { done(); return; }
                e.preventDefault(); e.stopPropagation();
                if (kind === 'selector'){
                  if (cell){
                    const cid = cell.getAttribute('data-id');
                    if (cid) inp.value = `'[data-id="${cid}"]'`;
                  } else {
                    const id = el.getAttribute('data-id');
                    if (id) inp.value = `'[data-id="${id}"]'`;
                  }
                } else if (kind === 'style'){
                  const EXCLUDE = /^(?:width|height|left|top|right|bottom|inset|transform|translate|scale|rotate|position|z-index|x|y|outline(?:-.+)?)$/i;
                  const parts = [];
                  // Use the exact inline style attribute (as shown in DevTools)
                  try {
                    // Ensure picker outline is cleared before reading inline styles
                    el.style.outline = '';
                    const attr = el.getAttribute('style') || '';
                    attr.split(';').forEach(chunk => {
                      const seg = chunk.trim();
                      if (!seg) return;
                      const [kRaw, ...rest] = seg.split(':');
                      const k = (kRaw || '').trim();
                      const v = rest.join(':').trim(); // preserve any colons in values
                      if (!k || !v) return;
                      if (EXCLUDE.test(k)) return;
                      parts.push(`${k}:${v}`);
                    });
                  } catch {}
                  if (parts.length === 0){
                    // Fallback: pick a curated set from computed styles
                    const cs = getComputedStyle(el);
                    const keys = [
                      'background-color','color','border','border-color','border-width','border-style','border-radius',
                      'box-shadow','font-family','font-size','font-weight','font-style','text-decoration','text-align','line-height',
                      'opacity'
                    ];
                    keys.forEach(k => { const v = cs.getPropertyValue(k); if (v && v !== 'auto' && v !== 'normal' && v !== 'none') parts.push(`${k}:${v.trim()}`); });
                  }
                  const styleStr = parts.join('; ');
                  const escaped = styleStr.replace(/'/g, "\\'");
                  inp.value = `'${escaped}'`;
                }
                inp.dispatchEvent(new Event('change', { bubbles:true }));
                done();
              };
              document.addEventListener('mousemove', onMove, true);
              document.addEventListener('click', onClick, true);
              document.addEventListener('keydown', onKey, true);
            }
            pickBtn.addEventListener('click', () => startElementPicker('selector'));
            styleBtn.addEventListener('click', () => startElementPicker('style'));
          }
          // preserve args array length
          it.args = (it.args || []).slice(0, count);
        }

        function commit(){
          it.fn = fnSel.value || '';
          it.event = trgSel.value || 'click';
          // Read current inputs
          const vals = Array.from(inputsWrap.querySelectorAll('input')).map((inputEl) => {
            const v = String(inputEl.value || '').trim();
            if (v === '') return "''";
            if (v.startsWith("'") || v.startsWith('"')) return v; // already quoted
            // JSON-like only if it parses successfully
            if (v.startsWith('{') || v.startsWith('[')) {
              try { JSON.parse(v); return v; } catch {/* fall through to quote as string */}
            }
            if (/^-?\d+(?:\.\d+)?$/.test(v) || /^(true|false|null|undefined)$/i.test(v)) return v;
            const escaped = v.replace(/'/g, "\\'");
            return `'${escaped}'`;
          });
          it.args = vals;
          writeBack(items);
          // nothing else
          // keep expansion state for this updated signature
          if (!collapsed) openSet.add(keyOf()); else openSet.delete(keyOf());
        }

        fnSel.addEventListener('change', () => { rebuildInputs(); commit(); });
        trgSel.addEventListener('change', () => { commit(); });
        delBtn.addEventListener('click', () => {
          items.splice(idx, 1);
          writeBack(items);
          render();
        });

        bubble.appendChild(inputsWrap);
        rebuildInputs();
        // collapse by default
        const applyCollapsed = () => { inputsWrap.style.display = collapsed ? 'none' : 'grid'; expBtn.innerHTML = collapsed
          ? '<svg class="icon" viewBox="0 0 24 24" width="16" height="16" aria-hidden="true"><path d="M10 8l4 4-4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>'
          : '<svg class="icon" viewBox="0 0 24 24" width="16" height="16" aria-hidden="true"><path d="M8 10l4 4 4-4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>';
        };
        applyCollapsed();
        expBtn.addEventListener('click', () => { collapsed = !collapsed; if (collapsed) openSet.delete(keyOf()); else openSet.add(keyOf()); applyCollapsed(); });
        container.appendChild(bubble);
      });
    }

    render();
  } catch {}

  // Add-property trigger button (centered)
  const addWrap = document.createElement('div');
  addWrap.className = 'add-wrap';
  addWrap.innerHTML = `
    <button type="button" title="Add property" aria-label="Add property" data-add-prop-trigger
      style="width:28px;height:28px;border-radius:6px;border:1px solid #d1d5db;background:#f9fafb;cursor:pointer;font-size:18px;line-height:26px;">+</button>`;
  box.appendChild(addWrap);
  const trigger = addWrap.querySelector('[data-add-prop-trigger]');
  if (trigger) trigger.addEventListener('click', () => showAddPropRow(box), { once: true });
  // Apply edits only when the field commits (blur/change)
  box.addEventListener('change', onPropsInput, { once: true });
  // While typing in content textarea, switch to formula automatically if starts with '='
  box.addEventListener('input', (ev) => {
    const t = ev.target; if (!t || !t.matches('textarea[data-prop="content"]')) return;
    const val = String(t.value || '');
    if (val.startsWith('=')){
      // move value to formula field and clear content field
      const formCtl = box.querySelector('textarea[data-prop="formula"]');
      if (formCtl && formCtl !== t){ formCtl.value = val; formCtl.dispatchEvent(new Event('change', { bubbles:true })); }
      t.value = '';
    }
  });
}
function onPropsInput(e){
  const t = e.target; if (!t.matches('[data-prop]')) return;
  const key = t.dataset.prop; 
  let val;
  if (t.type === 'checkbox') {
    val = t.checked;
  } else {
    val = parsePropertyValue(t.value);
  }
  // Special case: validate id uniqueness across the document
  if (key === 'id'){
    const newId = String(val || '');
    const currentIds = new Set();
    try {
      (Model.document?.pages || []).forEach(p => (p.elements || []).forEach(el => currentIds.add(el.id)));
    } catch {}
    // Allow keeping the same id of the first selected element
    const firstSelected = (selectedIds && selectedIds.size) ? [...selectedIds][0] : null;
    if (firstSelected) currentIds.delete(firstSelected);
    const exists = currentIds.has(newId);
    if (exists || newId.trim() === ''){
      // Mark invalid and stop
      t.setAttribute('aria-invalid','true');
      t.style.borderColor = '#ef4444';
      t.style.background = '#fee2e2';
      // Rebind for next change
  propertiesContent().addEventListener('change', onPropsInput, { once: true });
      return;
    } else {
      t.removeAttribute('aria-invalid');
      t.style.borderColor = '';
      t.style.background = '';
    }
  }
  // Special handling for per-cell attrs when a cell is active
  if (key.startsWith('cell.') && tableSel){
    const tModel = getElementById(tableSel.tableId);
    if (tModel && tModel.type === 'table'){
      const ar = Math.min(tableSel.r0, tableSel.r1);
      const ac = Math.min(tableSel.c0, tableSel.c1);
      const cid = tModel.grid[ar]?.[ac];
      if (cid){
        const next = deepClone(tModel);
        next.cells[cid] = next.cells[cid] || { attrs: {} };
        next.cells[cid].attrs = Object.assign({}, next.cells[cid].attrs);
        const name = key.slice('cell.'.length);
        next.cells[cid].attrs[name] = val;
        updateElement(next.id, next);
        // Keep selection
        setTableSelection(next.id, ar, ac);
      }
    }
    propertiesContent().addEventListener('change', onPropsInput, { once: true });
    return;
  }

  // Special case: 'formula' maps to attrs.formula
  if (key === 'formula'){
    applyPatchToSelection(toPatch('attrs.formula', String(val || '')));
    try { if (typeof window.recalculateAllFormulas === 'function') window.recalculateAllFormulas(); } catch {}
    renderPage(getCurrentPage());
    propertiesContent().addEventListener('change', onPropsInput, { once: true });
    return;
  }
  // If editing a reserved key or styles.* keep path, otherwise map to attrs.*
  const topKey = key.split('.')[0];
  const isReserved = RESERVED_MODEL_KEYS.has(topKey) || key.startsWith('styles.');
  const path = isReserved ? key : `attrs.${key}`;
  applyPatchToSelection(toPatch(path, val));
  // If stackByPage was toggled on/off, reflow immediately so element jumps in place
  if (key === 'stackByPage' || key === 'pageBreak' || key === 'repeatOnAllPages' || key === 'freeMove') {
    try { reflowStacks(getCurrentPage()); } catch {}
  }
  propertiesContent().addEventListener('change', onPropsInput, { once: true });
}

function showAddPropRow(container){
  // Replace trigger with input row
  const row = document.createElement('div');
  row.className = 'row';
  row.setAttribute('data-add-prop-row','');
  row.innerHTML = `
    <label>key</label>
    <input name="k" placeholder="path.like.styles.custom">
    <label>value</label>
    <textarea name="v" rows="3" placeholder="number / text / true / {…}"></textarea>
    <div class="row-hint"></div>
    <div style="display:flex; gap:6px; justify-content:flex-end;">
      <button type="button" data-confirm-add class="btn mini">Add</button>
      <button type="button" data-cancel-add class="btn mini">Cancel</button>
    </div>`;
  // Remove the trigger wrapper if it exists
  const trigWrap = container.querySelector('[data-add-prop-trigger]')?.parentElement;
  if (trigWrap) container.replaceChild(row, trigWrap); else container.appendChild(row);

  const keyInput = row.querySelector('input[name="k"]');
  const valInput = row.querySelector('[name="v"]');
  const confirmBtn = row.querySelector('[data-confirm-add]');
  const cancelBtn = row.querySelector('[data-cancel-add]');
  const confirm = () => {
    const key = keyInput.value.trim();
    const raw = valInput.value;
    if (!key) { keyInput.focus(); return; }
    const val = parsePropertyValue(raw);
    const topKey = key.split('.')[0];
    const isReserved = RESERVED_MODEL_KEYS.has(topKey) || key.startsWith('styles.');
    const path = isReserved ? key : `attrs.${key}`;
    applyPatchToSelection(toPatch(path, val), 'add-prop');
    renderProperties();
  };
  const cancel = () => { renderProperties(); };

  confirmBtn.addEventListener('click', confirm);
  cancelBtn.addEventListener('click', cancel);
  row.addEventListener('keydown', (ev) => {
    if (ev.key === 'Enter') { ev.preventDefault(); confirm(); }
    if (ev.key === 'Escape') { ev.preventDefault(); cancel(); }
  });
  keyInput.focus();
}

function normalizeZOrder(){
  const page = getCurrentPage();
  const sorted = [...page.elements].sort((a,b) => (a.z ?? 0) - (b.z ?? 0));
  sorted.forEach((el, i) => el.z = (i + 1) * 10);
}
function sendSelectionToFront(){
  normalizeZOrder(); const page = getCurrentPage();
  const maxZ = Math.max(...page.elements.map(e => e.z ?? 0), 0);
  [...selectedIds].forEach(id => { const m = getElementById(id); if (m) m.z = maxZ + 10; });
  normalizeZOrder(); renderPage(page); updateSelectionUI();
}
function sendSelectionToBack(){
  normalizeZOrder(); const page = getCurrentPage();
  const minZ = Math.min(...page.elements.map(e => e.z ?? 0), 10);
  [...selectedIds].forEach(id => { const m = getElementById(id); if (m) m.z = minZ - 10; });
  normalizeZOrder(); renderPage(page); updateSelectionUI();
}
function bringSelectionForward(){
  normalizeZOrder(); const page = getCurrentPage();
  [...selectedIds].forEach(id => { const m = getElementById(id); if (m) m.z += 15; });
  normalizeZOrder(); renderPage(page); updateSelectionUI();
}
function sendSelectionBackward(){
  normalizeZOrder(); const page = getCurrentPage();
  [...selectedIds].forEach(id => { const m = getElementById(id); if (m) m.z -= 15; });
  normalizeZOrder(); renderPage(page); updateSelectionUI();
}

/* ===== PDF Export Utilities ===== */
//onclick of the export pdf button, export the page to pdf
document.getElementById('savePdfBtn').addEventListener('click', () => ExportService.exportDocumentToPdf());



// Dynamically ensure required libs are available without changing app logic
async function loadExternalScript(src){
  return new Promise((resolve, reject) => {
    // Deduplicate loads
    let existing = document.querySelector(`script[data-dynamic-src="${src}"]`);
    if (existing){
      if (existing.dataset.loaded === 'true') return resolve();
      existing.addEventListener('load', () => resolve());
      existing.addEventListener('error', () => reject(new Error('Failed to load: '+src)));
      return;
    }
    const s = document.createElement('script');
    s.src = src;
    s.async = true;
    s.crossOrigin = 'anonymous';
    s.referrerPolicy = 'no-referrer';
    s.dataset.dynamicSrc = src;
    s.addEventListener('load', () => { s.dataset.loaded = 'true'; resolve(); });
    s.addEventListener('error', () => reject(new Error('Failed to load: '+src)));
    document.head.appendChild(s);
  });
}

// Export implementation moved to export.service.js

function serializeDocument(){
  const payload = {
    schema: (typeof SCHEMA_VERSION === 'number' ? SCHEMA_VERSION : 1),
    app: (typeof APP_VERSION === 'string' ? APP_VERSION : ''),
    document: Model.document
  };
  return JSON.stringify(payload);
}
function normalizeDocument(doc){
  const out = (doc && typeof doc === 'object') ? doc : { pages: [], currentPageId:'', nextElementId:1, editMode:false };
  if (!Array.isArray(out.pages)) out.pages = [];
  if (typeof out.currentPageId !== 'string') out.currentPageId = out.pages[0]?.id || '';
  if (typeof out.nextElementId !== 'number') out.nextElementId = 1;
  if (typeof out.editMode !== 'boolean') out.editMode = false;
  return out;
}
function migrateDocument(doc, fromVersion){
  let d = normalizeDocument(doc);
  const to = (typeof SCHEMA_VERSION === 'number' ? SCHEMA_VERSION : 1);
  // For now schemas are identical. Place future migrations here.
  if (fromVersion === to) return d;
  // Example: if (fromVersion === 0) { /* mutate d to new shape */ }
  return d;
}
function deserializeDocument(json){
  const parsed = JSON.parse(json);
  // Back-compat: older saves stored raw document object
  if (parsed && Array.isArray(parsed.pages)) {
    Model.document = normalizeDocument(parsed);
    return;
  }
  // New format wrapper
  if (parsed && parsed.document) {
    const fromSchema = Number(parsed.schema || 1);
    const doc = migrateDocument(parsed.document, fromSchema);
    Model.document = normalizeDocument(doc);
    return;
  }
  // Fallback: keep existing in-memory document
}
function download(filename, content, type='text/html'){
  const blob = new Blob([content], { type });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
}

// Save button UI feedback (both editor and hub buttons)
function getSaveBtns(){
  const a = document.getElementById('saveBtn');
  const b = document.getElementById('hubSaveBtn');
  return [a,b].filter(Boolean);
}
function indicateSaving(){
  getSaveBtns().forEach((btn) => {
    btn.classList.remove('saved');
    btn.classList.add('saving');
    btn.setAttribute('aria-busy', 'true');
    if (!btn.dataset.originalText) btn.dataset.originalText = btn.textContent || 'Save';
    btn.textContent = 'Saving…';
    // Watchdog to avoid getting stuck
    if (btn._saveWatchdog) clearTimeout(btn._saveWatchdog);
    btn._saveWatchdog = setTimeout(() => {
      if (btn.classList.contains('saving')){
        btn.classList.remove('saving');
        btn.removeAttribute('aria-busy');
        btn.textContent = btn.dataset.originalText || 'Save';
      }
    }, 8000);
  });
}
function indicateSaved(){
  getSaveBtns().forEach((btn) => {
    btn.classList.remove('saving');
    btn.classList.add('saved');
    btn.removeAttribute('aria-busy');
    btn.textContent = 'Saved';
    if (btn._saveResetTimer) clearTimeout(btn._saveResetTimer);
    btn._saveResetTimer = setTimeout(() => {
      btn.classList.remove('saved');
      btn.textContent = btn.dataset.originalText || 'Save';
    }, 1500);
  });
}

// ---- Extension Save Bridge ----
// Trigger the Chrome extension content script to perform a save (without faking Ctrl+S)
function triggerExtensionSave(){
  try { document.dispatchEvent(new CustomEvent('cm-request-save')); } catch {}
}
// Listen for lifecycle events from the content script to drive existing UI indicators
document.addEventListener('cm-save-start', () => { try { indicateSaving(); } catch {} });
document.addEventListener('cm-save-done', () => { try { indicateSaved(); } catch {} });
document.addEventListener('cm-save-error', (e) => { try { indicateSaved(); console.warn('[Save] error:', e?.detail?.error); } catch {} });

// ---------------- OPFS (Origin Private File System) helpers ----------------
// Scope autosave per file by deriving a stable key from the current path
function getFileScopeId(){
  try {
    const path = (window && window.location && window.location.pathname) ? window.location.pathname : '';
    const key = path.replace(/[^a-z0-9\-_.]/gi, '_').toLowerCase();
    return key || 'index';
  } catch (_) {
    return 'index';
  }
}
function getOpfsAutosaveName(){
  return `autosave-${getFileScopeId()}.json`;
}
function supportsOPFS(){
  return typeof navigator !== 'undefined' && navigator.storage && navigator.storage.getDirectory;
}
async function opfsGetRoot(){
  return await navigator.storage.getDirectory();
}
async function opfsWriteFile(filename, text){
  const root = await opfsGetRoot();
  const fh = await root.getFileHandle(filename, { create: true });
  const w = await fh.createWritable();
  await w.write(text);
  await w.close();
}
async function opfsReadTextIfExists(filename){
  try {
    const root = await opfsGetRoot();
    const fh = await root.getFileHandle(filename, { create: false });
    const file = await fh.getFile();
    return await file.text();
  } catch (_) {
    return null;
  }
}

// LocalStorage fallback for silent autosave when OPFS isn't available
function localAutosaveKey(){
  return `certificateMaker:autosave:v1:${getFileScopeId()}`;
}
function localSaveDocument(){
  try {
    const json = serializeDocument();
    localStorage.setItem(localAutosaveKey(), json);
    return true;
  } catch (_) { return false; }
}
function localLoadDocument(){
  try {
    const json = localStorage.getItem(localAutosaveKey());
    return json || null;
  } catch (_) { return null; }
}

// File System Access API helpers for silent saves after initial user selection
let currentFileHandle = null;
function supportsFileSystemAccess(){
  return typeof window !== 'undefined' && 'showSaveFilePicker' in window;
}
function buildSaveHtml(){
  const documentData = serializeDocument();
  // HTML-escape to keep JSON safe inside markup
  const escaped = String(documentData)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
  let html = document.documentElement.outerHTML;
  // If an embedded payload already exists, replace it
  const preRe = /<pre\s+id=["']__doc__["'][^>]*>[\s\S]*?<\/pre>/i;
  if (preRe.test(html)){
    return html.replace(preRe, `<pre id="__doc__" style="display:none">${escaped}</pre>`);
  }
  // Otherwise, inject right after the opening <body ...>
  const bodyOpenRe = /<body([^>]*)>/i;
  return html.replace(bodyOpenRe, (m, attrs) => `<body${attrs}>\n  <pre id="__doc__" style="display:none">${escaped}</pre>`);
}

// Attempt to load latest autosave snapshot (OPFS or localStorage) when embedded doc not present
async function __tryLoadAutosaveSnapshot(){
  if (window.__docLoaded) return false; // already have a document
  let loaded = false;
  const scopeId = (function(){
    try { return getFileScopeId ? getFileScopeId() : (location.pathname||'index.html').replace(/[^a-z0-9\-_.]/gi,'_').toLowerCase(); } catch { return 'index'; }
  })();
  // 1) OPFS snapshot (saved by silent Persistence.saveDocument) => full HTML file containing <pre id="__doc__">
  try {
    if (!loaded && navigator.storage?.getDirectory){
      const root = await navigator.storage.getDirectory();
      const fname = `${scopeId}-autosave.html`;
      let fh = null;
      try { fh = await root.getFileHandle(fname, { create:false }); } catch {}
      if (fh){
        try {
          const file = await fh.getFile(); const html = await file.text();
          const m = html.match(/<pre\s+id=["']__doc__["'][^>]*>([\s\S]*?)<\/pre>/i);
            if (m && m[1]) {
              try { deserializeDocument(m[1].replaceAll('&lt;','<')); window.__docLoaded = true; loaded = true; console.info('[App] Loaded OPFS autosave snapshot'); } catch(e){ console.warn('[App] Failed to deserialize OPFS snapshot', e); }
            }
        } catch {}
      }
    }
  } catch(e){ try { console.warn('[App] OPFS autosave load error', e); } catch {} }
  // 2) localStorage snapshot (Persistence may have stored full HTML) or legacy JSON
  if (!loaded){
    try {
      const lsKey = `certificateMaker:autosave:v1:${scopeId}`;
      const raw = localStorage.getItem(lsKey);
      if (raw){
        let jsonPayload = null;
        if (/^\s*\{/.test(raw)) { // looks like pure JSON
          jsonPayload = raw;
        } else {
          // assume full HTML; extract embedded pre
            const m2 = raw.match(/<pre\s+id=["']__doc__["'][^>]*>([\s\S]*?)<\/pre>/i);
            if (m2 && m2[1]) jsonPayload = m2[1].replaceAll('&lt;','<');
        }
        if (jsonPayload){
          try { deserializeDocument(jsonPayload); window.__docLoaded = true; loaded = true; console.info('[App] Loaded localStorage autosave snapshot'); } catch(e){ console.warn('[App] Failed to deserialize localStorage snapshot', e); }
        }
      }
    } catch(e){ try { console.warn('[App] localStorage autosave load error', e); } catch {} }
  }
  return loaded;
}
async function verifyPermission(fileHandle, withWrite){
  const opts = {};
  if (withWrite) opts.mode = 'readwrite';
  if ((await fileHandle.queryPermission(opts)) === 'granted') return true;
  if ((await fileHandle.requestPermission(opts)) === 'granted') return true;
  return false;
}
async function writeFile(handle, content){
  const ok = await verifyPermission(handle, true);
  if (!ok) throw new Error('Permission denied');
  const writable = await handle.createWritable();
  await writable.write(content);
  await writable.close();
}


async function saveDocument(){
  // Update inline snapshot first
  try { if (AppState?.activeDocId) InlineDocs.set(AppState.activeDocId, Model.document); } catch {}
  // Show immediate feedback (extension will also emit start)
  try { indicateSaving(); } catch {}
  // Ask extension to perform the actual disk write
  triggerExtensionSave();
  // Do NOT call indicateSaved() here; we wait for cm-save-done / cm-save-error
}

function getCurrentFilename(){
  // Extract filename from the current URL
  const path = window.location.pathname;
  const filename = path.split('/').pop();
  
  // Return filename if it's an HTML file, otherwise null
  if (filename && filename.toLowerCase().endsWith('.html')) {
    return filename;
  }
  
  return null;
}

async function saveDocumentAs(){
  indicateSaving();
  try {
    const res = await Persistence.saveDocumentAs();
    if (res && res.ok) { indicateSaved(); return; }
  } catch {}
}


/* ----------------------- Init & Events ----------------------- */
async function bootstrap(){
  try { console.info('[App] bootstrap start'); } catch {}
  // When running in editor view, we'll load from InlineDocs if available; otherwise fall back
  let loaded = false;
  try {
    const hv = document.getElementById('hubView');
    const ev = document.getElementById('editorView');
    // If hub is visible on first load, don't load a document yet
    if (hv && !hv.hidden && ev && ev.hidden) {
      loaded = true; // defer loading until a doc is opened
    }
  } catch {}
  // Try to auto-load an embedded document (when opening a file saved via Save As)
  if (!loaded){
    try {
      if (window.Persistence && typeof Persistence.tryAutoLoad === 'function'){
        const res = await Persistence.tryAutoLoad();
        if (res && res.ok){
          loaded = true;
          try { console.info('[App] Embedded document loaded via', res.via); } catch {}
          // Switch to editor view so the loaded doc is visible immediately
          setView('editor');
        }
      }
    } catch (e) { try { console.warn('[App] Embedded load failed', e); } catch {} }
  }
  // Attempt OPFS/localStorage autosave snapshot if no embedded doc
  if (!loaded){
    try {
      const snap = await __tryLoadAutosaveSnapshot();
      if (snap){ loaded = true; setView('editor'); }
    } catch {}
  }
  // Disable auto-load of previous autosave; start with empty doc unless embedded
  if (!loaded){ loaded = false; }
  if (!loaded){
    Model.document.pages = [createPage('Page 1')];
    Model.document.currentPageId = Model.document.pages[0].id;
  }
  // Apply initial mode before rendering to avoid flicker
  setEditMode(!!Model.document.editMode);
  renderAll();
  // Try to restore file handle for silent saves across reloads
  try { if (window.Persistence && typeof Persistence.restoreHandle === 'function') { const ok = await Persistence.restoreHandle(); try { console.info('[App] restoreHandle:', ok); } catch {} } } catch {}
  // Silent-disk banner removed per request; no auto UI injected on startup

  // elements panel
  elementsPanel().addEventListener('click', (e) => {
    const btn = e.target.closest('.add-el');
    if (!btn) return;
    // If a drag just completed, ignore the click that follows
    if (__addingByDrag) { __addingByDrag = false; return; }
    addElementToVisiblePage(btn.dataset.add);
  });

  // Make element buttons draggable for drag-to-place
  try {
    elementsPanel().querySelectorAll('.add-el').forEach((btn) => {
      btn.setAttribute('draggable', 'true');
      btn.addEventListener('dragstart', (ev) => {
        try { ev.dataTransfer.setData('text/plain', btn.dataset.add); } catch {}
        ev.dataTransfer.effectAllowed = 'copy';
      });
    });
  } catch {}

  // canvas interactions: delegate to clicked page; support add-to-clicked-page and drag-to-place
  pagesList().addEventListener('mousedown', (e) => {
    const page = e.target.closest('.page');
    if (!page) return;
    const wrap = page.closest('.page-wrapper');
    const pageId = wrap?.dataset.pageId;
    if (!pageId) return;
    if (pendingAddType){
      Model.document.currentPageId = pageId;
      const pt = getCanvasPoint(e, page);
      placePendingAt(pt.x, pt.y, pageId);
      e.preventDefault();
      return;
    }
    const targetEl = e.target.closest('.element');
    if (!targetEl){
      // Disable lasso in view mode
      if (!Model || !Model.document || !Model.document.editMode) return;
      // If user is resizing header/footer, do not start a lasso
      const isHFResize = !!e.target.closest('.hf-resize');
      if (isHFResize) { e.preventDefault(); return; }
      // Starting a lasso selection: cancel any pending element drag promotion from a prior click
      dragMaybe = null;
      drag = null;
      // Prevent accidental UI text selection while lassoing
      document.body.classList.add('app-noselect');
      e.preventDefault();
      // lasso on drag only; click without movement just clears/keeps selection
      const start = { x: e.clientX, y: e.clientY };
      const lasso = document.getElementById('lasso');
      let additive = e.shiftKey || e.ctrlKey || e.metaKey;
      let moved = false;
      const onMove = (ev) => {
        const dx = ev.clientX - start.x; const dy = ev.clientY - start.y;
        if (Math.abs(dx) < 4 && Math.abs(dy) < 4) return; // threshold
        moved = true;
        lasso.hidden = false;
        const left = Math.min(start.x, ev.clientX);
        const top = Math.min(start.y, ev.clientY);
        const w = Math.abs(dx); const h = Math.abs(dy);
        Object.assign(lasso.style, { left:left+'px', top:top+'px', width:w+'px', height:h+'px' });
        const hits = [];
        document.querySelectorAll('.page .element').forEach(node => {
          const r = node.getBoundingClientRect();
          const inter = !(left > r.left + r.width || left + w < r.left || top > r.top + r.height || top + h < r.top);
          if (inter) hits.push(node.dataset.id);
        });
        additive ? setSelection([...selectedIds, ...hits]) : setSelection(hits);
      };
      const onUp = () => {
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        document.body.classList.remove('app-noselect');
        lasso.hidden = true;
        if (!moved) {
          // click without movement toggles/clears selection
          additive ? null : clearSelection();
        }
      };
      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
      return;
    }
    if (getPageNode() === page) onMouseDown(e);
  });

  // Drag-over/drop to place element where dropped
  pagesList().addEventListener('dragover', (e) => {
    const page = e.target.closest('.page');
    if (!page) return;
    const type = (e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types.includes('text/plain')) ? 'ok' : null;
    if (!type) return;
    e.preventDefault();
    // Stop bubbling so the viewport dragover doesn't also run
    if (e.stopPropagation) e.stopPropagation();
    e.dataTransfer.dropEffect = 'copy';
  });
  pagesList().addEventListener('drop', (e) => {
    const page = e.target.closest('.page');
    if (!page) return;
    const wrap = page.closest('.page-wrapper');
    const pageId = wrap?.dataset.pageId;
    if (!pageId) return;
    let type = '';
    try { type = e.dataTransfer.getData('text/plain'); } catch { type = ''; }
    if (!type) return;
    e.preventDefault();
    // Stop bubbling so the viewport drop handler doesn't also place the element
    if (e.stopPropagation) e.stopPropagation();
    const pt = getCanvasPoint(e, page);
    Model.document.currentPageId = pageId;
    pendingAddType = type;
    placePendingAt(pt.x, pt.y, pageId);
    __addingByDrag = true; // consume immediate click after drop
  });
  // Allow starting a lasso selection from outside of any page within the viewport
  const viewportEl = document.getElementById('pageViewport');
  if (viewportEl){
    // Support dropping onto empty viewport areas too (choose most visible page)
    viewportEl.addEventListener('dragover', (e) => {
      const hasText = e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types.includes('text/plain');
      if (!hasText) return;
      // Only allow if pointer is visually over a page or we have any page visible
      const page = e.target.closest && e.target.closest('.page');
      if (!page) {
        const info = getMostVisiblePageInfo();
        if (!info) return;
      }
      e.preventDefault();
      // Prevent the event from bubbling to any parent handlers
      if (e.stopPropagation) e.stopPropagation();
      e.dataTransfer.dropEffect = 'copy';
    });
    viewportEl.addEventListener('drop', (e) => {
      let type = '';
      try { type = e.dataTransfer.getData('text/plain'); } catch { type = ''; }
      if (!type) return;
      const page = e.target.closest && e.target.closest('.page');
      if (page){
        const wrap = page.closest('.page-wrapper');
        const pageId = wrap?.dataset.pageId; if (!pageId) return;
        e.preventDefault();
        // Stop bubbling so other drop listeners don't also run
        if (e.stopPropagation) e.stopPropagation();
        const pt = getCanvasPoint(e, page);
        Model.document.currentPageId = pageId;
        pendingAddType = type;
        placePendingAt(pt.x, pt.y, pageId);
        __addingByDrag = true;
      } else {
        const info = getMostVisiblePageInfo(); if (!info) return;
        e.preventDefault();
        if (e.stopPropagation) e.stopPropagation();
        const pr = info.pageNode.getBoundingClientRect();
        const z = (typeof getZoom === 'function') ? (getZoom() || 1) : 1;
        const cx = e.clientX; const cy = e.clientY;
        const x = (cx - pr.left) / z; const y = (cy - pr.top) / z;
        Model.document.currentPageId = info.pageId;
        pendingAddType = type;
        placePendingAt(x, y, info.pageId);
        __addingByDrag = true;
      }
    });
    viewportEl.addEventListener('mousedown', (e) => {
      // If inside a page, let the page handler above manage it
      if (e.target.closest && e.target.closest('.page')) return;
      // Disable outside-page lasso in view mode
      if (!Model || !Model.document || !Model.document.editMode) return;
      // Ignore clicks on overlays/toolbars within the viewport
      const bar = formatToolbar && formatToolbar();
      if (bar && bar.contains && bar.contains(e.target)) return;
      const bubble = elementActions && elementActions();
      if (bubble && bubble.contains && bubble.contains(e.target)) return;
      const tblMenu = document.getElementById('tableMenu');
      if (tblMenu && tblMenu.contains && tblMenu.contains(e.target)) return;

      // Start lasso selection similar to inside-page behavior
      // Cancel any pending single-element drag from previous clicks
      dragMaybe = null; drag = null;
      // Prevent accidental UI text selection while lassoing
      document.body.classList.add('app-noselect');
      e.preventDefault();
      const start = { x: e.clientX, y: e.clientY };
      const lasso = document.getElementById('lasso');
      let additive = e.shiftKey || e.ctrlKey || e.metaKey;
      let moved = false;
      const onMove = (ev) => {
        const dx = ev.clientX - start.x; const dy = ev.clientY - start.y;
        if (Math.abs(dx) < 4 && Math.abs(dy) < 4) return; // threshold
        moved = true;
        lasso.hidden = false;
        const left = Math.min(start.x, ev.clientX);
        const top = Math.min(start.y, ev.clientY);
        const w = Math.abs(dx); const h = Math.abs(dy);
        Object.assign(lasso.style, { left:left+'px', top:top+'px', width:w+'px', height:h+'px' });
        const hits = [];
        document.querySelectorAll('.page .element').forEach(node => {
          const r = node.getBoundingClientRect();
          const inter = !(left > r.left + r.width || left + w < r.left || top > r.top + r.height || top + h < r.top);
          if (inter) hits.push(node.dataset.id);
        });
        additive ? setSelection([...selectedIds, ...hits]) : setSelection(hits);
      };
      const onUp = () => {
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        document.body.classList.remove('app-noselect');
        lasso.hidden = true;
        if (!moved) {
          // click without movement clears selection when outside the page
          additive ? null : clearSelection();
        }
      };
      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
    });
  }
  // Centralized window listeners (bound once)
  window.addEventListener('mousemove', onMouseMove, { passive: true });
  window.addEventListener('mouseup', onMouseUp, { passive: true });
  window.addEventListener('resize', () => { updateFormatToolbarVisibility(); alignOverlays(); });
  window.addEventListener('scroll', () => { alignOverlays(); }, true);

  // Snap/Guides toggles
  const snapToggle = document.getElementById('snapToggle');
  const guidesToggle = document.getElementById('guidesToggle');
  const rulersToggle = document.getElementById('rulersToggle');
  const minimapToggle = document.getElementById('minimapToggle');
  // Initialize header/footer guides for all pages after bootstrap
  try { document.querySelectorAll('.page').forEach(p => updateHeaderFooterGuides(p)); } catch {}
  let SNAP_ENABLED = true;
  let GUIDES_ENABLED = false; // default off per request
  function updateSnapGuides(){
    SNAP_ENABLED = !snapToggle || !!snapToggle.checked;
    GUIDES_ENABLED = !!(guidesToggle && guidesToggle.checked);
  }
  snapToggle?.addEventListener('change', updateSnapGuides);
  guidesToggle?.addEventListener('change', updateSnapGuides);
  updateSnapGuides();

  // Rulers visibility
  const rulers = document.getElementById('rulers');
  const rulerH = document.getElementById('rulerH');
  const rulerV = document.getElementById('rulerV');
  rulersToggle?.addEventListener('change', () => {
    if (!rulers) return;
    rulers.classList.toggle('hidden', !rulersToggle.checked);
    if (rulersToggle.checked) drawRulers();
  });
  if (rulers && rulersToggle && rulersToggle.checked) rulers.classList.remove('hidden');

  // Minimap visibility
  const minimap = document.getElementById('minimap');
  minimapToggle?.addEventListener('change', () => {
    if (!minimap) return;
    minimap.classList.toggle('hidden', !minimapToggle.checked);
    if (minimapToggle.checked) drawMinimap();
  });
  if (minimap && minimapToggle && minimapToggle.checked) minimap.classList.remove('hidden');

  // Document header/footer inputs
  const docHeaderInput = document.getElementById('docHeaderHeight');
  const docFooterInput = document.getElementById('docFooterHeight');
  if (docHeaderInput) docHeaderInput.value = String(Model?.document?.headerHeight || 0);
  if (docFooterInput) docFooterInput.value = String(Model?.document?.footerHeight || 0);
  function onHFChange(){
    const h = Number(docHeaderInput?.value || 0);
    const f = Number(docFooterInput?.value || 0);
    setHeaderFooterHeights({ header: h, footer: f });
  }
  docHeaderInput?.addEventListener('change', onHFChange);
  docFooterInput?.addEventListener('change', onHFChange);

  function drawRulers(){
    if (!rulers || !rulerH || !rulerV) return;
    // Simple tick marks using background gradients for performance
    const mmPerPx = 1; // not calibrated; placeholder scale
    rulerH.style.backgroundImage = `linear-gradient(to right, transparent 0, transparent 9px, #ddd 9px, #ddd 10px)`;
    rulerH.style.backgroundSize = '10px 100%';
    rulerV.style.backgroundImage = `linear-gradient(to bottom, transparent 0, transparent 9px, #ddd 9px, #ddd 10px)`;
    rulerV.style.backgroundSize = '100% 10px';
  }

  function drawMinimap(){
    if (!minimap) return; const ctx = minimap.getContext('2d'); if (!ctx) return;
    const page = getPageNode(); if (!page) { ctx.clearRect(0,0,minimap.width,minimap.height); return; }
    const pr = page.getBoundingClientRect();
    const scale = Math.min(minimap.width / pr.width, minimap.height / pr.height);
    ctx.clearRect(0,0,minimap.width,minimap.height);
    ctx.fillStyle = '#fff'; ctx.fillRect(0,0,minimap.width,minimap.height);
    ctx.strokeStyle = '#ddd'; ctx.strokeRect(0.5,0.5,Math.round(pr.width*scale)-1,Math.round(pr.height*scale)-1);
    // Draw elements
    const p = getCurrentPage(); if (!p) return;
    p.elements.forEach(el => {
      const x = Math.round(el.x * scale); const y = Math.round(el.y * scale);
      const w = Math.max(1, Math.round((el.w||1) * scale)); const h = Math.max(1, Math.round((el.h||1) * scale));
      ctx.fillStyle = '#8888ff';
      ctx.globalAlpha = 0.5; ctx.fillRect(x, y, w, h); ctx.globalAlpha = 1;
      ctx.strokeStyle = '#6666cc'; ctx.strokeRect(x+0.5, y+0.5, w-1, h-1);
    });
  }

  // Keep rulers/minimap in sync
  ['scroll','resize'].forEach(evt => window.addEventListener(evt, () => { drawRulers(); if (minimap && !minimap.classList.contains('hidden')) drawMinimap(); }, { passive:true }));

  // text/field/rect editing (field editable even when edit mode is off)
  pagesList().addEventListener('dblclick', (e) => {
    const active = getPageNode();
    if (!active || !active.contains(e.target)) return;

    const elNode = e.target.closest('.element.text, .element.field, .element.rect');
    if (!elNode) return;

    // Only block editing when it's a text or rect element AND edit mode is off
    if ((elNode.classList.contains('text') || elNode.classList.contains('rect')) && !Model.document.editMode) return;

    // Prevent selection/move logic from running on this click and cancel any drags
    drag = null; dragMaybe = null; dragSelection = null; resize = null; rotateSelectionState = null; resizeSelectionState = null;
    e.stopPropagation();
    e.preventDefault();

    const id = elNode.dataset.id;
    setSelection([id]);

    // If element has placeholder, clear it when starting to edit
    if (elNode.classList.contains('has-placeholder')) {
      elNode.textContent = '';
      elNode.classList.remove('has-placeholder');
    }

    // If formula exists, show the formula text while editing; otherwise show content
    try {
      const model = getElementById(id);
      const existingFormula = String(model?.attrs?.formula || '').trim();
      if (existingFormula){ elNode.textContent = existingFormula; }
    } catch {}

    // Use plaintext-only to ensure Enter inserts a newline and no HTML is injected
    elNode.setAttribute('contenteditable', 'plaintext-only');
    elNode.classList.add('editing');
    elNode.focus();

    // Track cancel to support Esc behavior (discard changes)
    let cancelled = false;
    const insertNewlineAtCaret = () => {
      try {
        const sel = window.getSelection(); if (!sel) return; if (sel.rangeCount === 0) { elNode.textContent = (elNode.textContent||'') + "\n"; return; }
        const range = sel.getRangeAt(0);
        range.deleteContents();
        const textNode = document.createTextNode("\n");
        range.insertNode(textNode);
        range.setStartAfter(textNode);
        range.collapse(true);
        sel.removeAllRanges(); sel.addRange(range);
      } catch {}
    };

    const onBlur = () => {
      elNode.removeEventListener('blur', onBlur);
      elNode.removeEventListener('keydown', onKey);
      // Stop inline picker if active
      try { if (elNode._pickerDoneRef) { elNode._pickerDoneRef(); } } catch {}
      elNode.setAttribute('contenteditable', 'false');
      elNode.classList.remove('editing');
      if (cancelled){
        // Re-render to restore original value
        renderPage(getCurrentPage());
        return;
      }
      const text = elNode.textContent || '';
      // If starts with '=', treat as formula and store into attrs.formula; otherwise content
      if (text.trim().startsWith('=')){
        applyPatchToSelection(toPatch('attrs.formula', text.trim()));
        // Recalculate now so user sees value
        try { if (typeof window.recalculateAllFormulas === 'function') window.recalculateAllFormulas(); } catch {}
        const m = getElementById(id);
        updateElement(id, { content: m?.content || '' });
      } else {
        updateElement(id, { content: text });
      }
      
      // Re-render to show placeholder if content is empty
      if (!text) {
        renderPage(getCurrentPage());
      }
    };
    const onKey = (ke) => {
      if (ke.key === 'Enter' && ke.shiftKey){
        // New line, keep editing
        ke.preventDefault();
        insertNewlineAtCaret();
        return;
      }
      if (ke.key === 'Enter' && !ke.shiftKey){
        // Commit and exit
        ke.preventDefault();
        elNode.blur();
        return;
      }
      if (ke.key === 'Escape'){
        // Cancel and exit
        ke.preventDefault();
        cancelled = true;
        elNode.blur();
      }
    };
    elNode.addEventListener('blur', onBlur);
    elNode.addEventListener('keydown', onKey);

    // If we entered edit mode with an existing formula, auto-enable picker
    try {
      const txtNow = String(elNode.textContent || '');
      if (txtNow.trim().startsWith('=')) { startInlineFormulaPicker(elNode); }
    } catch {}
  });

  // edit mode toggle button
  const etb = (typeof editToggleBtn === 'function') ? editToggleBtn() : document.getElementById('editToggleBtn');
  if (etb){
    etb.addEventListener('click', () => setEditMode(!Model.document.editMode));
  }

  // per-page controls exist inside each wrapper; no global page strip

  // undo/redo
  undoBtn().addEventListener('click', undo);
  redoBtn().addEventListener('click', redo);

  // Keyboard shortcuts: Undo/Redo
  // - Ctrl/Cmd + Z => Undo
  // - Ctrl/Cmd + Shift + Z or Ctrl/Cmd + Y => Redo
  document.addEventListener('keydown', (e) => {
    const active = document.activeElement;
    const isEditing = active && (
      active.contentEditable === 'true' ||
      active.contentEditable === 'plaintext-only' ||
      active.tagName === 'INPUT' ||
      active.tagName === 'TEXTAREA'
    );
    if (isEditing) return; // let native undo work while typing

    if (e.ctrlKey || e.metaKey) {
      const k = String(e.key || '').toLowerCase();
      if (k === 'z') {
        e.preventDefault();
        if (e.shiftKey) { redo(); } else { undo(); }
      } else if (k === 'y') {
        e.preventDefault();
        redo();
      }
    }
  });

  // keyboard shortcuts for copy/paste (element-level)
  // IMPORTANT: if a table selection exists, DO NOT intercept copy/paste here.
  // But for Ctrl+Shift+V, set a flag to request values-only paste before letting native paste fire.
  document.addEventListener('keydown', (e) => {
    const isEditing = document.activeElement && (
      document.activeElement.contentEditable === 'true' ||
      document.activeElement.contentEditable === 'plaintext-only' ||
      document.activeElement.tagName === 'INPUT' ||
      document.activeElement.tagName === 'TEXTAREA'
    );
    if (isEditing) return;

    // If a table selection is active, allow default so our 'copy'/'paste' listeners run.
    // For Ctrl+Shift+V, mark values-only paste before letting the paste event proceed.
    if (tableSel && (e.ctrlKey || e.metaKey)) {
      if (e.key === 'v' || e.key === 'V') {
        if (e.shiftKey) {
          try { window.__valuesOnlyPaste = true; } catch { window.__valuesOnlyPaste = true; }
        }
        return;
      }
      if (e.key === 'c' || e.key === 'C') {
        return;
      }
    }

    if ((e.ctrlKey || e.metaKey) && e.key === 'c' && selectedIds.size > 0) {
      e.preventDefault();
      copyToClipboard();
    } else if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
      e.preventDefault();
      pasteFromClipboard();
    } else if ((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === 'v' || e.key === 'V')) {
      // Ctrl+Shift+V: values-only paste for tables; do not intercept table selection copy/paste above
      if (tableSel) return; // allow table paste listener to handle
      try { window.__valuesOnlyPaste = true; } catch { window.__valuesOnlyPaste = true; }
      // Trigger native paste event to reuse table handler if a table anchor exists, otherwise element-level paste
      const evt = new ClipboardEvent('paste', { bubbles: true });
      document.dispatchEvent(evt);
    }
  });

  // While editing a text/field/rect, if typing begins with '=', switch to formula mode and enable picker
  pagesList().addEventListener('keydown', (e) => {
    const elNode = e.target && e.target.closest && e.target.closest('.element.text, .element.field, .element.rect');
    if (!elNode) return;
    if (elNode.getAttribute('contenteditable') !== 'plaintext-only') return;
    if (e.key === '=' && elNode.textContent === ''){
      // Insert '=' and optionally allow picking elements by clicking while holding Alt
      e.preventDefault();
      elNode.textContent = '=';
      try { startInlineFormulaPicker(elNode); } catch {}
    }
  });

  // Inline picker that inserts #id tokens into a contenteditable host while composing a formula
  function startInlineFormulaPicker(host){
    if (window.__PICKING) return () => {};
    const prevSelIds = Array.from(document.querySelectorAll('.page .element.selected'))
      .map(n => n && n.getAttribute('data-id'))
      .filter(Boolean);
    const pageEl = document.querySelector('.page'); if (!pageEl) return;
    let last;
    window.__PICKING = true; document.body.classList.add('app-noselect');
    const blockDown = (ev) => { ev.stopPropagation(); ev.preventDefault(); };
    document.addEventListener('pointerdown', blockDown, true);
    document.addEventListener('mousedown', blockDown, true);
    const onMove = (ev) => {
      const cell = ev.target.closest('.table-cell');
      const el = cell || ev.target.closest('.page .element');
      if (last === el) return; if (last) last.style.outline = ''; last = el; if (last) last.style.outline = '2px solid var(--primary)';
    };
    const done = () => {
      document.removeEventListener('mousemove', onMove, true);
      document.removeEventListener('click', onClick, true);
      document.removeEventListener('keydown', onKey, true);
      document.removeEventListener('pointerdown', blockDown, true);
      document.removeEventListener('mousedown', blockDown, true);
      if (last) last.style.outline = '';
      window.__PICKING = false; document.body.classList.remove('app-noselect');
      if (Array.isArray(prevSelIds) && prevSelIds.length && typeof setSelection === 'function') setSelection(prevSelIds);
      try { host._pickerDoneRef = null; } catch {}
    };
    const onKey = (ke) => { if (ke.key === 'Escape'){ ke.preventDefault(); done(); } };
    const onClick = (ev) => {
      const cell = ev.target.closest('.table-cell');
      const el = cell || ev.target.closest('.page .element');
      if (!el) { done(); return; }
      ev.preventDefault(); ev.stopPropagation();
      let token = '';
      if (cell){ const cid = cell.getAttribute('data-id'); if (cid) token = `"#${cid}"`; }
      else { const id = el.getAttribute('data-id'); if (id) token = `"#${id}"`; }
      // Insert token at end (no extra spaces; quotes make it distinct)
      host.textContent = String(host.textContent || '') + token;
      host.focus();
    };
    document.addEventListener('mousemove', onMove, true);
    document.addEventListener('click', onClick, true);
    document.addEventListener('keydown', onKey, true);
    try { host._pickerDoneRef = done; } catch {}
    return done;
  }
  try { window.startInlineFormulaPicker = startInlineFormulaPicker; } catch {}

  // save and export
  saveBtn().addEventListener('click', saveDocument);
  // Hook up More menu items (Save As / Exports)
  const moreBtn = document.getElementById('moreMenuBtn');
  const moreMenu = document.getElementById('moreMenu');
  if (moreBtn && moreMenu){
    const toggleMenu = (open) => {
      const willOpen = typeof open === 'boolean' ? open : moreMenu.classList.contains('hidden');
      moreMenu.classList.toggle('hidden', !willOpen);
      moreBtn.setAttribute('aria-expanded', String(willOpen));
    };
    moreBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleMenu(); });
    document.addEventListener('click', (e) => { if (!moreMenu.contains(e.target) && e.target !== moreBtn) toggleMenu(false); });
  }
  // Hub view: minimal More menu (Settings only)
  const hubMoreBtn = document.getElementById('hubMoreMenuBtn');
  const hubMoreMenu = document.getElementById('hubMoreMenu');
  if (hubMoreBtn && hubMoreMenu){
    const toggleHubMenu = (open) => {
      const willOpen = typeof open === 'boolean' ? open : hubMoreMenu.classList.contains('hidden');
      hubMoreMenu.classList.toggle('hidden', !willOpen);
      hubMoreBtn.setAttribute('aria-expanded', String(willOpen));
    };
    hubMoreBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleHubMenu(); });
    document.addEventListener('click', (e) => { if (!hubMoreMenu.contains(e.target) && e.target !== hubMoreBtn) toggleHubMenu(false); });
  }
  // Settings dialog wiring
  (function bindSettings(){
    const openBtn = document.getElementById('settingsBtn');
    const hubOpenBtn = document.getElementById('hubSettingsBtn');
    const dialog = document.getElementById('settingsDialog');
    const closeBtn = document.getElementById('settingsCloseBtn');
    const autoToggle = document.getElementById('autosaveToggle');
    function sync(){ try { if (autoToggle){ const on = Settings.get('autosaveEnabled') !== false; autoToggle.checked = !!on; const span = autoToggle.nextElementSibling; if (span) span.textContent = on ? 'On' : 'Off'; } } catch {} }
    function open(){ if (!dialog) return; sync(); dialog.classList.remove('hidden'); }
    function close(){ if (!dialog) return; dialog.classList.add('hidden'); }
    if (openBtn) openBtn.addEventListener('click', (e)=>{ e.stopPropagation(); open(); });
    if (hubOpenBtn) hubOpenBtn.addEventListener('click', (e)=>{ e.stopPropagation(); try { hubMoreMenu?.classList.add('hidden'); hubMoreBtn?.setAttribute('aria-expanded','false'); } catch{} open(); });
    if (closeBtn) closeBtn.addEventListener('click', close);
    if (dialog) dialog.addEventListener('click', (e)=>{ if (e.target === dialog) close(); });
    document.addEventListener('keydown', (e)=>{ if (dialog && !dialog.classList.contains('hidden') && e.key === 'Escape') close(); });
    if (autoToggle) autoToggle.addEventListener('change', ()=>{ const on = !!autoToggle.checked; Settings.set('autosaveEnabled', on); const span = autoToggle.nextElementSibling; if (span) span.textContent = on ? 'On' : 'Off'; });
  })();
  const saveAs = document.getElementById('saveAsBtn');
  if (saveAs) saveAs.addEventListener('click', saveDocumentAs);
  const pngBtn = document.getElementById('exportPngBtn');
  const jpgBtn = document.getElementById('exportJpgBtn');
  const pdfBtn = document.getElementById('savePdfBtn');
  if (pdfBtn) pdfBtn.addEventListener('click', () => ExportService.exportDocumentToPdf());
  if (pngBtn) pngBtn.addEventListener('click', () => ExportService.exportCurrentPageToImage({ format: 'png' }));
  if (jpgBtn) jpgBtn.addEventListener('click', () => ExportService.exportCurrentPageToImage({ format: 'jpg', quality: 0.85 }));
  
  // floating toolbar wiring
  bindFloatingToolbar();

  // Layers UI removed per request (keep app logic intact)

  // table clipboard handlers
  bindTableClipboard();

  // Initial zoom
  setZoomScale(1);
  if (zoomSlider()){
    zoomSlider().addEventListener('input', (e) => {
      const target = (Number(e.target.value)||100)/100;
      zoomAtViewportCenter(target);
    });
  }
  // Ctrl/Cmd + wheel zoom over page only, keep cursor fixed
  window.addEventListener('wheel', (e) => {
    const overWorkspace = !!(e.target.closest && (e.target.closest('.page') || e.target.closest('#pageViewport')));
    if (!overWorkspace) return;
    if (!e.ctrlKey && !e.metaKey) return;
    e.preventDefault();
    const dir = e.deltaY > 0 ? -1 : 1;
    const factor = dir > 0 ? 1.05 : 0.95;
    const next = getZoom() * factor;
    const vpRect = document.getElementById('pageViewport').getBoundingClientRect();
    const cx = Math.max(vpRect.left, Math.min(e.clientX, vpRect.right));
    const cy = Math.max(vpRect.top,  Math.min(e.clientY, vpRect.bottom));
    zoomAtClientPoint(cx, cy, next);
  }, { passive:false });
  // Safari pinch gestures
  window.addEventListener('gesturestart',  (e) => { if (e.target.closest && (e.target.closest('.page') || e.target.closest('#pageViewport'))) e.preventDefault(); }, { passive:false });
  window.addEventListener('gesturechange', (e) => {
    if (!(e.target.closest && (e.target.closest('.page') || e.target.closest('#pageViewport')))) return;
    e.preventDefault();
    zoomAtClientPoint(e.clientX, e.clientY, getZoom() * e.scale);
  }, { passive:false });

  // element actions wiring
  const actions = elementActions();
  actions.addEventListener('click', (e) => {
    const menuToggle = e.target.closest('[data-menu]');
    if (menuToggle) {
      const key = menuToggle.dataset.menu;
      const panel = actions.querySelector(`[data-menu-panel="${key}"]`);
      panel.classList.toggle('hidden');
      return;
    }
    const btn = e.target.closest('[data-action],[data-z],[data-group],[data-group-toggle],[data-align],[data-distribute]'); if (!btn) return;
    if (btn.hasAttribute('data-group-toggle')) { toggleGroupSelection(); updateGroupToggleButton(); return; }
    if (selectedIds.size===0) return;
    if (btn.dataset.action === 'copy') {
      copySelection();
    } else if (btn.dataset.action === 'delete') {
      deleteSelection();
    } else if (btn.dataset.action === 'duplicate') {
      copySelection();
    } else if (btn.dataset.z) {
      if (btn.dataset.z === 'front') sendSelectionToFront();
      else if (btn.dataset.z === 'back') sendSelectionToBack();
      else if (btn.dataset.z === 'up') bringSelectionForward();
      else if (btn.dataset.z === 'down') sendSelectionBackward();
      // close dropdown after action
      const open = actions.querySelector('[data-menu-panel]'); if (open) open.classList.add('hidden');
    } else if (btn.dataset.align) {
      alignSelection(btn.dataset.align);
    } else if (btn.dataset.distribute) {
      distributeSelection(btn.dataset.distribute);
    }
  });

  // Close dropdown on outside click or ESC
  document.addEventListener('click', (e) => {
    const panel = actions.querySelector('[data-menu-panel]');
    if (!panel) return; if (panel.classList.contains('hidden')) return;
    if (!actions.contains(e.target)) panel.classList.add('hidden');
  });

  // Command palette (Ctrl/Cmd+K)
  const cp = document.getElementById('commandPalette');
  const ci = document.getElementById('commandInput');
  const cl = document.getElementById('commandList');
  const COMMANDS = [
    { id:'duplicate', label:'Duplicate selection (Ctrl+D)', run: ()=> copySelection() },
    { id:'delete', label:'Delete selection (Del)', run: ()=> deleteSelection() },
    { id:'group', label:'Group selection', run: ()=> groupSelection() },
    { id:'ungroup', label:'Ungroup selection', run: ()=> ungroupSelection() },
    { id:'align-left', label:'Align Left', run: ()=> alignSelection('left') },
    { id:'align-center', label:'Align Center', run: ()=> alignSelection('center') },
    { id:'align-right', label:'Align Right', run: ()=> alignSelection('right') },
    { id:'align-top', label:'Align Top', run: ()=> alignSelection('top') },
    { id:'align-middle', label:'Align Middle', run: ()=> alignSelection('middle') },
    { id:'align-bottom', label:'Align Bottom', run: ()=> alignSelection('bottom') },
    { id:'distribute-h', label:'Distribute Horizontally', run: ()=> distributeSelection('h') },
    { id:'distribute-v', label:'Distribute Vertically', run: ()=> distributeSelection('v') },
    { id:'export-png', label:'Export current page (PNG)', run: ()=> ExportService.exportCurrentPageToImage({format:'png'}) },
    { id:'export-jpg', label:'Export current page (JPG)', run: ()=> ExportService.exportCurrentPageToImage({format:'jpg'}) },
    { id:'export-pdf', label:'Export document (PDF)', run: ()=> ExportService.exportDocumentToPdf() },
  ];
  function openPalette(){ if (!cp) return; cp.classList.remove('hidden'); ci.value=''; renderCmds(''); ci.focus(); }
  function closePalette(){ if (!cp) return; cp.classList.add('hidden'); }
  function renderCmds(q){ if (!cl) return; const qq = q.trim().toLowerCase(); cl.innerHTML=''; COMMANDS.filter(c=>c.label.toLowerCase().includes(qq)).forEach(c=>{ const b=document.createElement('button'); b.className='btn'; b.textContent=c.label; b.style.justifyContent='flex-start'; b.addEventListener('click', ()=>{ c.run(); closePalette(); }); cl.appendChild(b); }); }
  document.addEventListener('keydown', (e)=>{
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') { e.preventDefault(); openPalette(); }
    if (cp && !cp.classList.contains('hidden') && e.key === 'Escape') { e.preventDefault(); closePalette(); }
  });
  ci?.addEventListener('input', ()=> renderCmds(ci.value));
  cp?.addEventListener('click', (e)=>{ if (e.target === cp) closePalette(); });
  // Deselect elements when clicking anywhere outside of a page (but ignore editor overlays)
  document.addEventListener('mousedown', (e) => {
    const t = e.target;
    // If clicking inside a page, let page handlers manage selection
    if (t.closest && t.closest('.page')) return;
    // Ignore clicks inside overlays/toolbars that operate on the current selection
    const bar = formatToolbar && formatToolbar();
    if (bar && bar.contains && bar.contains(t)) return;
    // Do not clear selection when interacting with side panels
    const propsPanel = document.getElementById('propertiesPanel');
    if (propsPanel && propsPanel.contains && propsPanel.contains(t)) return;
    const elsPanel = document.getElementById('elementsPanel');
    if (elsPanel && elsPanel.contains && elsPanel.contains(t)) return;
    const tblMenu = document.getElementById('tableMenu');
    if (tblMenu && tblMenu.contains && tblMenu.contains(t)) return;
    const tblActions = document.getElementById('tableActions');
    if (tblActions && tblActions.contains && tblActions.contains(t)) return;
    const bubble = elementActions && elementActions();
    if (bubble && bubble.contains && bubble.contains(t)) return;
    const selBox = selectionBoxEl && selectionBoxEl();
    if (selBox && selBox.contains && selBox.contains(t)) return;
    // Otherwise, clear element selection
    if (selectedIds && selectedIds.size > 0) clearSelection();
  });

  // Element context menu (right-click) — reuse the actions bar "..." dropdown
  (function bindElementContextMenu(){
    document.addEventListener('contextmenu', (e) => {
      const el = e.target.closest?.('.element');
      if (!el) return; // allow default context menu elsewhere
      e.preventDefault();
      const id = el.dataset.id;
      if (!selectedIds.has(id)) setSelection([id]);
      // Ensure the element actions bubble is visible and positioned
      try { elementActions().classList.remove('hidden'); positionElementActions(); } catch {}
      // Open the existing actions dropdown panel
      const actionsEl = elementActions && elementActions();
      if (!actionsEl) return;
      const panel = actionsEl.querySelector('[data-menu-panel="actions"]');
      if (panel) panel.classList.remove('hidden');
    });
  })();
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      const panel = actions.querySelector('[data-menu-panel]'); if (panel) panel.classList.add('hidden');
      // Also deselect elements when Esc is pressed and not editing text or table cell
      const active = document.activeElement;
      const isEditing = active && (active.isContentEditable || active.tagName === 'INPUT' || active.tagName === 'TEXTAREA');
      if (!isEditing && (!window.tableSel)) { clearSelection(); }
    }
    // Delete selection via keyboard when not typing in inputs
    if (e.key === 'Delete' || e.key === 'Backspace'){
      const active = document.activeElement;
      const isEditing = active && (active.isContentEditable || active.tagName === 'INPUT' || active.tagName === 'TEXTAREA');
      if (!isEditing && selectedIds.size > 0){ e.preventDefault(); deleteSelection(); }
    }
    // Duplicate selection: Ctrl/Cmd + D
    if ((e.ctrlKey || e.metaKey) && (e.key === 'd' || e.key === 'D')){
      const active = document.activeElement;
      const isEditing = active && (active.isContentEditable || active.tagName === 'INPUT' || active.tagName === 'TEXTAREA');
      if (!isEditing && selectedIds.size > 0){ e.preventDefault(); copySelection(); }
    }
  });

  // Keep overlays anchored while scrolling containers
  document.addEventListener('scroll', () => { alignOverlays(); }, true);
  const vp = document.getElementById('pageViewport');
  if (vp) vp.addEventListener('scroll', alignOverlays, { passive: true });

  // Selection-box resize events
  const selBox = selectionBoxEl();
  selBox.addEventListener('mousedown', (e) => {
    // Disallow resizing when edit mode is off (fields should remain editable-only)
    if (!Model.document.editMode) return;
    const h = e.target.closest('.sb-h'); if (!h) return;
    startSelectionResize(h.dataset.handle, e);
    const onMove = (ev) => { applySelectionResize(ev); };
    const onUp = () => {
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
      if (resizeSelectionState){ commitHistory('resize-multi'); resizeSelectionState = null; hideGuides(); updateSelectionBox(); }
      if (rotateSelectionState){ rotateSelectionState = null; hideGuides(); updateSelectionBox(); }
    };
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    e.preventDefault(); e.stopPropagation();
  });
}

// Custom Color Picker like Canva
const COLOR_HISTORY_KEY = 'certificateMaker-colorHistory';
const MAX_COLOR_HISTORY = 8;

let currentColorInput = null;
let customColorPicker = null;
let deferredHistoryColor = null; // remember last chosen color while the picker is open

function getColorHistory() {
  try {
    const stored = JSON.parse(localStorage.getItem(COLOR_HISTORY_KEY) || '[]');
    // If no history exists, provide MonTech brand colors and essential colors
    if (stored.length === 0) {
      return [
        '#E10600', '#222222', '#F5F5F5', '#FFFFFF', 
        '#000000', '#808080', '#C0C0C0', '#E74C3C'
      ];
    }
    return stored;
  } catch {
    return [
      '#E10600', '#222222', '#F5F5F5', '#FFFFFF', 
      '#000000', '#808080', '#C0C0C0', '#E74C3C'
    ];
  }
}

function addToColorHistory(color) {
  if (!color || color === 'transparent') return;
  
  let history = getColorHistory();
  
  // Remove color if it already exists
  history = history.filter(c => c.toLowerCase() !== color.toLowerCase());
  
  // Add to beginning
  history.unshift(color);
  
  // Limit to max colors
  history = history.slice(0, MAX_COLOR_HISTORY);
  
  localStorage.setItem(COLOR_HISTORY_KEY, JSON.stringify(history));
  
  // Update the color picker if it's open
  if (customColorPicker && !customColorPicker.classList.contains('hidden')) {
    updateCustomColorPickerHistory();
  }
}

function createCustomColorPickerElement() {
  const picker = document.createElement('div');
  picker.className = 'custom-color-picker hidden';
  // Add data-role attributes so we can scope queries even if duplicate IDs existed in static HTML
  picker.innerHTML = `
    <div class="color-picker-section">
      <h4>Recent Colors</h4>
      <div class="color-history-grid" id="colorHistoryGrid" data-role="colorHistoryGrid"></div>
    </div>
    <div class="color-picker-section">
      <h4>Custom Color</h4>
      <div class="color-picker-input-wrapper">
        <input type="color" id="customColorInput" data-role="customColorInput" value="#000000">
        <input type="text" class="color-picker-hex" id="colorHexInput" data-role="colorHexInput" placeholder="#000000">
      </div>
    </div>
  `;

  document.body.appendChild(picker);
  ['pointerdown','mousedown'].forEach((evt) => {
    picker.addEventListener(evt, (e) => { e.stopPropagation(); }, true);
  });
  picker.addEventListener('click', (e) => { e.stopPropagation(); });
  return picker;
}

function updateCustomColorPickerHistory() {
  if (!customColorPicker) return;
  const grid = customColorPicker.querySelector('#colorHistoryGrid, [data-role="colorHistoryGrid"]');
  if (!grid) return;
  const history = getColorHistory();
  grid.innerHTML = '';
  history.forEach(color => {
    const circle = document.createElement('div');
    circle.className = 'color-history-circle';
    circle.style.backgroundColor = color;
    circle.title = color;
    circle.dataset.color = color;
    circle.addEventListener('click', () => {
      const colorInput = customColorPicker.querySelector('#customColorInput, [data-role="customColorInput"]');
      const hexInput = customColorPicker.querySelector('#colorHexInput, [data-role="colorHexInput"]');
      if (colorInput) colorInput.value = color;
      if (hexInput) hexInput.value = color;
      selectColor(color);
    });
    grid.appendChild(circle);
  });
}

function updateColorWithoutClosing(color) {
  if (!currentColorInput) return;
  
  // Update the input value
  currentColorInput.value = color;
  
  // Trigger events but don't close picker
  currentColorInput.dispatchEvent(new Event('input', { bubbles: true }));
}

function selectColor(color) {
  if (!currentColorInput) return;
  // Apply immediately without closing, so the first click takes effect
  updateColorWithoutClosing(color);
  // Defer reordering history until the picker closes to avoid chips jumping
  if (customColorPicker && !customColorPicker.classList.contains('hidden')) {
    deferredHistoryColor = color;
  } else {
    addToColorHistory(color);
  }
  // Fire a change event to signal commit
  currentColorInput.dispatchEvent(new Event('change', { bubbles: true }));
}

function showCustomColorPicker(input, x, y) {
  currentColorInput = input;
  
  if (!customColorPicker) {
    customColorPicker = createCustomColorPickerElement();
    
    // Set up custom color input events
  const colorInput = customColorPicker.querySelector('#customColorInput, [data-role="customColorInput"]');
  const hexInput = customColorPicker.querySelector('#colorHexInput, [data-role="colorHexInput"]');
    
    if (colorInput && hexInput) {
      colorInput.addEventListener('input', () => {
        hexInput.value = colorInput.value;
        updateColorWithoutClosing(colorInput.value);
      });
      colorInput.addEventListener('change', () => { selectColor(colorInput.value); });
      hexInput.addEventListener('input', () => {
        const color = hexInput.value;
        if (/^#[0-9A-F]{6}$/i.test(color)) { colorInput.value = color; updateColorWithoutClosing(color); }
      });
      hexInput.addEventListener('change', () => {
        const color = hexInput.value;
        if (/^#[0-9A-F]{6}$/i.test(color)) selectColor(color);
      });
    }
  }
  
  // Update history display
  updateCustomColorPickerHistory();
  
  // Set current color in the picker (scoped)
  const colorInput = customColorPicker.querySelector('#customColorInput, [data-role="customColorInput"]');
  const hexInput = customColorPicker.querySelector('#colorHexInput, [data-role="colorHexInput"]');
  if (colorInput) colorInput.value = input.value;
  if (hexInput) hexInput.value = input.value;
  
  // Position the picker
  customColorPicker.style.left = x + 'px';
  customColorPicker.style.top = y + 'px';
  
  // Show picker
  customColorPicker.classList.remove('hidden');
  
  // Adjust position if off-screen
  setTimeout(() => {
    const rect = customColorPicker.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    if (rect.right > viewportWidth) {
      customColorPicker.style.left = (viewportWidth - rect.width - 10) + 'px';
    }
    if (rect.bottom > viewportHeight) {
      customColorPicker.style.top = (viewportHeight - rect.height - 10) + 'px';
    }
  }, 0);
}

function hideCustomColorPicker() {
  if (customColorPicker) {
    customColorPicker.classList.add('hidden');
  }
  // Commit any deferred history update now that the picker is closed
  if (deferredHistoryColor) {
    try { addToColorHistory(deferredHistoryColor); } catch {}
    deferredHistoryColor = null;
  }
  currentColorInput = null;
}

function initializeCustomColorPicker() {
  // If multiple pickers were inlined (e.g. via saved HTML snapshot), remove extras so we manage one instance
  const existing = document.querySelectorAll('.custom-color-picker');
  if (existing.length > 1) {
    existing.forEach((el, idx) => { if (idx !== existing.length - 1) el.remove(); });
  }
  document.addEventListener('click', (e) => {
    const inputEl = e.target.closest('input[type="color"]');
    if (!inputEl) {
      if (customColorPicker && !customColorPicker.contains(e.target)) hideCustomColorPicker();
      return;
    }
    if (inputEl.closest('.custom-color-picker')) return; // native input inside picker
    e.preventDefault();
    e.stopPropagation();
    const rect = inputEl.getBoundingClientRect();
    showCustomColorPicker(inputEl, rect.left, rect.bottom + 5);
  });
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && customColorPicker && !customColorPicker.classList.contains('hidden')) hideCustomColorPicker();
  });
}

// Panel management functions
function updateWorkspacePadding() {
  const leftPanel = document.getElementById('elementsPanel');
  const rightPanel = document.getElementById('propertiesPanel');
  const viewport = document.getElementById('pageViewport');
  
  if (!viewport) return;
  
  if (!Model.document.editMode) {
    viewport.style.paddingLeft = '0';
    viewport.style.paddingRight = '0';
    return;
  }
  
  const leftCollapsed = leftPanel?.classList.contains('collapsed');
  const rightCollapsed = rightPanel?.classList.contains('collapsed');
  
  let leftPadding, rightPadding;
  
  if (leftCollapsed) {
    leftPadding = '44px'; // collapsed width + gap
  } else {
    const leftWidth = leftPanel?.offsetWidth || 200;
    leftPadding = `${leftWidth + 12}px`;
  }
  
  if (rightCollapsed) {
    rightPadding = '44px'; // collapsed width + gap
  } else {
    const rightWidth = rightPanel?.offsetWidth || 240;
    rightPadding = `${rightWidth + 12}px`;
  }
  
  viewport.style.paddingLeft = leftPadding;
  viewport.style.paddingRight = rightPadding;
}

function togglePanelCollapse(panelId) {
  const panel = document.getElementById(panelId);
  if (!panel) return;
  
  const isCollapsed = panel.classList.contains('collapsed');
  panel.classList.toggle('collapsed');
  
  // Update the toggle button icon
  const toggle = panel.querySelector('.panel-toggle');
  if (toggle) {
    // Use data-dir to control arrow orientation via CSS, no text glyphs
    if (panelId === 'elementsPanel') {
      toggle.setAttribute('data-dir', isCollapsed ? 'left' : 'right');
    } else if (panelId === 'propertiesPanel') {
      toggle.setAttribute('data-dir', isCollapsed ? 'right' : 'left');
    }
  }
  
  // Save state to localStorage
  localStorage.setItem(`${panelId}-collapsed`, !isCollapsed);
  
  updateWorkspacePadding();
  // Ensure centering updates after CSS transition finishes
  // Run on next frame and after the transition duration as a fallback
  requestAnimationFrame(() => updateWorkspacePadding());
  setTimeout(updateWorkspacePadding, 350);
}

function initializePanelResizing() {
  let currentResize = null;
  
  // Handle resize start
  document.addEventListener('mousedown', (e) => {
    const handle = e.target.closest('.panel-resize-handle');
    if (!handle) return;
    
    const panelId = handle.dataset.panel;
    const panel = document.getElementById(panelId);
    if (!panel) return;
    
    currentResize = {
      panel,
      panelId,
      isLeft: panel.classList.contains('left'),
      startX: e.clientX,
      startWidth: panel.offsetWidth
    };
    
    document.body.style.cursor = 'ew-resize';
    document.body.style.userSelect = 'none';
    
    e.preventDefault();
  });
  
  // Handle resize drag
  document.addEventListener('mousemove', (e) => {
    if (!currentResize) return;
    
    const { panel, panelId, isLeft, startX, startWidth } = currentResize;
    const deltaX = e.clientX - startX;
    
    let newWidth;
    if (isLeft) {
      newWidth = startWidth + deltaX;
    } else {
      newWidth = startWidth - deltaX;
    }
    
    // Clamp width between min and max values
    newWidth = Math.max(150, Math.min(400, newWidth));
    
    // Update panel width
    panel.style.width = `${newWidth}px`;
    
    // Update CSS custom property
    const property = isLeft ? '--left-panel-width' : '--right-panel-width';
    document.documentElement.style.setProperty(property, `${newWidth}px`);
    
    updateWorkspacePadding();
  });
  
  // Handle resize end
  document.addEventListener('mouseup', () => {
    if (currentResize) {
      const { panelId, isLeft } = currentResize;
      const panel = document.getElementById(panelId);
      const newWidth = panel.offsetWidth;
      
      // Save to localStorage
      localStorage.setItem(`${panelId}-width`, newWidth);
      
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      currentResize = null;
    }
  });
}

function restorePanelStates() {
  // Restore panel widths
  const leftWidth = localStorage.getItem('elementsPanel-width');
  if (leftWidth) {
    document.documentElement.style.setProperty('--left-panel-width', `${leftWidth}px`);
    document.getElementById('elementsPanel').style.width = `${leftWidth}px`;
  }
  
  const rightWidth = localStorage.getItem('propertiesPanel-width');
  if (rightWidth) {
    document.documentElement.style.setProperty('--right-panel-width', `${rightWidth}px`);
    document.getElementById('propertiesPanel').style.width = `${rightWidth}px`;
  }
  
  // Restore collapsed states
  const elementsCollapsed = localStorage.getItem('elementsPanel-collapsed') === 'true';
  const propertiesCollapsed = localStorage.getItem('propertiesPanel-collapsed') === 'true';
  
  if (elementsCollapsed) {
    togglePanelCollapse('elementsPanel');
  }
  if (propertiesCollapsed) {
    togglePanelCollapse('propertiesPanel');
  }
  
  updateWorkspacePadding();
}

function initializePanelControls() {
  // Add click handlers for toggle buttons
  document.getElementById('elementsToggle')?.addEventListener('click', () => {
    togglePanelCollapse('elementsPanel');
  });
  
  document.getElementById('propertiesToggle')?.addEventListener('click', () => {
    togglePanelCollapse('propertiesPanel');
  });
  
  initializePanelResizing();
  restorePanelStates();
  
  // Recalculate padding/centering on window resize
  window.addEventListener('resize', updateWorkspacePadding);
  // Also when side panels finish their width/pos transitions
  document.querySelectorAll('.side').forEach((panel) => {
    panel.addEventListener('transitionend', (e) => {
      if (e.propertyName === 'width' || e.propertyName === 'left' || e.propertyName === 'right') {
        updateWorkspacePadding();
      }
    });
  });
}

document.addEventListener('DOMContentLoaded', () => {
  bootstrap();
  initializePanelControls();
  initializeCustomColorPicker();
  // Initialize panel toggle arrow orientation
  const elT = document.getElementById('elementsToggle');
  const prT = document.getElementById('propertiesToggle');
  if (elT) elT.setAttribute('data-dir', document.getElementById('elementsPanel')?.classList.contains('collapsed') ? 'left' : 'right');
  if (prT) prT.setAttribute('data-dir', document.getElementById('propertiesPanel')?.classList.contains('collapsed') ? 'right' : 'left');
  const versionEl = document.getElementById('version');
  if (versionEl) versionEl.textContent = APP_VERSION;
  // Initialize hub/router after base editor wiring
  try { initializeHubRouter(); } catch {}
});





  </script>

</body></html>